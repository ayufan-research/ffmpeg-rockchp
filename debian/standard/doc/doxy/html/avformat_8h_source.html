<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FFmpeg: libavformat/avformat.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FFmpeg
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_c323f0049949ddd42f5d8cc7327305d9.html">libavformat</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">avformat.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="avformat_8h.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">/*</span></div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment"> * copyright (c) 2001 Fabrice Bellard</span></div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment"> * This file is part of FFmpeg.</span></div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment"> * FFmpeg is free software; you can redistribute it and/or</span></div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="comment"> * modify it under the terms of the GNU Lesser General Public</span></div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment"> * License as published by the Free Software Foundation; either</span></div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="comment"> * version 2.1 of the License, or (at your option) any later version.</span></div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="comment"> * FFmpeg is distributed in the hope that it will be useful,</span></div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span></div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span></div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="comment"> * Lesser General Public License for more details.</span></div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="comment"> * You should have received a copy of the GNU Lesser General Public</span></div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="comment"> * License along with FFmpeg; if not, write to the Free Software</span></div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="comment"> * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA</span></div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="preprocessor">#ifndef AVFORMAT_AVFORMAT_H</span></div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="preprocessor">#define AVFORMAT_AVFORMAT_H</span></div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="comment"> * @file</span></div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="comment"> * @ingroup libavf</span></div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="comment"> * Main libavformat public API header</span></div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;<span class="comment"> * @defgroup libavf libavformat</span></div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;<span class="comment"> * I/O and Muxing/Demuxing Library</span></div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;<span class="comment"> * Libavformat (lavf) is a library for dealing with various media container</span></div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;<span class="comment"> * formats. Its main two purposes are demuxing - i.e. splitting a media file</span></div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;<span class="comment"> * into component streams, and the reverse process of muxing - writing supplied</span></div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;<span class="comment"> * data in a specified container format. It also has an @ref lavf_io</span></div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;<span class="comment"> * &quot;I/O module&quot; which supports a number of protocols for accessing the data (e.g.</span></div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;<span class="comment"> * file, tcp, http and others). Before using lavf, you need to call</span></div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;<span class="comment"> * av_register_all() to register all compiled muxers, demuxers and protocols.</span></div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;<span class="comment"> * Unless you are absolutely sure you won&#39;t use libavformat&#39;s network</span></div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;<span class="comment"> * capabilities, you should also call avformat_network_init().</span></div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;<span class="comment"> * A supported input format is described by an AVInputFormat struct, conversely</span></div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;<span class="comment"> * an output format is described by AVOutputFormat. You can iterate over all</span></div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;<span class="comment"> * registered input/output formats using the av_iformat_next() /</span></div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;<span class="comment"> * av_oformat_next() functions. The protocols layer is not part of the public</span></div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;<span class="comment"> * API, so you can only get the names of supported protocols with the</span></div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;<span class="comment"> * avio_enum_protocols() function.</span></div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;<span class="comment"> * Main lavf structure used for both muxing and demuxing is AVFormatContext,</span></div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;<span class="comment"> * which exports all information about the file being read or written. As with</span></div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;<span class="comment"> * most Libavformat structures, its size is not part of public ABI, so it cannot be</span></div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;<span class="comment"> * allocated on stack or directly with av_malloc(). To create an</span></div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;<span class="comment"> * AVFormatContext, use avformat_alloc_context() (some functions, like</span></div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;<span class="comment"> * avformat_open_input() might do that for you).</span></div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;<span class="comment"> * Most importantly an AVFormatContext contains:</span></div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;<span class="comment"> * @li the @ref AVFormatContext.iformat &quot;input&quot; or @ref AVFormatContext.oformat</span></div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;<span class="comment"> * &quot;output&quot; format. It is either autodetected or set by user for input;</span></div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;<span class="comment"> * always set by user for output.</span></div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;<span class="comment"> * @li an @ref AVFormatContext.streams &quot;array&quot; of AVStreams, which describe all</span></div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;<span class="comment"> * elementary streams stored in the file. AVStreams are typically referred to</span></div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;<span class="comment"> * using their index in this array.</span></div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;<span class="comment"> * @li an @ref AVFormatContext.pb &quot;I/O context&quot;. It is either opened by lavf or</span></div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;<span class="comment"> * set by user for input, always set by user for output (unless you are dealing</span></div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;<span class="comment"> * with an AVFMT_NOFILE format).</span></div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;<span class="comment"> * @section lavf_options Passing options to (de)muxers</span></div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;<span class="comment"> * It is possible to configure lavf muxers and demuxers using the @ref avoptions</span></div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;<span class="comment"> * mechanism. Generic (format-independent) libavformat options are provided by</span></div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;<span class="comment"> * AVFormatContext, they can be examined from a user program by calling</span></div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;<span class="comment"> * av_opt_next() / av_opt_find() on an allocated AVFormatContext (or its AVClass</span></div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;<span class="comment"> * from avformat_get_class()). Private (format-specific) options are provided by</span></div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;<span class="comment"> * AVFormatContext.priv_data if and only if AVInputFormat.priv_class /</span></div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;<span class="comment"> * AVOutputFormat.priv_class of the corresponding format struct is non-NULL.</span></div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;<span class="comment"> * Further options may be provided by the @ref AVFormatContext.pb &quot;I/O context&quot;,</span></div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;<span class="comment"> * if its AVClass is non-NULL, and the protocols layer. See the discussion on</span></div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;<span class="comment"> * nesting in @ref avoptions documentation to learn how to access those.</span></div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;<span class="comment"> * @section urls</span></div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;<span class="comment"> * URL strings in libavformat are made of a scheme/protocol, a &#39;:&#39;, and a</span></div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;<span class="comment"> * scheme specific string. URLs without a scheme and &#39;:&#39; used for local files</span></div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;<span class="comment"> * are supported but deprecated. &quot;file:&quot; should be used for local files.</span></div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;<span class="comment"> * It is important that the scheme string is not taken from untrusted</span></div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;<span class="comment"> * sources without checks.</span></div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;<span class="comment"> * Note that some schemes/protocols are quite powerful, allowing access to</span></div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;<span class="comment"> * both local and remote files, parts of them, concatenations of them, local</span></div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;<span class="comment"> * audio and video devices and so on.</span></div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;<span class="comment"> * @{</span></div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;<span class="comment"> * @defgroup lavf_decoding Demuxing</span></div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;<span class="comment"> * @{</span></div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;<span class="comment"> * Demuxers read a media file and split it into chunks of data (@em packets). A</span></div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;<span class="comment"> * @ref AVPacket &quot;packet&quot; contains one or more encoded frames which belongs to a</span></div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;<span class="comment"> * single elementary stream. In the lavf API this process is represented by the</span></div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;<span class="comment"> * avformat_open_input() function for opening a file, av_read_frame() for</span></div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;<span class="comment"> * reading a single packet and finally avformat_close_input(), which does the</span></div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;<span class="comment"> * cleanup.</span></div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;<span class="comment"> * @section lavf_decoding_open Opening a media file</span></div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;<span class="comment"> * The minimum information required to open a file is its URL, which</span></div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;<span class="comment"> * is passed to avformat_open_input(), as in the following code:</span></div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;<span class="comment"> * @code</span></div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;<span class="comment"> * const char    *url = &quot;file:in.mp3&quot;;</span></div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;<span class="comment"> * AVFormatContext *s = NULL;</span></div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;<span class="comment"> * int ret = avformat_open_input(&amp;s, url, NULL, NULL);</span></div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;<span class="comment"> * if (ret &lt; 0)</span></div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;<span class="comment"> *     abort();</span></div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;<span class="comment"> * @endcode</span></div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;<span class="comment"> * The above code attempts to allocate an AVFormatContext, open the</span></div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;<span class="comment"> * specified file (autodetecting the format) and read the header, exporting the</span></div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;<span class="comment"> * information stored there into s. Some formats do not have a header or do not</span></div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;<span class="comment"> * store enough information there, so it is recommended that you call the</span></div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;<span class="comment"> * avformat_find_stream_info() function which tries to read and decode a few</span></div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;<span class="comment"> * frames to find missing information.</span></div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;<span class="comment"> * In some cases you might want to preallocate an AVFormatContext yourself with</span></div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;<span class="comment"> * avformat_alloc_context() and do some tweaking on it before passing it to</span></div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;<span class="comment"> * avformat_open_input(). One such case is when you want to use custom functions</span></div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;<span class="comment"> * for reading input data instead of lavf internal I/O layer.</span></div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;<span class="comment"> * To do that, create your own AVIOContext with avio_alloc_context(), passing</span></div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;<span class="comment"> * your reading callbacks to it. Then set the @em pb field of your</span></div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;<span class="comment"> * AVFormatContext to newly created AVIOContext.</span></div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;<span class="comment"> * Since the format of the opened file is in general not known until after</span></div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;<span class="comment"> * avformat_open_input() has returned, it is not possible to set demuxer private</span></div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;<span class="comment"> * options on a preallocated context. Instead, the options should be passed to</span></div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;<span class="comment"> * avformat_open_input() wrapped in an AVDictionary:</span></div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;<span class="comment"> * @code</span></div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;<span class="comment"> * AVDictionary *options = NULL;</span></div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;<span class="comment"> * av_dict_set(&amp;options, &quot;video_size&quot;, &quot;640x480&quot;, 0);</span></div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;<span class="comment"> * av_dict_set(&amp;options, &quot;pixel_format&quot;, &quot;rgb24&quot;, 0);</span></div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;<span class="comment"> * if (avformat_open_input(&amp;s, url, NULL, &amp;options) &lt; 0)</span></div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;<span class="comment"> *     abort();</span></div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;<span class="comment"> * av_dict_free(&amp;options);</span></div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;<span class="comment"> * @endcode</span></div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;<span class="comment"> * This code passes the private options &#39;video_size&#39; and &#39;pixel_format&#39; to the</span></div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;<span class="comment"> * demuxer. They would be necessary for e.g. the rawvideo demuxer, since it</span></div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;<span class="comment"> * cannot know how to interpret raw video data otherwise. If the format turns</span></div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;<span class="comment"> * out to be something different than raw video, those options will not be</span></div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;<span class="comment"> * recognized by the demuxer and therefore will not be applied. Such unrecognized</span></div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;<span class="comment"> * options are then returned in the options dictionary (recognized options are</span></div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;<span class="comment"> * consumed). The calling program can handle such unrecognized options as it</span></div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;<span class="comment"> * wishes, e.g.</span></div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;<span class="comment"> * @code</span></div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;<span class="comment"> * AVDictionaryEntry *e;</span></div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;<span class="comment"> * if (e = av_dict_get(options, &quot;&quot;, NULL, AV_DICT_IGNORE_SUFFIX)) {</span></div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;<span class="comment"> *     fprintf(stderr, &quot;Option %s not recognized by the demuxer.\n&quot;, e-&gt;key);</span></div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;<span class="comment"> *     abort();</span></div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;<span class="comment"> * }</span></div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;<span class="comment"> * @endcode</span></div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;<span class="comment"> * After you have finished reading the file, you must close it with</span></div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;<span class="comment"> * avformat_close_input(). It will free everything associated with the file.</span></div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;<span class="comment"> * @section lavf_decoding_read Reading from an opened file</span></div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;<span class="comment"> * Reading data from an opened AVFormatContext is done by repeatedly calling</span></div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;<span class="comment"> * av_read_frame() on it. Each call, if successful, will return an AVPacket</span></div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;<span class="comment"> * containing encoded data for one AVStream, identified by</span></div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;<span class="comment"> * AVPacket.stream_index. This packet may be passed straight into the libavcodec</span></div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;<span class="comment"> * decoding functions avcodec_send_packet() or avcodec_decode_subtitle2() if the</span></div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;<span class="comment"> * caller wishes to decode the data.</span></div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;<span class="comment"> * AVPacket.pts, AVPacket.dts and AVPacket.duration timing information will be</span></div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;<span class="comment"> * set if known. They may also be unset (i.e. AV_NOPTS_VALUE for</span></div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;<span class="comment"> * pts/dts, 0 for duration) if the stream does not provide them. The timing</span></div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;<span class="comment"> * information will be in AVStream.time_base units, i.e. it has to be</span></div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;<span class="comment"> * multiplied by the timebase to convert them to seconds.</span></div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;<span class="comment"> * If AVPacket.buf is set on the returned packet, then the packet is</span></div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;<span class="comment"> * allocated dynamically and the user may keep it indefinitely.</span></div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;<span class="comment"> * Otherwise, if AVPacket.buf is NULL, the packet data is backed by a</span></div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;<span class="comment"> * static storage somewhere inside the demuxer and the packet is only valid</span></div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;<span class="comment"> * until the next av_read_frame() call or closing the file. If the caller</span></div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;<span class="comment"> * requires a longer lifetime, av_dup_packet() will make an av_malloc()ed copy</span></div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;<span class="comment"> * of it.</span></div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;<span class="comment"> * In both cases, the packet must be freed with av_packet_unref() when it is no</span></div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;<span class="comment"> * longer needed.</span></div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;<span class="comment"> * @section lavf_decoding_seek Seeking</span></div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;<span class="comment"> * @}</span></div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;<span class="comment"> * @defgroup lavf_encoding Muxing</span></div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;<span class="comment"> * @{</span></div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;<span class="comment"> * Muxers take encoded data in the form of @ref AVPacket &quot;AVPackets&quot; and write</span></div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;<span class="comment"> * it into files or other output bytestreams in the specified container format.</span></div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;<span class="comment"> * The main API functions for muxing are avformat_write_header() for writing the</span></div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;<span class="comment"> * file header, av_write_frame() / av_interleaved_write_frame() for writing the</span></div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;<span class="comment"> * packets and av_write_trailer() for finalizing the file.</span></div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;<span class="comment"> * At the beginning of the muxing process, the caller must first call</span></div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;<span class="comment"> * avformat_alloc_context() to create a muxing context. The caller then sets up</span></div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;<span class="comment"> * the muxer by filling the various fields in this context:</span></div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;<span class="comment"> * - The @ref AVFormatContext.oformat &quot;oformat&quot; field must be set to select the</span></div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;<span class="comment"> *   muxer that will be used.</span></div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;<span class="comment"> * - Unless the format is of the AVFMT_NOFILE type, the @ref AVFormatContext.pb</span></div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;<span class="comment"> *   &quot;pb&quot; field must be set to an opened IO context, either returned from</span></div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;<span class="comment"> *   avio_open2() or a custom one.</span></div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;<span class="comment"> * - Unless the format is of the AVFMT_NOSTREAMS type, at least one stream must</span></div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;<span class="comment"> *   be created with the avformat_new_stream() function. The caller should fill</span></div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;<span class="comment"> *   the @ref AVStream.codecpar &quot;stream codec parameters&quot; information, such as the</span></div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;<span class="comment"> *   codec @ref AVCodecParameters.codec_type &quot;type&quot;, @ref AVCodecParameters.codec_id</span></div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;<span class="comment"> *   &quot;id&quot; and other parameters (e.g. width / height, the pixel or sample format,</span></div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;<span class="comment"> *   etc.) as known. The @ref AVStream.time_base &quot;stream timebase&quot; should</span></div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;<span class="comment"> *   be set to the timebase that the caller desires to use for this stream (note</span></div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;<span class="comment"> *   that the timebase actually used by the muxer can be different, as will be</span></div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;<span class="comment"> *   described later).</span></div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;<span class="comment"> * - It is advised to manually initialize only the relevant fields in</span></div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;<span class="comment"> *   AVCodecParameters, rather than using @ref avcodec_parameters_copy() during</span></div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;<span class="comment"> *   remuxing: there is no guarantee that the codec context values remain valid</span></div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;<span class="comment"> *   for both input and output format contexts.</span></div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;<span class="comment"> * - The caller may fill in additional information, such as @ref</span></div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;<span class="comment"> *   AVFormatContext.metadata &quot;global&quot; or @ref AVStream.metadata &quot;per-stream&quot;</span></div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;<span class="comment"> *   metadata, @ref AVFormatContext.chapters &quot;chapters&quot;, @ref</span></div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;<span class="comment"> *   AVFormatContext.programs &quot;programs&quot;, etc. as described in the</span></div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;<span class="comment"> *   AVFormatContext documentation. Whether such information will actually be</span></div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;<span class="comment"> *   stored in the output depends on what the container format and the muxer</span></div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;<span class="comment"> *   support.</span></div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;<span class="comment"> * When the muxing context is fully set up, the caller must call</span></div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;<span class="comment"> * avformat_write_header() to initialize the muxer internals and write the file</span></div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;<span class="comment"> * header. Whether anything actually is written to the IO context at this step</span></div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;<span class="comment"> * depends on the muxer, but this function must always be called. Any muxer</span></div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;<span class="comment"> * private options must be passed in the options parameter to this function.</span></div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;<span class="comment"> * The data is then sent to the muxer by repeatedly calling av_write_frame() or</span></div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;<span class="comment"> * av_interleaved_write_frame() (consult those functions&#39; documentation for</span></div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;<span class="comment"> * discussion on the difference between them; only one of them may be used with</span></div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;<span class="comment"> * a single muxing context, they should not be mixed). Do note that the timing</span></div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;<span class="comment"> * information on the packets sent to the muxer must be in the corresponding</span></div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;<span class="comment"> * AVStream&#39;s timebase. That timebase is set by the muxer (in the</span></div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;<span class="comment"> * avformat_write_header() step) and may be different from the timebase</span></div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;<span class="comment"> * requested by the caller.</span></div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;<span class="comment"> * Once all the data has been written, the caller must call av_write_trailer()</span></div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;<span class="comment"> * to flush any buffered packets and finalize the output file, then close the IO</span></div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;<span class="comment"> * context (if any) and finally free the muxing context with</span></div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;<span class="comment"> * avformat_free_context().</span></div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;<span class="comment"> * @}</span></div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;<span class="comment"> * @defgroup lavf_io I/O Read/Write</span></div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;<span class="comment"> * @{</span></div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;<span class="comment"> * @section lavf_io_dirlist Directory listing</span></div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;<span class="comment"> * The directory listing API makes it possible to list files on remote servers.</span></div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;<span class="comment"> * Some of possible use cases:</span></div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;<span class="comment"> * - an &quot;open file&quot; dialog to choose files from a remote location,</span></div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;<span class="comment"> * - a recursive media finder providing a player with an ability to play all</span></div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;<span class="comment"> * files from a given directory.</span></div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;<span class="comment"> * @subsection lavf_io_dirlist_open Opening a directory</span></div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;<span class="comment"> * At first, a directory needs to be opened by calling avio_open_dir()</span></div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;<span class="comment"> * supplied with a URL and, optionally, ::AVDictionary containing</span></div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;<span class="comment"> * protocol-specific parameters. The function returns zero or positive</span></div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;<span class="comment"> * integer and allocates AVIODirContext on success.</span></div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;<span class="comment"> * @code</span></div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;<span class="comment"> * AVIODirContext *ctx = NULL;</span></div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;<span class="comment"> * if (avio_open_dir(&amp;ctx, &quot;smb://example.com/some_dir&quot;, NULL) &lt; 0) {</span></div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;<span class="comment"> *     fprintf(stderr, &quot;Cannot open directory.\n&quot;);</span></div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;<span class="comment"> *     abort();</span></div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;<span class="comment"> * }</span></div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;<span class="comment"> * @endcode</span></div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;<span class="comment"> * This code tries to open a sample directory using smb protocol without</span></div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;<span class="comment"> * any additional parameters.</span></div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;<span class="comment"> * @subsection lavf_io_dirlist_read Reading entries</span></div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;<span class="comment"> * Each directory&#39;s entry (i.e. file, another directory, anything else</span></div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;<span class="comment"> * within ::AVIODirEntryType) is represented by AVIODirEntry.</span></div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;<span class="comment"> * Reading consecutive entries from an opened AVIODirContext is done by</span></div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;<span class="comment"> * repeatedly calling avio_read_dir() on it. Each call returns zero or</span></div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;<span class="comment"> * positive integer if successful. Reading can be stopped right after the</span></div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;<span class="comment"> * NULL entry has been read -- it means there are no entries left to be</span></div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;<span class="comment"> * read. The following code reads all entries from a directory associated</span></div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;<span class="comment"> * with ctx and prints their names to standard output.</span></div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;<span class="comment"> * @code</span></div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;<span class="comment"> * AVIODirEntry *entry = NULL;</span></div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;<span class="comment"> * for (;;) {</span></div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;<span class="comment"> *     if (avio_read_dir(ctx, &amp;entry) &lt; 0) {</span></div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;<span class="comment"> *         fprintf(stderr, &quot;Cannot list directory.\n&quot;);</span></div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;<span class="comment"> *         abort();</span></div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;<span class="comment"> *     }</span></div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;<span class="comment"> *     if (!entry)</span></div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;<span class="comment"> *         break;</span></div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;<span class="comment"> *     printf(&quot;%s\n&quot;, entry-&gt;name);</span></div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;<span class="comment"> *     avio_free_directory_entry(&amp;entry);</span></div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;<span class="comment"> * }</span></div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;<span class="comment"> * @endcode</span></div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;<span class="comment"> * @}</span></div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;<span class="comment"> * @defgroup lavf_codec Demuxers</span></div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;<span class="comment"> * @{</span></div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;<span class="comment"> * @defgroup lavf_codec_native Native Demuxers</span></div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;<span class="comment"> * @{</span></div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;<span class="comment"> * @}</span></div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;<span class="comment"> * @defgroup lavf_codec_wrappers External library wrappers</span></div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;<span class="comment"> * @{</span></div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;<span class="comment"> * @}</span></div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;<span class="comment"> * @}</span></div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;<span class="comment"> * @defgroup lavf_protos I/O Protocols</span></div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;<span class="comment"> * @{</span></div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;<span class="comment"> * @}</span></div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;<span class="comment"> * @defgroup lavf_internal Internal</span></div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;<span class="comment"> * @{</span></div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;<span class="comment"> * @}</span></div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;<span class="comment"> * @}</span></div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="time_8h.html">time.h</a>&gt;</span></div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;<span class="preprocessor">#include &lt;stdio.h&gt;</span>  <span class="comment">/* FILE */</span></div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="avcodec_8h.html">libavcodec/avcodec.h</a>&quot;</span></div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="dict_8h.html">libavutil/dict.h</a>&quot;</span></div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="log_8h.html">libavutil/log.h</a>&quot;</span></div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="avio_8h.html">avio.h</a>&quot;</span></div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="libavformat_2version_8h.html">libavformat/version.h</a>&quot;</span></div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;<span class="keyword">struct </span><a class="code" href="structAVFormatContext.html">AVFormatContext</a>;</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;<span class="keyword">struct </span><a class="code" href="structAVDeviceInfoList.html">AVDeviceInfoList</a>;</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;<span class="keyword">struct </span><a class="code" href="structAVDeviceCapabilitiesQuery.html">AVDeviceCapabilitiesQuery</a>;</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;<span class="comment"> * @defgroup metadata_api Public Metadata API</span></div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;<span class="comment"> * @{</span></div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;<span class="comment"> * @ingroup libavf</span></div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;<span class="comment"> * The metadata API allows libavformat to export metadata tags to a client</span></div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;<span class="comment"> * application when demuxing. Conversely it allows a client application to</span></div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;<span class="comment"> * set metadata when muxing.</span></div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;<span class="comment"> * Metadata is exported or set as pairs of key/value strings in the &#39;metadata&#39;</span></div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;<span class="comment"> * fields of the AVFormatContext, AVStream, AVChapter and AVProgram structs</span></div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;<span class="comment"> * using the @ref lavu_dict &quot;AVDictionary&quot; API. Like all strings in FFmpeg,</span></div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;<span class="comment"> * metadata is assumed to be UTF-8 encoded Unicode. Note that metadata</span></div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;<span class="comment"> * exported by demuxers isn&#39;t checked to be valid UTF-8 in most cases.</span></div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;<span class="comment"> * Important concepts to keep in mind:</span></div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;<span class="comment"> * -  Keys are unique; there can never be 2 tags with the same key. This is</span></div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;<span class="comment"> *    also meant semantically, i.e., a demuxer should not knowingly produce</span></div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;<span class="comment"> *    several keys that are literally different but semantically identical.</span></div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;<span class="comment"> *    E.g., key=Author5, key=Author6. In this example, all authors must be</span></div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;<span class="comment"> *    placed in the same tag.</span></div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;<span class="comment"> * -  Metadata is flat, not hierarchical; there are no subtags. If you</span></div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;<span class="comment"> *    want to store, e.g., the email address of the child of producer Alice</span></div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;<span class="comment"> *    and actor Bob, that could have key=alice_and_bobs_childs_email_address.</span></div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;<span class="comment"> * -  Several modifiers can be applied to the tag name. This is done by</span></div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;<span class="comment"> *    appending a dash character (&#39;-&#39;) and the modifier name in the order</span></div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;<span class="comment"> *    they appear in the list below -- e.g. foo-eng-sort, not foo-sort-eng.</span></div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;<span class="comment"> *    -  language -- a tag whose value is localized for a particular language</span></div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;<span class="comment"> *       is appended with the ISO 639-2/B 3-letter language code.</span></div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;<span class="comment"> *       For example: Author-ger=Michael, Author-eng=Mike</span></div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;<span class="comment"> *       The original/default language is in the unqualified &quot;Author&quot; tag.</span></div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;<span class="comment"> *       A demuxer should set a default if it sets any translated tag.</span></div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;<span class="comment"> *    -  sorting  -- a modified version of a tag that should be used for</span></div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;<span class="comment"> *       sorting will have &#39;-sort&#39; appended. E.g. artist=&quot;The Beatles&quot;,</span></div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;<span class="comment"> *       artist-sort=&quot;Beatles, The&quot;.</span></div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;<span class="comment"> * - Some protocols and demuxers support metadata updates. After a successful</span></div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;<span class="comment"> *   call to av_read_packet(), AVFormatContext.event_flags or AVStream.event_flags</span></div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;<span class="comment"> *   will be updated to indicate if metadata changed. In order to detect metadata</span></div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;<span class="comment"> *   changes on a stream, you need to loop through all streams in the AVFormatContext</span></div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;<span class="comment"> *   and check their individual event_flags.</span></div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;<span class="comment"> * -  Demuxers attempt to export metadata in a generic format, however tags</span></div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;<span class="comment"> *    with no generic equivalents are left as they are stored in the container.</span></div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;<span class="comment"> *    Follows a list of generic tag names:</span></div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;<span class="comment"> @verbatim</span></div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;<span class="comment"> album        -- name of the set this work belongs to</span></div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;<span class="comment"> album_artist -- main creator of the set/album, if different from artist.</span></div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;<span class="comment">                 e.g. &quot;Various Artists&quot; for compilation albums.</span></div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;<span class="comment"> artist       -- main creator of the work</span></div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;<span class="comment"> comment      -- any additional description of the file.</span></div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;<span class="comment"> composer     -- who composed the work, if different from artist.</span></div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;<span class="comment"> copyright    -- name of copyright holder.</span></div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;<span class="comment"> creation_time-- date when the file was created, preferably in ISO 8601.</span></div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;<span class="comment"> date         -- date when the work was created, preferably in ISO 8601.</span></div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;<span class="comment"> disc         -- number of a subset, e.g. disc in a multi-disc collection.</span></div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;<span class="comment"> encoder      -- name/settings of the software/hardware that produced the file.</span></div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;<span class="comment"> encoded_by   -- person/group who created the file.</span></div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;<span class="comment"> filename     -- original name of the file.</span></div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;<span class="comment"> genre        -- &lt;self-evident&gt;.</span></div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;<span class="comment"> language     -- main language in which the work is performed, preferably</span></div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;<span class="comment">                 in ISO 639-2 format. Multiple languages can be specified by</span></div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;<span class="comment">                 separating them with commas.</span></div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;<span class="comment"> performer    -- artist who performed the work, if different from artist.</span></div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;<span class="comment">                 E.g for &quot;Also sprach Zarathustra&quot;, artist would be &quot;Richard</span></div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;<span class="comment">                 Strauss&quot; and performer &quot;London Philharmonic Orchestra&quot;.</span></div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;<span class="comment"> publisher    -- name of the label/publisher.</span></div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;<span class="comment"> service_name     -- name of the service in broadcasting (channel name).</span></div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;<span class="comment"> service_provider -- name of the service provider in broadcasting.</span></div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;<span class="comment"> title        -- name of the work.</span></div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;<span class="comment"> track        -- number of this work in the set, can be in form current/total.</span></div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;<span class="comment"> variant_bitrate -- the total bitrate of the bitrate variant that the current stream is part of</span></div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;<span class="comment"> @endverbatim</span></div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;<span class="comment"> * Look in the examples section for an application example how to use the Metadata API.</span></div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;<span class="comment"> * @}</span></div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;<span class="comment">/* packet functions */</span></div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;<span class="comment"> * Allocate and read the payload of a packet and initialize its</span></div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;<span class="comment"> * fields with default values.</span></div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;<span class="comment"> * @param s    associated IO context</span></div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;<span class="comment"> * @param pkt packet</span></div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;<span class="comment"> * @param size desired payload size</span></div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;<span class="comment"> * @return &gt;0 (read size) if OK, AVERROR_xxx otherwise</span></div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;<span class="keywordtype">int</span> <a class="code" href="avformat_8h.html#a9d2e6f22150d98c36dcc2c6c49318019">av_get_packet</a>(<a class="code" href="structAVIOContext.html">AVIOContext</a> *s, <a class="code" href="structAVPacket.html">AVPacket</a> *<a class="code" href="demuxing__decoding_8c.html#a3d4c6562f0b27cf0cacbbea5c038c090">pkt</a>, <span class="keywordtype">int</span> size);</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;<span class="comment"> * Read data and append it to the current content of the AVPacket.</span></div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;<span class="comment"> * If pkt-&gt;size is 0 this is identical to av_get_packet.</span></div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;<span class="comment"> * Note that this uses av_grow_packet and thus involves a realloc</span></div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;<span class="comment"> * which is inefficient. Thus this function should only be used</span></div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;<span class="comment"> * when there is no reasonable way to know (an upper bound of)</span></div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;<span class="comment"> * the final size.</span></div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;<span class="comment"> * @param s    associated IO context</span></div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;<span class="comment"> * @param pkt packet</span></div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;<span class="comment"> * @param size amount of data to read</span></div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;<span class="comment"> * @return &gt;0 (read size) if OK, AVERROR_xxx otherwise, previous data</span></div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;<span class="comment"> *         will not be lost even if an error occurs.</span></div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;<span class="keywordtype">int</span> <a class="code" href="avformat_8h.html#a0e991213ccc3d642972b57a1decb797b">av_append_packet</a>(<a class="code" href="structAVIOContext.html">AVIOContext</a> *s, <a class="code" href="structAVPacket.html">AVPacket</a> *<a class="code" href="demuxing__decoding_8c.html#a3d4c6562f0b27cf0cacbbea5c038c090">pkt</a>, <span class="keywordtype">int</span> size);</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;<span class="comment">/*************************************************/</span></div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;<span class="comment">/* input/output formats */</span></div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;<span class="keyword">struct </span>AVCodecTag;</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;<span class="comment"> * This structure contains the data a format has to probe a file.</span></div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l00448"></a><span class="lineno"><a class="line" href="structAVProbeData.html">  448</a></span>&#160;<span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structAVProbeData.html">AVProbeData</a> {</div><div class="line"><a name="l00449"></a><span class="lineno"><a class="line" href="structAVProbeData.html#a0e8504127aff8af25cc9f3c6400b9651">  449</a></span>&#160;    <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structAVProbeData.html#a0e8504127aff8af25cc9f3c6400b9651">filename</a>;</div><div class="line"><a name="l00450"></a><span class="lineno"><a class="line" href="structAVProbeData.html#a814cca49dda3f578ebb32d4b2f74368a">  450</a></span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *<a class="code" href="structAVProbeData.html#a814cca49dda3f578ebb32d4b2f74368a">buf</a>; <span class="comment">/**&lt; Buffer must have AVPROBE_PADDING_SIZE of extra allocated bytes filled with zero. */</span></div><div class="line"><a name="l00451"></a><span class="lineno"><a class="line" href="structAVProbeData.html#a30309e4de25c1a411c635eab767e1e53">  451</a></span>&#160;    <span class="keywordtype">int</span> <a class="code" href="structAVProbeData.html#a30309e4de25c1a411c635eab767e1e53">buf_size</a>;       <span class="comment">/**&lt; Size of buf except extra allocated bytes */</span></div><div class="line"><a name="l00452"></a><span class="lineno"><a class="line" href="structAVProbeData.html#a20533bdafa6230d2ef8392cb7cb38382">  452</a></span>&#160;    <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structAVProbeData.html#a20533bdafa6230d2ef8392cb7cb38382">mime_type</a>; <span class="comment">/**&lt; mime_type, when known. */</span></div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;} <a class="code" href="structAVProbeData.html">AVProbeData</a>;</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;</div><div class="line"><a name="l00455"></a><span class="lineno"><a class="line" href="avformat_8h.html#adeacd8263046043734062588db39bce9">  455</a></span>&#160;<span class="preprocessor">#define AVPROBE_SCORE_RETRY (AVPROBE_SCORE_MAX/4)</span></div><div class="line"><a name="l00456"></a><span class="lineno"><a class="line" href="avformat_8h.html#a1b33e0f3734db4299d5aff4b78f98c43">  456</a></span>&#160;<span class="preprocessor">#define AVPROBE_SCORE_STREAM_RETRY (AVPROBE_SCORE_MAX/4-1)</span></div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;</div><div class="line"><a name="l00458"></a><span class="lineno"><a class="line" href="avformat_8h.html#a8fef570c1a6f9c445acaf97fa2da3b7e">  458</a></span>&#160;<span class="preprocessor">#define AVPROBE_SCORE_EXTENSION  50 </span><span class="comment">///&lt; score for file extension</span></div><div class="line"><a name="l00459"></a><span class="lineno"><a class="line" href="avformat_8h.html#a09af1c3eb8b432e16f1594f57d899aef">  459</a></span>&#160;<span class="comment"></span>#define AVPROBE_SCORE_MIME       75 <span class="comment">///&lt; score for file mime type</span></div><div class="line"><a name="l00460"></a><span class="lineno"><a class="line" href="avformat_8h.html#a24925a4d1138c3f17a7a27dd45c08920">  460</a></span>&#160;<span class="comment"></span>#define AVPROBE_SCORE_MAX       100 <span class="comment">///&lt; maximum score</span></div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00462"></a><span class="lineno"><a class="line" href="avformat_8h.html#a2cba242c83a06fff914d1c8ef4cd42ac">  462</a></span>&#160;<span class="preprocessor">#define AVPROBE_PADDING_SIZE 32             </span><span class="comment">///&lt; extra allocated bytes at the end of the probe buffer</span></div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;<span class="comment">/// Demuxer will use avio_open, no opened file should be provided by the caller.</span></div><div class="line"><a name="l00465"></a><span class="lineno"><a class="line" href="avformat_8h.html#a752cce390d480521919aa5d8be24ac0b">  465</a></span>&#160;<span class="comment"></span><span class="preprocessor">#define AVFMT_NOFILE        0x0001</span></div><div class="line"><a name="l00466"></a><span class="lineno"><a class="line" href="avformat_8h.html#af7899d15bd762258202bdec2035d8fc8">  466</a></span>&#160;<span class="preprocessor">#define AVFMT_NEEDNUMBER    0x0002 </span><span class="comment">/**&lt; Needs &#39;%d&#39; in filename. */</span><span class="preprocessor"></span></div><div class="line"><a name="l00467"></a><span class="lineno"><a class="line" href="avformat_8h.html#a90e4cbd1011b989cd7db628d2eca2675">  467</a></span>&#160;<span class="preprocessor">#define AVFMT_SHOW_IDS      0x0008 </span><span class="comment">/**&lt; Show format stream IDs numbers. */</span><span class="preprocessor"></span></div><div class="line"><a name="l00468"></a><span class="lineno"><a class="line" href="avformat_8h.html#ab203c7b734e9c31b7c37d34f6e2c6aef">  468</a></span>&#160;<span class="preprocessor">#define AVFMT_GLOBALHEADER  0x0040 </span><span class="comment">/**&lt; Format wants global header. */</span><span class="preprocessor"></span></div><div class="line"><a name="l00469"></a><span class="lineno"><a class="line" href="avformat_8h.html#ae4418d32b17890be22da9c5f95087168">  469</a></span>&#160;<span class="preprocessor">#define AVFMT_NOTIMESTAMPS  0x0080 </span><span class="comment">/**&lt; Format does not need / have any timestamps. */</span><span class="preprocessor"></span></div><div class="line"><a name="l00470"></a><span class="lineno"><a class="line" href="avformat_8h.html#ad2bd0ecdd51061b300e2ab490907bb09">  470</a></span>&#160;<span class="preprocessor">#define AVFMT_GENERIC_INDEX 0x0100 </span><span class="comment">/**&lt; Use generic index building code. */</span><span class="preprocessor"></span></div><div class="line"><a name="l00471"></a><span class="lineno"><a class="line" href="avformat_8h.html#a4d232408e799fa2b2f2705a3e8e0b4b8">  471</a></span>&#160;<span class="preprocessor">#define AVFMT_TS_DISCONT    0x0200 </span><span class="comment">/**&lt; Format allows timestamp discontinuities. Note, muxers always require valid (monotone) timestamps */</span><span class="preprocessor"></span></div><div class="line"><a name="l00472"></a><span class="lineno"><a class="line" href="avformat_8h.html#a4d9f21e76a3bf919c74ea40957ef21a7">  472</a></span>&#160;<span class="preprocessor">#define AVFMT_VARIABLE_FPS  0x0400 </span><span class="comment">/**&lt; Format allows variable fps. */</span><span class="preprocessor"></span></div><div class="line"><a name="l00473"></a><span class="lineno"><a class="line" href="avformat_8h.html#a21abb57f90931c92c853e696cc1c358c">  473</a></span>&#160;<span class="preprocessor">#define AVFMT_NODIMENSIONS  0x0800 </span><span class="comment">/**&lt; Format does not need width/height */</span><span class="preprocessor"></span></div><div class="line"><a name="l00474"></a><span class="lineno"><a class="line" href="avformat_8h.html#a1500ed92d07addf13d1e9dfd0fff6672">  474</a></span>&#160;<span class="preprocessor">#define AVFMT_NOSTREAMS     0x1000 </span><span class="comment">/**&lt; Format does not require any streams */</span><span class="preprocessor"></span></div><div class="line"><a name="l00475"></a><span class="lineno"><a class="line" href="avformat_8h.html#a8f47c7c3b5763fc7199f41741d759a70">  475</a></span>&#160;<span class="preprocessor">#define AVFMT_NOBINSEARCH   0x2000 </span><span class="comment">/**&lt; Format does not allow to fall back on binary search via read_timestamp */</span><span class="preprocessor"></span></div><div class="line"><a name="l00476"></a><span class="lineno"><a class="line" href="avformat_8h.html#a860dc077e9c782de0d49a2d4d968b64a">  476</a></span>&#160;<span class="preprocessor">#define AVFMT_NOGENSEARCH   0x4000 </span><span class="comment">/**&lt; Format does not allow to fall back on generic search */</span><span class="preprocessor"></span></div><div class="line"><a name="l00477"></a><span class="lineno"><a class="line" href="avformat_8h.html#a6286e2977286a22b622cb51cf4106541">  477</a></span>&#160;<span class="preprocessor">#define AVFMT_NO_BYTE_SEEK  0x8000 </span><span class="comment">/**&lt; Format does not allow seeking by bytes */</span><span class="preprocessor"></span></div><div class="line"><a name="l00478"></a><span class="lineno"><a class="line" href="avformat_8h.html#a3b9a2012b993edb9e2ba3db6d55db1ae">  478</a></span>&#160;<span class="preprocessor">#define AVFMT_ALLOW_FLUSH  0x10000 </span><span class="comment">/**&lt; Format allows flushing. If not set, the muxer will not receive a NULL packet in the write_packet function. */</span><span class="preprocessor"></span></div><div class="line"><a name="l00479"></a><span class="lineno"><a class="line" href="avformat_8h.html#a918dc7abf0d4f7abd36a2ea2a594feaf">  479</a></span>&#160;<span class="preprocessor">#define AVFMT_TS_NONSTRICT 0x20000 </span><span class="comment">/**&lt; Format does not require strictly</span></div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;<span class="comment">                                        increasing timestamps, but they must</span></div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;<span class="comment">                                        still be monotonic */</span><span class="preprocessor"></span></div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;<span class="preprocessor">#define AVFMT_TS_NEGATIVE  0x40000 </span><span class="comment">/**&lt; Format allows muxing negative</span></div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;<span class="comment">                                        timestamps. If not set the timestamp</span></div><div class="line"><a name="l00484"></a><span class="lineno"><a class="line" href="avformat_8h.html#a886476ebe41f52a2232ee10f97ac11d0">  484</a></span>&#160;<span class="comment">                                        will be shifted in av_write_frame and</span></div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;<span class="comment">                                        av_interleaved_write_frame so they</span></div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;<span class="comment">                                        start from 0.</span></div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;<span class="comment">                                        The user or muxer can override this through</span></div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;<span class="comment">                                        AVFormatContext.avoid_negative_ts</span></div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;<span class="comment">                                        */</span><span class="preprocessor"></span></div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;<span class="preprocessor">#define AVFMT_SEEK_TO_PTS   0x4000000 </span><span class="comment">/**&lt; Seeking is based on PTS */</span><span class="preprocessor"></span></div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;<span class="comment"> * @addtogroup lavf_encoding</span></div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;<span class="comment"> * @{</span></div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;<span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structAVOutputFormat.html">AVOutputFormat</a> {</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">char</span> *name;<span class="comment"></span></div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00500"></a><span class="lineno"><a class="line" href="avformat_8h.html#ab87b74d5eff79c28e7756f893d57c4d7">  500</a></span>&#160;<span class="comment">     * Descriptive name for the format, meant to be more human-readable</span></div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;<span class="comment">     * than name. You should use the NULL_IF_CONFIG_SMALL() macro</span></div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;<span class="comment">     * to define it.</span></div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">char</span> *long_name;</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structAVProbeData.html#a20533bdafa6230d2ef8392cb7cb38382">mime_type</a>;</div><div class="line"><a name="l00506"></a><span class="lineno"><a class="line" href="structAVOutputFormat.html">  506</a></span>&#160;    <span class="keyword">const</span> <span class="keywordtype">char</span> *extensions; <span class="comment">/**&lt; comma-separated filename extensions */</span></div><div class="line"><a name="l00507"></a><span class="lineno"><a class="line" href="structAVOutputFormat.html#ac3abc5f47f3465b6b7eec89c9476351c">  507</a></span>&#160;    <span class="comment">/* output support */</span></div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;    <span class="keyword">enum</span> <a class="code" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a> audio_codec;    <span class="comment">/**&lt; default audio codec */</span></div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;    <span class="keyword">enum</span> <a class="code" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a> video_codec;    <span class="comment">/**&lt; default video codec */</span></div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;    <span class="keyword">enum</span> <a class="code" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a> subtitle_codec; <span class="comment">/**&lt; default subtitle codec */</span><span class="comment"></span></div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;<span class="comment">     * can use flags: AVFMT_NOFILE, AVFMT_NEEDNUMBER,</span></div><div class="line"><a name="l00513"></a><span class="lineno"><a class="line" href="structAVOutputFormat.html#a4ff98d90aac0047a204a35a758a363fc">  513</a></span>&#160;<span class="comment">     * AVFMT_GLOBALHEADER, AVFMT_NOTIMESTAMPS, AVFMT_VARIABLE_FPS,</span></div><div class="line"><a name="l00514"></a><span class="lineno"><a class="line" href="structAVOutputFormat.html#ad94e0c8bd362cb9ffbfc44514481fc75">  514</a></span>&#160;<span class="comment">     * AVFMT_NODIMENSIONS, AVFMT_NOSTREAMS, AVFMT_ALLOW_FLUSH,</span></div><div class="line"><a name="l00515"></a><span class="lineno"><a class="line" href="structAVOutputFormat.html#a10f19abe463890063659723c90c15335">  515</a></span>&#160;<span class="comment">     * AVFMT_TS_NONSTRICT, AVFMT_TS_NEGATIVE</span></div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00517"></a><span class="lineno"><a class="line" href="structAVOutputFormat.html#a2e4fff0aa061984d586ea08ecad96141">  517</a></span>&#160;    <span class="keywordtype">int</span> flags;</div><div class="line"><a name="l00518"></a><span class="lineno"><a class="line" href="structAVOutputFormat.html#a1354a9c8542b1b698157218336bd4754">  518</a></span>&#160;<span class="comment"></span></div><div class="line"><a name="l00519"></a><span class="lineno"><a class="line" href="structAVOutputFormat.html#adc8b4d7a5f6610e1816dd522e362217c">  519</a></span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;<span class="comment">     * List of supported codec_id-codec_tag pairs, ordered by &quot;better</span></div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;<span class="comment">     * choice first&quot;. The arrays are all terminated by AV_CODEC_ID_NONE.</span></div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;    <span class="keyword">const</span> <span class="keyword">struct </span>AVCodecTag * <span class="keyword">const</span> *codec_tag;</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;</div><div class="line"><a name="l00526"></a><span class="lineno"><a class="line" href="structAVOutputFormat.html#aad55a00e728a020c1dcfaaf695320445">  526</a></span>&#160;    <span class="keyword">const</span> <a class="code" href="structAVClass.html">AVClass</a> *priv_class; <span class="comment">///&lt; AVClass for the private context</span></div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;    <span class="comment">/*****************************************************************</span></div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;<span class="comment">     * No fields below this line are part of the public API. They</span></div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;<span class="comment">     * may not be used outside of libavformat and can be changed and</span></div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;<span class="comment">     * removed at will.</span></div><div class="line"><a name="l00532"></a><span class="lineno"><a class="line" href="structAVOutputFormat.html#ac55f4c21dd75c8c48b9de5080681eed4">  532</a></span>&#160;<span class="comment">     * New public fields should be added right above.</span></div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;<span class="comment">     *****************************************************************</span></div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00535"></a><span class="lineno"><a class="line" href="structAVOutputFormat.html#ae030463c5c08de99f8c9e727c822ca87">  535</a></span>&#160;    <span class="keyword">struct </span><a class="code" href="structAVOutputFormat.html">AVOutputFormat</a> *<a class="code" href="structAVOutputFormat.html#a381830276f0c71583a0ca014fcd2fc97">next</a>;<span class="comment"></span></div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;<span class="comment">     * size of private data so that it can be allocated in the wrapper</span></div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;    <span class="keywordtype">int</span> <a class="code" href="structAVOutputFormat.html#ad7677ef35d272b2dad5498c51b4d2204">priv_data_size</a>;</div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;</div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;    int (*<a class="code" href="structAVOutputFormat.html#aa867a120bd90779111565907b327ba61">write_header</a>)(<span class="keyword">struct </span><a class="code" href="structAVFormatContext.html">AVFormatContext</a> *);<span class="comment"></span></div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;<span class="comment">     * Write a packet. If AVFMT_ALLOW_FLUSH is set in flags,</span></div><div class="line"><a name="l00544"></a><span class="lineno"><a class="line" href="structAVOutputFormat.html#a381830276f0c71583a0ca014fcd2fc97">  544</a></span>&#160;<span class="comment">     * pkt can be NULL in order to flush data buffered in the muxer.</span></div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;<span class="comment">     * When flushing, return 0 if there still is more data to flush,</span></div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;<span class="comment">     * or 1 if everything was flushed and there is no more buffered</span></div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;<span class="comment">     * data.</span></div><div class="line"><a name="l00548"></a><span class="lineno"><a class="line" href="structAVOutputFormat.html#ad7677ef35d272b2dad5498c51b4d2204">  548</a></span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;    int (*write_packet)(<span class="keyword">struct </span><a class="code" href="structAVFormatContext.html">AVFormatContext</a> *, <a class="code" href="structAVPacket.html">AVPacket</a> *<a class="code" href="demuxing__decoding_8c.html#a3d4c6562f0b27cf0cacbbea5c038c090">pkt</a>);</div><div class="line"><a name="l00550"></a><span class="lineno"><a class="line" href="structAVOutputFormat.html#aa867a120bd90779111565907b327ba61">  550</a></span>&#160;    int (*write_trailer)(<span class="keyword">struct </span><a class="code" href="structAVFormatContext.html">AVFormatContext</a> *);<span class="comment"></span></div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;<span class="comment">     * Currently only used to set pixel format if not YUV420P.</span></div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;    int (*interleave_packet)(<span class="keyword">struct </span><a class="code" href="structAVFormatContext.html">AVFormatContext</a> *, <a class="code" href="structAVPacket.html">AVPacket</a> *out,</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;                             <a class="code" href="structAVPacket.html">AVPacket</a> *in, <span class="keywordtype">int</span> flush);<span class="comment"></span></div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;<span class="comment">     * Test if the given codec can be stored in this container.</span></div><div class="line"><a name="l00558"></a><span class="lineno"><a class="line" href="structAVOutputFormat.html#a98fc78e67fc67e6f18d116ead8fb5010">  558</a></span>&#160;<span class="comment">     *</span></div><div class="line"><a name="l00559"></a><span class="lineno"><a class="line" href="structAVOutputFormat.html#abf35da5f2d210523507001ca0fa26a48">  559</a></span>&#160;<span class="comment">     * @return 1 if the codec is supported, 0 if it is not.</span></div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;<span class="comment">     *         A negative number if unknown.</span></div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;<span class="comment">     *         MKTAG(&#39;A&#39;, &#39;P&#39;, &#39;I&#39;, &#39;C&#39;) if the codec is only supported as AV_DISPOSITION_ATTACHED_PIC</span></div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00563"></a><span class="lineno"><a class="line" href="structAVOutputFormat.html#ab26b14e9f3c16220e8e8ce34b3a3fddc">  563</a></span>&#160;    int (*query_codec)(<span class="keyword">enum</span> <a class="code" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a> id, <span class="keywordtype">int</span> std_compliance);</div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;</div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;    void (*get_output_timestamp)(<span class="keyword">struct </span><a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s, <span class="keywordtype">int</span> stream,</div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;                                 int64_t *dts, int64_t *wall);<span class="comment"></span></div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;<span class="comment">     * Allows sending messages from application to device.</span></div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;    int (*control_message)(<span class="keyword">struct </span><a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s, <span class="keywordtype">int</span> type,</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;                           <span class="keywordtype">void</span> *data, <span class="keywordtype">size_t</span> data_size);</div><div class="line"><a name="l00572"></a><span class="lineno"><a class="line" href="structAVOutputFormat.html#a2622bb891412cf52010a54afb622abc9">  572</a></span>&#160;<span class="comment"></span></div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00574"></a><span class="lineno"><a class="line" href="structAVOutputFormat.html#a605bb6484d5da9f0ea9b129d438e353d">  574</a></span>&#160;<span class="comment">     * Write an uncoded AVFrame.</span></div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;<span class="comment">     *</span></div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;<span class="comment">     * See av_write_uncoded_frame() for details.</span></div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;<span class="comment">     *</span></div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;<span class="comment">     * The library will free *frame afterwards, but the muxer can prevent it</span></div><div class="line"><a name="l00579"></a><span class="lineno"><a class="line" href="structAVOutputFormat.html#aaf8c014593bd71d0bb5f542267a02a90">  579</a></span>&#160;<span class="comment">     * by setting the pointer to NULL.</span></div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;    int (*write_uncoded_frame)(<span class="keyword">struct </span><a class="code" href="structAVFormatContext.html">AVFormatContext</a> *, <span class="keywordtype">int</span> stream_index,</div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;                               <a class="code" href="structAVFrame.html">AVFrame</a> **<a class="code" href="demuxing__decoding_8c.html#ad7d33d579a8d4241a5e643e39287a209">frame</a>, <span class="keywordtype">unsigned</span> <a class="code" href="structAVFormatContext.html#a32379cc371463b235d54235d4af06a15">flags</a>);<span class="comment"></span></div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;<span class="comment">     * Returns device list with it properties.</span></div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;<span class="comment">     * @see avdevice_list_devices() for more details.</span></div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;    int (*get_device_list)(<span class="keyword">struct </span><a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s, <span class="keyword">struct </span><a class="code" href="structAVDeviceInfoList.html">AVDeviceInfoList</a> *device_list);<span class="comment"></span></div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;<span class="comment">     * Initialize device capabilities submodule.</span></div><div class="line"><a name="l00590"></a><span class="lineno"><a class="line" href="structAVOutputFormat.html#a6c35fd05fb664e4950de2173bbeda793">  590</a></span>&#160;<span class="comment">     * @see avdevice_capabilities_create() for more details.</span></div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;    int (*create_device_capabilities)(<span class="keyword">struct </span><a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s, <span class="keyword">struct </span><a class="code" href="structAVDeviceCapabilitiesQuery.html">AVDeviceCapabilitiesQuery</a> *caps);<span class="comment"></span></div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;<span class="comment">     * Free device capabilities submodule.</span></div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;<span class="comment">     * @see avdevice_capabilities_free() for more details.</span></div><div class="line"><a name="l00596"></a><span class="lineno"><a class="line" href="structAVOutputFormat.html#adb9c784dcf21e76db0b18c9d019cb723">  596</a></span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;    int (*free_device_capabilities)(<span class="keyword">struct </span><a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s, <span class="keyword">struct </span><a class="code" href="structAVDeviceCapabilitiesQuery.html">AVDeviceCapabilitiesQuery</a> *caps);</div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;    <span class="keyword">enum</span> <a class="code" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a> data_codec; <span class="comment">/**&lt; default data codec */</span><span class="comment"></span></div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;<span class="comment">     * Initialize format. May allocate data here, and set any AVFormatContext or</span></div><div class="line"><a name="l00601"></a><span class="lineno"><a class="line" href="structAVOutputFormat.html#a049d185b6d02b4b1a78adef7fdceb4c0">  601</a></span>&#160;<span class="comment">     * AVStream parameters that need to be set before packets are sent.</span></div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;<span class="comment">     * This method must not write output.</span></div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;<span class="comment">     *</span></div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;<span class="comment">     * Return 0 if streams were fully configured, 1 if not, negative AVERROR on failure</span></div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;<span class="comment">     *</span></div><div class="line"><a name="l00606"></a><span class="lineno"><a class="line" href="structAVOutputFormat.html#aec717a62e08f65a86c0247a82fa38e50">  606</a></span>&#160;<span class="comment">     * Any allocations made here must be freed in deinit().</span></div><div class="line"><a name="l00607"></a><span class="lineno"><a class="line" href="structAVOutputFormat.html#ac4c06882481a62fd0de7396909b02796">  607</a></span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;    int (*init)(<span class="keyword">struct </span><a class="code" href="structAVFormatContext.html">AVFormatContext</a> *);<span class="comment"></span></div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;<span class="comment">     * Deinitialize format. If present, this is called whenever the muxer is being</span></div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;<span class="comment">     * destroyed, regardless of whether or not the header has been written.</span></div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;<span class="comment">     *</span></div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;<span class="comment">     * If a trailer is being written, this is called after write_trailer().</span></div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;<span class="comment">     *</span></div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;<span class="comment">     * This is called if init() fails as well.</span></div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00617"></a><span class="lineno"><a class="line" href="structAVOutputFormat.html#a163bd99f5663291a464687a0787829e3">  617</a></span>&#160;    void (*deinit)(<span class="keyword">struct </span><a class="code" href="structAVFormatContext.html">AVFormatContext</a> *);<span class="comment"></span></div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;<span class="comment">     * Set up any necessary bitstream filtering and extract any extra data needed</span></div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;<span class="comment">     * for the global header.</span></div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;<span class="comment">     * Return 0 if more packets from this stream must be checked; 1 if not.</span></div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;    int (*check_bitstream)(<span class="keyword">struct </span><a class="code" href="structAVFormatContext.html">AVFormatContext</a> *, <span class="keyword">const</span> <a class="code" href="structAVPacket.html">AVPacket</a> *<a class="code" href="demuxing__decoding_8c.html#a3d4c6562f0b27cf0cacbbea5c038c090">pkt</a>);</div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;} <a class="code" href="structAVOutputFormat.html">AVOutputFormat</a>;<span class="comment"></span></div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l00626"></a><span class="lineno"><a class="line" href="structAVOutputFormat.html#a4c85e8e190b457878eb144abf9918d6a">  626</a></span>&#160;<span class="comment"> * @}</span></div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;<span class="comment"> * @addtogroup lavf_decoding</span></div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;<span class="comment"> * @{</span></div><div class="line"><a name="l00632"></a><span class="lineno"><a class="line" href="structAVOutputFormat.html#a1260d6304f56b67bcc8fa2fb77a7d92f">  632</a></span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;<span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structAVInputFormat.html">AVInputFormat</a> {<span class="comment"></span></div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;<span class="comment">     * A comma separated list of short names for the format. New names</span></div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;<span class="comment">     * may be appended with a minor bump.</span></div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">char</span> *name;</div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;<span class="comment">     * Descriptive name for the format, meant to be more human-readable</span></div><div class="line"><a name="l00642"></a><span class="lineno"><a class="line" href="structAVInputFormat.html">  642</a></span>&#160;<span class="comment">     * than name. You should use the NULL_IF_CONFIG_SMALL() macro</span></div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;<span class="comment">     * to define it.</span></div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">char</span> *long_name;</div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00647"></a><span class="lineno"><a class="line" href="structAVInputFormat.html#a850db3eb225e22b64f3304d72134ca0c">  647</a></span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;<span class="comment">     * Can use flags: AVFMT_NOFILE, AVFMT_NEEDNUMBER, AVFMT_SHOW_IDS,</span></div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;<span class="comment">     * AVFMT_GENERIC_INDEX, AVFMT_TS_DISCONT, AVFMT_NOBINSEARCH,</span></div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;<span class="comment">     * AVFMT_NOGENSEARCH, AVFMT_NO_BYTE_SEEK, AVFMT_SEEK_TO_PTS.</span></div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;    <span class="keywordtype">int</span> flags;</div><div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00654"></a><span class="lineno"><a class="line" href="structAVInputFormat.html#a1f67064a527941944017f1dfe65d3aa9">  654</a></span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;<span class="comment">     * If extensions are defined, then no probe is done. You should</span></div><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;<span class="comment">     * usually not use extension format guessing because it is not</span></div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;<span class="comment">     * reliable enough</span></div><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;    <span class="keyword">const</span> <span class="keywordtype">char</span> *extensions;</div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;</div><div class="line"><a name="l00661"></a><span class="lineno"><a class="line" href="structAVInputFormat.html#a1b30f6647d0c2faf38ba8786d7c3a838">  661</a></span>&#160;    <span class="keyword">const</span> <span class="keyword">struct </span>AVCodecTag * <span class="keyword">const</span> *codec_tag;</div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;</div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;    <span class="keyword">const</span> <a class="code" href="structAVClass.html">AVClass</a> *priv_class; <span class="comment">///&lt; AVClass for the private context</span></div><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;<span class="comment"></span><span class="comment"></span></div><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;<span class="comment">     * Comma-separated list of mime types.</span></div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;<span class="comment">     * It is used check for matching mime types while probing.</span></div><div class="line"><a name="l00668"></a><span class="lineno"><a class="line" href="structAVInputFormat.html#ae692e27e532f664f26e2501967b09eab">  668</a></span>&#160;<span class="comment">     * @see av_probe_input_format2</span></div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00670"></a><span class="lineno"><a class="line" href="structAVInputFormat.html#a88738bb721c18df24fb4207aa2d4924a">  670</a></span>&#160;    <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structAVProbeData.html#a20533bdafa6230d2ef8392cb7cb38382">mime_type</a>;</div><div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;</div><div class="line"><a name="l00672"></a><span class="lineno"><a class="line" href="structAVInputFormat.html#afaac829559ad9e07618c01a51d8a4c5f">  672</a></span>&#160;    <span class="comment">/*****************************************************************</span></div><div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;<span class="comment">     * No fields below this line are part of the public API. They</span></div><div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;<span class="comment">     * may not be used outside of libavformat and can be changed and</span></div><div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;<span class="comment">     * removed at will.</span></div><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;<span class="comment">     * New public fields should be added right above.</span></div><div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;<span class="comment">     *****************************************************************</span></div><div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00679"></a><span class="lineno"><a class="line" href="structAVInputFormat.html#a963cd77aa525517dcfdc18227dae788f">  679</a></span>&#160;    <span class="keyword">struct </span><a class="code" href="structAVInputFormat.html">AVInputFormat</a> *<a class="code" href="structAVInputFormat.html#ad18d8584bb0648f53a7980be8f368164">next</a>;</div><div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;<span class="comment">     * Raw demuxers store their codec ID here.</span></div><div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;    <span class="keywordtype">int</span> <a class="code" href="structAVInputFormat.html#ac12c67e8e0b7bc2b0c26ab383d9a0c76">raw_codec_id</a>;</div><div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;<span class="comment">     * Size of private data so that it can be allocated in the wrapper.</span></div><div class="line"><a name="l00688"></a><span class="lineno"><a class="line" href="structAVInputFormat.html#ad18d8584bb0648f53a7980be8f368164">  688</a></span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;    <span class="keywordtype">int</span> <a class="code" href="structAVInputFormat.html#a195b445886775084b8e075062d33f09a">priv_data_size</a>;</div><div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;<span class="comment">     * Tell if a given file has a chance of being parsed as this format.</span></div><div class="line"><a name="l00693"></a><span class="lineno"><a class="line" href="structAVInputFormat.html#ac12c67e8e0b7bc2b0c26ab383d9a0c76">  693</a></span>&#160;<span class="comment">     * The buffer provided is guaranteed to be AVPROBE_PADDING_SIZE bytes</span></div><div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;<span class="comment">     * big so you do not have to check for that unless you need more.</span></div><div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;    int (*<a class="code" href="structAVInputFormat.html#a2e272c7785fdd26895b1af1867b62567">read_probe</a>)(<a class="code" href="structAVProbeData.html">AVProbeData</a> *);</div><div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00698"></a><span class="lineno"><a class="line" href="structAVInputFormat.html#a195b445886775084b8e075062d33f09a">  698</a></span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;<span class="comment">     * Read the format header and initialize the AVFormatContext</span></div><div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;<span class="comment">     * structure. Return 0 if OK. &#39;avformat_new_stream&#39; should be</span></div><div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;<span class="comment">     * called to create new streams.</span></div><div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;    int (*<a class="code" href="structAVInputFormat.html#a286d65d159570516e5ed38fcbb842d5a">read_header</a>)(<span class="keyword">struct </span><a class="code" href="structAVFormatContext.html">AVFormatContext</a> *);</div><div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00705"></a><span class="lineno"><a class="line" href="structAVInputFormat.html#a2e272c7785fdd26895b1af1867b62567">  705</a></span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;<span class="comment">     * Read one packet and put it in &#39;pkt&#39;. pts and flags are also</span></div><div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;<span class="comment">     * set. &#39;avformat_new_stream&#39; can be called only if the flag</span></div><div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;<span class="comment">     * AVFMTCTX_NOHEADER is used and only in the calling thread (not in a</span></div><div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;<span class="comment">     * background thread).</span></div><div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;<span class="comment">     * @return 0 on success, &lt; 0 on error.</span></div><div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;<span class="comment">     *         When returning an error, pkt must not have been allocated</span></div><div class="line"><a name="l00712"></a><span class="lineno"><a class="line" href="structAVInputFormat.html#a286d65d159570516e5ed38fcbb842d5a">  712</a></span>&#160;<span class="comment">     *         or must be freed before returning</span></div><div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;    int (*<a class="code" href="avio__reading_8c.html#a3a86bff38e7cb9093d0a32316b73b29c">read_packet</a>)(<span class="keyword">struct </span><a class="code" href="structAVFormatContext.html">AVFormatContext</a> *, <a class="code" href="structAVPacket.html">AVPacket</a> *<a class="code" href="demuxing__decoding_8c.html#a3d4c6562f0b27cf0cacbbea5c038c090">pkt</a>);</div><div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;<span class="comment">     * Close the stream. The AVFormatContext and AVStreams are not</span></div><div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;<span class="comment">     * freed by this function</span></div><div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;    int (*read_close)(<span class="keyword">struct </span><a class="code" href="structAVFormatContext.html">AVFormatContext</a> *);</div><div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00723"></a><span class="lineno"><a class="line" href="structAVInputFormat.html#aef741db739cb5af755f01f2a818b61a7">  723</a></span>&#160;<span class="comment">     * Seek to a given timestamp relative to the frames in</span></div><div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;<span class="comment">     * stream component stream_index.</span></div><div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;<span class="comment">     * @param stream_index Must not be -1.</span></div><div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;<span class="comment">     * @param flags Selects which direction should be preferred if no exact</span></div><div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;<span class="comment">     *              match is available.</span></div><div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;<span class="comment">     * @return &gt;= 0 on success (but not necessarily the new offset)</span></div><div class="line"><a name="l00729"></a><span class="lineno"><a class="line" href="structAVInputFormat.html#a725b4fbd5a28109d255d272f46efac90">  729</a></span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;    int (*read_seek)(<span class="keyword">struct </span><a class="code" href="structAVFormatContext.html">AVFormatContext</a> *,</div><div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;                     <span class="keywordtype">int</span> stream_index, int64_t timestamp, <span class="keywordtype">int</span> <a class="code" href="structAVFormatContext.html#a32379cc371463b235d54235d4af06a15">flags</a>);</div><div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;<span class="comment">     * Get the next timestamp in stream[stream_index].time_base units.</span></div><div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;<span class="comment">     * @return the timestamp or AV_NOPTS_VALUE if an error occurred</span></div><div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;    int64_t (*read_timestamp)(<span class="keyword">struct </span><a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s, <span class="keywordtype">int</span> stream_index,</div><div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;                              int64_t *pos, int64_t pos_limit);</div><div class="line"><a name="l00739"></a><span class="lineno"><a class="line" href="structAVInputFormat.html#a04a3b9ba459666bdb43628c472fa29bf">  739</a></span>&#160;<span class="comment"></span></div><div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;<span class="comment">     * Start/resume playing - only meaningful if using a network-based format</span></div><div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;<span class="comment">     * (RTSP).</span></div><div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;    int (*read_play)(<span class="keyword">struct </span><a class="code" href="structAVFormatContext.html">AVFormatContext</a> *);</div><div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00746"></a><span class="lineno"><a class="line" href="structAVInputFormat.html#ab071640466e60eddc4eee43385fb22fd">  746</a></span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;<span class="comment">     * Pause playing - only meaningful if using a network-based format</span></div><div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;<span class="comment">     * (RTSP).</span></div><div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;    int (*read_pause)(<span class="keyword">struct </span><a class="code" href="structAVFormatContext.html">AVFormatContext</a> *);</div><div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00753"></a><span class="lineno"><a class="line" href="structAVInputFormat.html#a4658ac53d7c6eaea445409010cd3b474">  753</a></span>&#160;<span class="comment">     * Seek to timestamp ts.</span></div><div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;<span class="comment">     * Seeking will be done so that the point from which all active streams</span></div><div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;<span class="comment">     * can be presented successfully will be closest to ts and within min/max_ts.</span></div><div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;<span class="comment">     * Active streams are all streams that have AVStream.discard &lt; AVDISCARD_ALL.</span></div><div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;    int (*read_seek2)(<span class="keyword">struct </span><a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s, <span class="keywordtype">int</span> stream_index, int64_t min_ts, int64_t ts, int64_t max_ts, <span class="keywordtype">int</span> <a class="code" href="structAVFormatContext.html#a32379cc371463b235d54235d4af06a15">flags</a>);</div><div class="line"><a name="l00759"></a><span class="lineno"><a class="line" href="structAVInputFormat.html#a4e4da186feab0a2900404e77aa3631f4">  759</a></span>&#160;<span class="comment"></span></div><div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;<span class="comment">     * Returns device list with it properties.</span></div><div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;<span class="comment">     * @see avdevice_list_devices() for more details.</span></div><div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;    int (*get_device_list)(<span class="keyword">struct </span><a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s, <span class="keyword">struct </span><a class="code" href="structAVDeviceInfoList.html">AVDeviceInfoList</a> *device_list);</div><div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00767"></a><span class="lineno"><a class="line" href="structAVInputFormat.html#abdc6865c444251c21980d8da2e087429">  767</a></span>&#160;<span class="comment">     * Initialize device capabilities submodule.</span></div><div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;<span class="comment">     * @see avdevice_capabilities_create() for more details.</span></div><div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;    int (*create_device_capabilities)(<span class="keyword">struct </span><a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s, <span class="keyword">struct </span><a class="code" href="structAVDeviceCapabilitiesQuery.html">AVDeviceCapabilitiesQuery</a> *caps);</div><div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00773"></a><span class="lineno"><a class="line" href="structAVInputFormat.html#a904104dc65359b800012d7abd01bb8e7">  773</a></span>&#160;<span class="comment">     * Free device capabilities submodule.</span></div><div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;<span class="comment">     * @see avdevice_capabilities_free() for more details.</span></div><div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;    int (*free_device_capabilities)(<span class="keyword">struct </span><a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s, <span class="keyword">struct </span><a class="code" href="structAVDeviceCapabilitiesQuery.html">AVDeviceCapabilitiesQuery</a> *caps);</div><div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;} <a class="code" href="structAVInputFormat.html">AVInputFormat</a>;<span class="comment"></span></div><div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l00779"></a><span class="lineno"><a class="line" href="structAVInputFormat.html#ac6a31bdb54e3a971435e2ad4de02d8e1">  779</a></span>&#160;<span class="comment"> * @}</span></div><div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;</div><div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;<span class="keyword">enum</span> <a class="code" href="avformat_8h.html#afacbc85f23a50771e3801bda0a353d91">AVStreamParseType</a> {</div><div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;    <a class="code" href="avformat_8h.html#afacbc85f23a50771e3801bda0a353d91ac715de62daa60e31ce01b9671bd35f9e">AVSTREAM_PARSE_NONE</a>,</div><div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;    <a class="code" href="avformat_8h.html#afacbc85f23a50771e3801bda0a353d91ac21d15a27dac74ca0730b4dace71d883">AVSTREAM_PARSE_FULL</a>,       <span class="comment">/**&lt; full parsing and repack */</span></div><div class="line"><a name="l00785"></a><span class="lineno"><a class="line" href="structAVInputFormat.html#a20a028f8f7f2eeb497d1695be096ea91">  785</a></span>&#160;    <a class="code" href="avformat_8h.html#afacbc85f23a50771e3801bda0a353d91a67bc09fcdeb0e05754f344fbc80856ca">AVSTREAM_PARSE_HEADERS</a>,    <span class="comment">/**&lt; Only parse headers, do not repack. */</span></div><div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;    <a class="code" href="avformat_8h.html#afacbc85f23a50771e3801bda0a353d91a10f8e7a9d88b7b5e2010ffb496b6cf1a">AVSTREAM_PARSE_TIMESTAMPS</a>, <span class="comment">/**&lt; full parsing and interpolation of timestamps for frames not starting on a packet boundary */</span></div><div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;    <a class="code" href="avformat_8h.html#afacbc85f23a50771e3801bda0a353d91a41eb176dd7cfc095b5ea66816a75c56a">AVSTREAM_PARSE_FULL_ONCE</a>,  <span class="comment">/**&lt; full parsing and repack of the first frame only, only implemented for H.264 currently */</span></div><div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;    <a class="code" href="avformat_8h.html#afacbc85f23a50771e3801bda0a353d91a4a4190f226593e92724285f8bfef9c2e">AVSTREAM_PARSE_FULL_RAW</a>,   <span class="comment">/**&lt; full parsing and repack with timestamp and position generation by parser for raw</span></div><div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;<span class="comment">                                    this assumes that each packet in the file contains no demuxer level headers and</span></div><div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;<span class="comment">                                    just codec level data, otherwise position generation would fail */</span></div><div class="line"><a name="l00791"></a><span class="lineno"><a class="line" href="avformat_8h.html#afacbc85f23a50771e3801bda0a353d91">  791</a></span>&#160;};</div><div class="line"><a name="l00792"></a><span class="lineno"><a class="line" href="avformat_8h.html#afacbc85f23a50771e3801bda0a353d91ac715de62daa60e31ce01b9671bd35f9e">  792</a></span>&#160;</div><div class="line"><a name="l00793"></a><span class="lineno"><a class="line" href="avformat_8h.html#afacbc85f23a50771e3801bda0a353d91ac21d15a27dac74ca0730b4dace71d883">  793</a></span>&#160;<span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structAVIndexEntry.html">AVIndexEntry</a> {</div><div class="line"><a name="l00794"></a><span class="lineno"><a class="line" href="avformat_8h.html#afacbc85f23a50771e3801bda0a353d91a67bc09fcdeb0e05754f344fbc80856ca">  794</a></span>&#160;    int64_t pos;</div><div class="line"><a name="l00795"></a><span class="lineno"><a class="line" href="avformat_8h.html#afacbc85f23a50771e3801bda0a353d91a10f8e7a9d88b7b5e2010ffb496b6cf1a">  795</a></span>&#160;    int64_t timestamp;        <span class="comment">/**&lt;</span></div><div class="line"><a name="l00796"></a><span class="lineno"><a class="line" href="avformat_8h.html#afacbc85f23a50771e3801bda0a353d91a41eb176dd7cfc095b5ea66816a75c56a">  796</a></span>&#160;<span class="comment">                               * Timestamp in AVStream.time_base units, preferably the time from which on correctly decoded frames are available</span></div><div class="line"><a name="l00797"></a><span class="lineno"><a class="line" href="avformat_8h.html#afacbc85f23a50771e3801bda0a353d91a4a4190f226593e92724285f8bfef9c2e">  797</a></span>&#160;<span class="comment">                               * when seeking to this entry. That means preferable PTS on keyframe based formats.</span></div><div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;<span class="comment">                               * But demuxers can choose to store a different timestamp, if it is more convenient for the implementation or nothing better</span></div><div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;<span class="comment">                               * is known</span></div><div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;<span class="comment">                               */</span></div><div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;<span class="preprocessor">#define AVINDEX_KEYFRAME 0x0001</span></div><div class="line"><a name="l00802"></a><span class="lineno"><a class="line" href="structAVIndexEntry.html">  802</a></span>&#160;<span class="preprocessor">#define AVINDEX_DISCARD_FRAME  0x0002    </span><span class="comment">/**</span></div><div class="line"><a name="l00803"></a><span class="lineno"><a class="line" href="structAVIndexEntry.html#ac0dd805ffd04bb52b1a358331dd10b98">  803</a></span>&#160;<span class="comment">                                          * Flag is used to indicate which frame should be discarded after decoding.</span></div><div class="line"><a name="l00804"></a><span class="lineno"><a class="line" href="structAVIndexEntry.html#affef8bf4cd2f53a47ebc2d298d0d57c1">  804</a></span>&#160;<span class="comment">                                          */</span><span class="preprocessor"></span></div><div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;    <span class="keywordtype">int</span> flags:2;</div><div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;    <span class="keywordtype">int</span> size:30; <span class="comment">//Yeah, trying to keep the size of this small to reduce memory requirements (it is 24 vs. 32 bytes due to possible 8-byte alignment).</span></div><div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;    <span class="keywordtype">int</span> min_distance;         <span class="comment">/**&lt; Minimum distance between this and the previous keyframe, used to avoid unneeded searching. */</span></div><div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;} <a class="code" href="structAVIndexEntry.html">AVIndexEntry</a>;</div><div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;</div><div class="line"><a name="l00810"></a><span class="lineno"><a class="line" href="avformat_8h.html#a23159bdc0b27ccf964072e30d6cc4559">  810</a></span>&#160;<span class="preprocessor">#define AV_DISPOSITION_DEFAULT   0x0001</span></div><div class="line"><a name="l00811"></a><span class="lineno"><a class="line" href="avformat_8h.html#ac4fe20a35d4a1b9014e5f4062fb67b52">  811</a></span>&#160;<span class="preprocessor">#define AV_DISPOSITION_DUB       0x0002</span></div><div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;<span class="preprocessor">#define AV_DISPOSITION_ORIGINAL  0x0004</span></div><div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;<span class="preprocessor">#define AV_DISPOSITION_COMMENT   0x0008</span></div><div class="line"><a name="l00814"></a><span class="lineno"><a class="line" href="structAVIndexEntry.html#a72366fb5dae7421e41cce6ad8dd2126b">  814</a></span>&#160;<span class="preprocessor">#define AV_DISPOSITION_LYRICS    0x0010</span></div><div class="line"><a name="l00815"></a><span class="lineno"><a class="line" href="structAVIndexEntry.html#a1b57d93b863a1b605461229a65ca8b52">  815</a></span>&#160;<span class="preprocessor">#define AV_DISPOSITION_KARAOKE   0x0020</span></div><div class="line"><a name="l00816"></a><span class="lineno"><a class="line" href="structAVIndexEntry.html#add3fa33e8b3363a96fa4c62fca1bcf42">  816</a></span>&#160;<span class="comment"></span></div><div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;<span class="comment"> * Track should be used during playback by default.</span></div><div class="line"><a name="l00819"></a><span class="lineno"><a class="line" href="avformat_8h.html#af09f200b4cd9bf0baa05671436eef2fb">  819</a></span>&#160;<span class="comment"> * Useful for subtitle track that should be displayed</span></div><div class="line"><a name="l00820"></a><span class="lineno"><a class="line" href="avformat_8h.html#a5bf41aa870351bd4e912725bcaf87031">  820</a></span>&#160;<span class="comment"> * even when user did not explicitly ask for subtitles.</span></div><div class="line"><a name="l00821"></a><span class="lineno"><a class="line" href="avformat_8h.html#aed1d78ae5604930f7465e5f48220941e">  821</a></span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l00822"></a><span class="lineno"><a class="line" href="avformat_8h.html#a3fd17d972522f10a6d73937482225482">  822</a></span>&#160;<span class="preprocessor">#define AV_DISPOSITION_FORCED    0x0040</span></div><div class="line"><a name="l00823"></a><span class="lineno"><a class="line" href="avformat_8h.html#a07792fd9060493192a4d4f25714a56d6">  823</a></span>&#160;<span class="preprocessor">#define AV_DISPOSITION_HEARING_IMPAIRED  0x0080  </span><span class="comment">/**&lt; stream for hearing impaired audiences */</span><span class="preprocessor"></span></div><div class="line"><a name="l00824"></a><span class="lineno"><a class="line" href="avformat_8h.html#a4e6b75c4d996642d88b98241f0ad2979">  824</a></span>&#160;<span class="preprocessor">#define AV_DISPOSITION_VISUAL_IMPAIRED   0x0100  </span><span class="comment">/**&lt; stream for visual impaired audiences */</span><span class="preprocessor"></span></div><div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;<span class="preprocessor">#define AV_DISPOSITION_CLEAN_EFFECTS     0x0200  </span><span class="comment">/**&lt; stream without voice */</span><span class="preprocessor"></span></div><div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;<span class="comment"> * The stream is stored in the file as an attached picture/&quot;cover art&quot; (e.g.</span></div><div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;<span class="comment"> * APIC frame in ID3v2). The first (usually only) packet associated with it</span></div><div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;<span class="comment"> * will be returned among the first few packets read from the file unless</span></div><div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;<span class="comment"> * seeking takes place. It can also be accessed at any time in</span></div><div class="line"><a name="l00831"></a><span class="lineno"><a class="line" href="avformat_8h.html#aa72fcb393482cb6bb302d4995990bf3b">  831</a></span>&#160;<span class="comment"> * AVStream.attached_pic.</span></div><div class="line"><a name="l00832"></a><span class="lineno"><a class="line" href="avformat_8h.html#a39ba22fdf89ec823243ba92bfd35c189">  832</a></span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l00833"></a><span class="lineno"><a class="line" href="avformat_8h.html#aa8e9704bcc842236ad048062dcf45d45">  833</a></span>&#160;<span class="preprocessor">#define AV_DISPOSITION_ATTACHED_PIC      0x0400</span></div><div class="line"><a name="l00834"></a><span class="lineno"><a class="line" href="avformat_8h.html#a9b09132b5af7f7f6fe54d61782373bc7">  834</a></span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;<span class="comment"> * The stream is sparse, and contains thumbnail images, often corresponding</span></div><div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;<span class="comment"> * to chapter markers. Only ever used with AV_DISPOSITION_ATTACHED_PIC.</span></div><div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;<span class="preprocessor">#define AV_DISPOSITION_TIMED_THUMBNAILS  0x0800</span></div><div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;</div><div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;<span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="avformat_8h.html#a5989dd9dc73f1e05d7cce92a056180bd">AVStreamInternal</a> <a class="code" href="avformat_8h.html#a5989dd9dc73f1e05d7cce92a056180bd">AVStreamInternal</a>;</div><div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00842"></a><span class="lineno"><a class="line" href="avformat_8h.html#ab54a3e54e88a8f7d7760e60b49944e44">  842</a></span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;<span class="comment"> * To specify text track kind (different from subtitles default).</span></div><div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;<span class="preprocessor">#define AV_DISPOSITION_CAPTIONS     0x10000</span></div><div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;<span class="preprocessor">#define AV_DISPOSITION_DESCRIPTIONS 0x20000</span></div><div class="line"><a name="l00847"></a><span class="lineno"><a class="line" href="avformat_8h.html#af7e859adfb2f1819dd733bc19b600585">  847</a></span>&#160;<span class="preprocessor">#define AV_DISPOSITION_METADATA     0x40000</span></div><div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00849"></a><span class="lineno"><a class="line" href="avformat_8h.html#a5989dd9dc73f1e05d7cce92a056180bd">  849</a></span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;<span class="comment"> * Options for behavior on timestamp wrap detection.</span></div><div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;<span class="preprocessor">#define AV_PTS_WRAP_IGNORE      0   </span><span class="comment">///&lt; ignore the wrap</span></div><div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;<span class="comment"></span>#define AV_PTS_WRAP_ADD_OFFSET  1   <span class="comment">///&lt; add the format specific offset on wrap detection</span></div><div class="line"><a name="l00854"></a><span class="lineno"><a class="line" href="avformat_8h.html#a51efe44185491ba0a214fe2bc92ac2a1">  854</a></span>&#160;<span class="comment"></span>#define AV_PTS_WRAP_SUB_OFFSET  -1  <span class="comment">///&lt; subtract the format specific offset on wrap detection</span></div><div class="line"><a name="l00855"></a><span class="lineno"><a class="line" href="avformat_8h.html#ae578ee8b851860926955855d1234f93f">  855</a></span>&#160;<span class="comment"></span></div><div class="line"><a name="l00856"></a><span class="lineno"><a class="line" href="avformat_8h.html#a5ff7b03b405295a7a9743cfa67369759">  856</a></span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;<span class="comment"> * Stream structure.</span></div><div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;<span class="comment"> * New fields can be added to the end with minor version bumps.</span></div><div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;<span class="comment"> * Removal, reordering and changes to existing fields require a major</span></div><div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;<span class="comment"> * version bump.</span></div><div class="line"><a name="l00861"></a><span class="lineno"><a class="line" href="avformat_8h.html#a1c159fe90edbc7a6f0c5e9f3537bff1b">  861</a></span>&#160;<span class="comment"> * sizeof(AVStream) must not be used outside libav*.</span></div><div class="line"><a name="l00862"></a><span class="lineno"><a class="line" href="avformat_8h.html#adafc4c061749f2f3a6ffac6796b844f0">  862</a></span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l00863"></a><span class="lineno"><a class="line" href="avformat_8h.html#a19520b122a38843e0ce95335ad92bb61">  863</a></span>&#160;<span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structAVStream.html">AVStream</a> {</div><div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;    <span class="keywordtype">int</span> index;    <span class="comment">/**&lt; stream index in AVFormatContext */</span><span class="comment"></span></div><div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;<span class="comment">     * Format-specific stream ID.</span></div><div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;<span class="comment">     * decoding: set by libavformat</span></div><div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;<span class="comment">     * encoding: set by the user, replaced by libavformat if left unset</span></div><div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;    <span class="keywordtype">int</span> id;</div><div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;<span class="preprocessor">#if FF_API_LAVF_AVCTX</span></div><div class="line"><a name="l00872"></a><span class="lineno"><a class="line" href="structAVStream.html">  872</a></span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00873"></a><span class="lineno"><a class="line" href="structAVStream.html#a6ca823054632821e085377f7d371a2d1">  873</a></span>&#160;<span class="comment">     * @deprecated use the codecpar struct instead</span></div><div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;    <a class="code" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a></div><div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;    <a class="code" href="structAVCodecContext.html">AVCodecContext</a> *codec;</div><div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;    <span class="keywordtype">void</span> *priv_data;</div><div class="line"><a name="l00879"></a><span class="lineno"><a class="line" href="structAVStream.html#a6873ed62f196c24e8bf282609231786f">  879</a></span>&#160;<span class="comment"></span></div><div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;<span class="comment">     * This is the fundamental unit of time (in seconds) in terms</span></div><div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;<span class="comment">     * of which frame timestamps are represented.</span></div><div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;<span class="comment">     *</span></div><div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;<span class="comment">     * decoding: set by libavformat</span></div><div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;<span class="comment">     * encoding: May be set by the caller before avformat_write_header() to</span></div><div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;<span class="comment">     *           provide a hint to the muxer about the desired timebase. In</span></div><div class="line"><a name="l00887"></a><span class="lineno"><a class="line" href="structAVStream.html#a61b61b0d009be377ebcfdc30ea053d27">  887</a></span>&#160;<span class="comment">     *           avformat_write_header(), the muxer will overwrite this field</span></div><div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;<span class="comment">     *           with the timebase that will actually be used for the timestamps</span></div><div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;<span class="comment">     *           written into the file (which may or may not be related to the</span></div><div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;<span class="comment">     *           user-provided one, depending on the format).</span></div><div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;    <a class="code" href="structAVRational.html">AVRational</a> time_base;</div><div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;<span class="comment">     * Decoding: pts of the first frame of the stream in presentation order, in stream time base.</span></div><div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;<span class="comment">     * Only set this if you are absolutely 100% sure that the value you set</span></div><div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;<span class="comment">     * it to really is the pts of the first frame.</span></div><div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;<span class="comment">     * This may be undefined (AV_NOPTS_VALUE).</span></div><div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;<span class="comment">     * @note The ASF header does NOT contain a correct start_time the ASF</span></div><div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;<span class="comment">     * demuxer must NOT set this.</span></div><div class="line"><a name="l00901"></a><span class="lineno"><a class="line" href="structAVStream.html#a9db755451f14e2bf590d4b85d82b32e6">  901</a></span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;    int64_t start_time;</div><div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;<span class="comment">     * Decoding: duration of the stream, in stream time base.</span></div><div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;<span class="comment">     * If a source file does not specify a duration, but does specify</span></div><div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;<span class="comment">     * a bitrate, this value will be estimated from bitrate and file size.</span></div><div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;<span class="comment">     *</span></div><div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;<span class="comment">     * Encoding: May be set by the caller before avformat_write_header() to</span></div><div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;<span class="comment">     * provide a hint to the muxer about the estimated duration.</span></div><div class="line"><a name="l00911"></a><span class="lineno"><a class="line" href="structAVStream.html#a7c67ae70632c91df8b0f721658ec5377">  911</a></span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;    int64_t duration;</div><div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;</div><div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;    int64_t nb_frames;                 <span class="comment">///&lt; number of frames in this stream if known or 0</span></div><div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;    <span class="keywordtype">int</span> disposition; <span class="comment">/**&lt; AV_DISPOSITION_* bit field */</span></div><div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;</div><div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;    <span class="keyword">enum</span> <a class="code" href="group__lavc__decoding.html#ga352363bce7d3ed82c101b3bc001d1c16">AVDiscard</a> discard; <span class="comment">///&lt; Selects which packets can be discarded at will and do not need to be demuxed.</span></div><div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;<span class="comment"></span><span class="comment"></span></div><div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00921"></a><span class="lineno"><a class="line" href="structAVStream.html#a4e04af7a5a4d8298649850df798dd0bc">  921</a></span>&#160;<span class="comment">     * sample aspect ratio (0 if unknown)</span></div><div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;<span class="comment">     * - encoding: Set by user.</span></div><div class="line"><a name="l00923"></a><span class="lineno"><a class="line" href="structAVStream.html#a4382c3064df1c9eb232ac198dec067f9">  923</a></span>&#160;<span class="comment">     * - decoding: Set by libavformat.</span></div><div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00925"></a><span class="lineno"><a class="line" href="structAVStream.html#aea05abdb8e45405048d7923a68c23ef5">  925</a></span>&#160;    <a class="code" href="structAVRational.html">AVRational</a> sample_aspect_ratio;</div><div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;</div><div class="line"><a name="l00927"></a><span class="lineno"><a class="line" href="structAVStream.html#a492fcecc45dbbd8da51edd0124e9dd30">  927</a></span>&#160;    <a class="code" href="group__lavu__dict.html#ga1d7cc0833bee918994a600556410315f">AVDictionary</a> *metadata;</div><div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;<span class="comment">     * Average framerate</span></div><div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;<span class="comment">     *</span></div><div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;<span class="comment">     * - demuxing: May be set by libavformat when creating the stream or in</span></div><div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;<span class="comment">     *             avformat_find_stream_info().</span></div><div class="line"><a name="l00934"></a><span class="lineno"><a class="line" href="structAVStream.html#a3f19c60ac6da237cd10e4d97150c118e">  934</a></span>&#160;<span class="comment">     * - muxing: May be set by the caller before avformat_write_header().</span></div><div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00936"></a><span class="lineno"><a class="line" href="structAVStream.html#a50d250a128a3da9ce3d135e84213fb82">  936</a></span>&#160;    <a class="code" href="structAVRational.html">AVRational</a> avg_frame_rate;</div><div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;<span class="comment">     * For streams with AV_DISPOSITION_ATTACHED_PIC disposition, this packet</span></div><div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;<span class="comment">     * will contain the attached picture.</span></div><div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;<span class="comment">     *</span></div><div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;<span class="comment">     * decoding: set by libavformat, must not be modified by the caller.</span></div><div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;<span class="comment">     * encoding: unused</span></div><div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00945"></a><span class="lineno"><a class="line" href="structAVStream.html#a946e1e9b89eeeae4cab8a833b482c1ad">  945</a></span>&#160;    <a class="code" href="structAVPacket.html">AVPacket</a> attached_pic;</div><div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;<span class="comment">     * An array of side data that applies to the whole stream (i.e. the</span></div><div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;<span class="comment">     * container does not allow it to change between packets).</span></div><div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;<span class="comment">     *</span></div><div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;<span class="comment">     * There may be no overlap between the side data in this array and side data</span></div><div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;<span class="comment">     * in the packets. I.e. a given side data is either exported by the muxer</span></div><div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;<span class="comment">     * (demuxing) / set by the caller (muxing) in this array, then it never</span></div><div class="line"><a name="l00954"></a><span class="lineno"><a class="line" href="structAVStream.html#a8c689ee00c0dfe4313891f8a2ea21f4d">  954</a></span>&#160;<span class="comment">     * appears in the packets, or the side data is exported / sent through</span></div><div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160;<span class="comment">     * the packets (always in the first packet where the value becomes known or</span></div><div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160;<span class="comment">     * changes), then it does not appear in this array.</span></div><div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;<span class="comment">     *</span></div><div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160;<span class="comment">     * - demuxing: Set by libavformat when the stream is created.</span></div><div class="line"><a name="l00959"></a><span class="lineno">  959</span>&#160;<span class="comment">     * - muxing: May be set by the caller before avformat_write_header().</span></div><div class="line"><a name="l00960"></a><span class="lineno">  960</span>&#160;<span class="comment">     *</span></div><div class="line"><a name="l00961"></a><span class="lineno">  961</span>&#160;<span class="comment">     * Freed by libavformat in avformat_free_context().</span></div><div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;<span class="comment">     *</span></div><div class="line"><a name="l00963"></a><span class="lineno">  963</span>&#160;<span class="comment">     * @see av_format_inject_global_side_data()</span></div><div class="line"><a name="l00964"></a><span class="lineno">  964</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00965"></a><span class="lineno">  965</span>&#160;    <a class="code" href="structAVPacketSideData.html">AVPacketSideData</a> *side_data;<span class="comment"></span></div><div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160;<span class="comment">     * The number of elements in the AVStream.side_data array.</span></div><div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;    <span class="keywordtype">int</span>            nb_side_data;</div><div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;<span class="comment">     * Flags for the user to detect events happening on the stream. Flags must</span></div><div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;<span class="comment">     * be cleared by the user once the event has been handled.</span></div><div class="line"><a name="l00974"></a><span class="lineno"><a class="line" href="structAVStream.html#a069da4bb2fba6871858065fdf25fe3b3">  974</a></span>&#160;<span class="comment">     * A combination of AVSTREAM_EVENT_FLAG_*.</span></div><div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;    <span class="keywordtype">int</span> event_flags;</div><div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160;<span class="preprocessor">#define AVSTREAM_EVENT_FLAG_METADATA_UPDATED 0x0001 </span><span class="comment">///&lt; The call resulted in updated metadata.</span></div><div class="line"><a name="l00978"></a><span class="lineno"><a class="line" href="structAVStream.html#ad2d413a504862fdfcf84105e898deb88">  978</a></span>&#160;<span class="comment"></span></div><div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160;<span class="comment">     * Real base framerate of the stream.</span></div><div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;<span class="comment">     * This is the lowest framerate with which all timestamps can be</span></div><div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;<span class="comment">     * represented accurately (it is the least common multiple of all</span></div><div class="line"><a name="l00983"></a><span class="lineno">  983</span>&#160;<span class="comment">     * framerates in the stream). Note, this value is just a guess!</span></div><div class="line"><a name="l00984"></a><span class="lineno">  984</span>&#160;<span class="comment">     * For example, if the time base is 1/90000 and all frames have either</span></div><div class="line"><a name="l00985"></a><span class="lineno"><a class="line" href="structAVStream.html#ab76e176c2a1d1ff09ec9c0bb88dc25e9">  985</a></span>&#160;<span class="comment">     * approximately 3600 or 1800 timer ticks, then r_frame_rate will be 50/1.</span></div><div class="line"><a name="l00986"></a><span class="lineno"><a class="line" href="avformat_8h.html#ab3a5958310f614671f5030ed10753ba9">  986</a></span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;    <a class="code" href="structAVRational.html">AVRational</a> r_frame_rate;</div><div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;<span class="comment">     * String containing pairs of key and values describing recommended encoder configuration.</span></div><div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;<span class="comment">     * Pairs are separated by &#39;,&#39;.</span></div><div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;<span class="comment">     * Keys are separated from values by &#39;=&#39;.</span></div><div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;    <span class="keywordtype">char</span> *recommended_encoder_configuration;</div><div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00996"></a><span class="lineno"><a class="line" href="structAVStream.html#ad63fb11cc1415e278e09ddc676e8a1ad">  996</a></span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;<span class="comment">     * Codec parameters associated with this stream. Allocated and freed by</span></div><div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;<span class="comment">     * libavformat in avformat_new_stream() and avformat_free_context()</span></div><div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;<span class="comment">     * respectively.</span></div><div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;<span class="comment">     *</span></div><div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;<span class="comment">     * - demuxing: filled by libavformat on stream creation or in</span></div><div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;<span class="comment">     *             avformat_find_stream_info()</span></div><div class="line"><a name="l01003"></a><span class="lineno"><a class="line" href="structAVStream.html#a990a5b024db89126b507197ebc4de4d0"> 1003</a></span>&#160;<span class="comment">     * - muxing: filled by the caller before avformat_write_header()</span></div><div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01005"></a><span class="lineno"> 1005</span>&#160;    <a class="code" href="structAVCodecParameters.html">AVCodecParameters</a> *codecpar;</div><div class="line"><a name="l01006"></a><span class="lineno"> 1006</span>&#160;</div><div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;    <span class="comment">/*****************************************************************</span></div><div class="line"><a name="l01008"></a><span class="lineno"> 1008</span>&#160;<span class="comment">     * All fields below this line are not part of the public API. They</span></div><div class="line"><a name="l01009"></a><span class="lineno"> 1009</span>&#160;<span class="comment">     * may not be used outside of libavformat and can be changed and</span></div><div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;<span class="comment">     * removed at will.</span></div><div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;<span class="comment">     * Internal note: be aware that physically removing these fields</span></div><div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;<span class="comment">     * will break ABI. Replace removed fields with dummy fields, and</span></div><div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;<span class="comment">     * add new fields to AVStreamInternal.</span></div><div class="line"><a name="l01014"></a><span class="lineno"><a class="line" href="structAVStream.html#a12826d21779289356722971d362c583c"> 1014</a></span>&#160;<span class="comment">     *****************************************************************</span></div><div class="line"><a name="l01015"></a><span class="lineno"> 1015</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01016"></a><span class="lineno"> 1016</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;<span class="comment">     * Stream information used internally by avformat_find_stream_info()</span></div><div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160;<span class="preprocessor">#define MAX_STD_TIMEBASES (30*12+30+3+6)</span></div><div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;    <span class="keyword">struct </span>{</div><div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;        int64_t last_dts;</div><div class="line"><a name="l01023"></a><span class="lineno"> 1023</span>&#160;        int64_t duration_gcd;</div><div class="line"><a name="l01024"></a><span class="lineno"> 1024</span>&#160;        <span class="keywordtype">int</span> duration_count;</div><div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;        int64_t rfps_duration_sum;</div><div class="line"><a name="l01026"></a><span class="lineno"> 1026</span>&#160;        double (*duration_error)[2][<a class="code" href="avformat_8h.html#a79d6ee9e699fd534e85543752f3cb775">MAX_STD_TIMEBASES</a>];</div><div class="line"><a name="l01027"></a><span class="lineno"> 1027</span>&#160;        int64_t codec_info_duration;</div><div class="line"><a name="l01028"></a><span class="lineno"> 1028</span>&#160;        int64_t codec_info_duration_fields;</div><div class="line"><a name="l01029"></a><span class="lineno"><a class="line" href="avformat_8h.html#a79d6ee9e699fd534e85543752f3cb775"> 1029</a></span>&#160;        <span class="keywordtype">int</span> frame_delay_evidence;</div><div class="line"><a name="l01030"></a><span class="lineno"> 1030</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01031"></a><span class="lineno"><a class="line" href="structAVStream.html#a1c89d3d6eedba5bab6e3e12f0d6fb70e"> 1031</a></span>&#160;<span class="comment">        /**</span></div><div class="line"><a name="l01032"></a><span class="lineno"><a class="line" href="structAVStream.html#a0074e905c9fdbd79d2ecd623361ec4f8"> 1032</a></span>&#160;<span class="comment">         * 0  -&gt; decoder has not been searched for yet.</span></div><div class="line"><a name="l01033"></a><span class="lineno"><a class="line" href="structAVStream.html#ab1dc61f4f5b3bd8e1211c022aa04d588"> 1033</a></span>&#160;<span class="comment">         * &gt;0 -&gt; decoder found</span></div><div class="line"><a name="l01034"></a><span class="lineno"><a class="line" href="structAVStream.html#afeec9883900710b1e9fc241dd6c32a20"> 1034</a></span>&#160;<span class="comment">         * &lt;0 -&gt; decoder with codec_id == -found_decoder has not been found</span></div><div class="line"><a name="l01035"></a><span class="lineno"><a class="line" href="structAVStream.html#a5364ec3acec412b24d225152cf1c0fd6"> 1035</a></span>&#160;<span class="comment">         */</span></div><div class="line"><a name="l01036"></a><span class="lineno"><a class="line" href="structAVStream.html#a55fa61f39b931338e5ba270f3be7a28e"> 1036</a></span>&#160;        <span class="keywordtype">int</span> found_decoder;</div><div class="line"><a name="l01037"></a><span class="lineno"><a class="line" href="structAVStream.html#a5cf5e17cd1a56b141b588225fe7cf272"> 1037</a></span>&#160;</div><div class="line"><a name="l01038"></a><span class="lineno"><a class="line" href="structAVStream.html#a5a7972530b4d05bd00b5b1e502c50589"> 1038</a></span>&#160;        int64_t last_duration;</div><div class="line"><a name="l01039"></a><span class="lineno"> 1039</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01040"></a><span class="lineno"> 1040</span>&#160;<span class="comment">        /**</span></div><div class="line"><a name="l01041"></a><span class="lineno"> 1041</span>&#160;<span class="comment">         * Those are used for average framerate estimation.</span></div><div class="line"><a name="l01042"></a><span class="lineno"> 1042</span>&#160;<span class="comment">         */</span></div><div class="line"><a name="l01043"></a><span class="lineno"> 1043</span>&#160;        int64_t fps_first_dts;</div><div class="line"><a name="l01044"></a><span class="lineno"> 1044</span>&#160;        <span class="keywordtype">int</span>     fps_first_dts_idx;</div><div class="line"><a name="l01045"></a><span class="lineno"><a class="line" href="structAVStream.html#aa209c846f64d54a7d73fcfdea0d3df94"> 1045</a></span>&#160;        int64_t fps_last_dts;</div><div class="line"><a name="l01046"></a><span class="lineno"> 1046</span>&#160;        <span class="keywordtype">int</span>     fps_last_dts_idx;</div><div class="line"><a name="l01047"></a><span class="lineno"><a class="line" href="structAVStream.html#af2a160604ac831709bc4f011a3a38410"> 1047</a></span>&#160;</div><div class="line"><a name="l01048"></a><span class="lineno"> 1048</span>&#160;    } *info;</div><div class="line"><a name="l01049"></a><span class="lineno"> 1049</span>&#160;</div><div class="line"><a name="l01050"></a><span class="lineno"> 1050</span>&#160;    <span class="keywordtype">int</span> pts_wrap_bits; <span class="comment">/**&lt; number of bits in pts (used for wrapping control) */</span></div><div class="line"><a name="l01051"></a><span class="lineno"> 1051</span>&#160;</div><div class="line"><a name="l01052"></a><span class="lineno"><a class="line" href="structAVStream.html#a00f9cfd6b94390286360f004af7882a3"> 1052</a></span>&#160;    <span class="comment">// Timestamp generation support:</span><span class="comment"></span></div><div class="line"><a name="l01053"></a><span class="lineno"><a class="line" href="structAVStream.html#a7c3c240bfa2e64162c3811ffc33207ff"> 1053</a></span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01054"></a><span class="lineno"><a class="line" href="structAVStream.html#a4ec56efe4892728d0b767d55c1238faa"> 1054</a></span>&#160;<span class="comment">     * Timestamp corresponding to the last dts sync point.</span></div><div class="line"><a name="l01055"></a><span class="lineno"><a class="line" href="structAVStream.html#ac815be62a9c05f7da2e2665ee058014b"> 1055</a></span>&#160;<span class="comment">     *</span></div><div class="line"><a name="l01056"></a><span class="lineno"> 1056</span>&#160;<span class="comment">     * Initialized when AVCodecParserContext.dts_sync_point &gt;= 0 and</span></div><div class="line"><a name="l01057"></a><span class="lineno"> 1057</span>&#160;<span class="comment">     * a DTS is received from the underlying container. Otherwise set to</span></div><div class="line"><a name="l01058"></a><span class="lineno"> 1058</span>&#160;<span class="comment">     * AV_NOPTS_VALUE by default.</span></div><div class="line"><a name="l01059"></a><span class="lineno"><a class="line" href="structAVStream.html#a6cdb0c90a69899f4e1e54704bb654936"> 1059</a></span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01060"></a><span class="lineno"> 1060</span>&#160;    int64_t first_dts;</div><div class="line"><a name="l01061"></a><span class="lineno"> 1061</span>&#160;    int64_t cur_dts;</div><div class="line"><a name="l01062"></a><span class="lineno"> 1062</span>&#160;    int64_t last_IP_pts;</div><div class="line"><a name="l01063"></a><span class="lineno"> 1063</span>&#160;    <span class="keywordtype">int</span> last_IP_duration;</div><div class="line"><a name="l01064"></a><span class="lineno"> 1064</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01065"></a><span class="lineno"> 1065</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01066"></a><span class="lineno"> 1066</span>&#160;<span class="comment">     * Number of packets to buffer for codec probing</span></div><div class="line"><a name="l01067"></a><span class="lineno"> 1067</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01068"></a><span class="lineno"> 1068</span>&#160;    <span class="keywordtype">int</span> probe_packets;</div><div class="line"><a name="l01069"></a><span class="lineno"><a class="line" href="structAVStream.html#a1e341587fa92b173a0d6ae73fadb0409"> 1069</a></span>&#160;<span class="comment"></span></div><div class="line"><a name="l01070"></a><span class="lineno"><a class="line" href="structAVStream.html#ad552f602c2113bd5152cff3c58ba1f9f"> 1070</a></span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01071"></a><span class="lineno"><a class="line" href="structAVStream.html#af8e7b1373292e393ed210dc15aa8d2ca"> 1071</a></span>&#160;<span class="comment">     * Number of frames that have been demuxed during avformat_find_stream_info()</span></div><div class="line"><a name="l01072"></a><span class="lineno"><a class="line" href="structAVStream.html#a5764343a4d348f453933bf73c26f84c3"> 1072</a></span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01073"></a><span class="lineno"> 1073</span>&#160;    <span class="keywordtype">int</span> codec_info_nb_frames;</div><div class="line"><a name="l01074"></a><span class="lineno"> 1074</span>&#160;</div><div class="line"><a name="l01075"></a><span class="lineno"> 1075</span>&#160;    <span class="comment">/* av_read_frame() support */</span></div><div class="line"><a name="l01076"></a><span class="lineno"> 1076</span>&#160;    <span class="keyword">enum</span> <a class="code" href="avformat_8h.html#afacbc85f23a50771e3801bda0a353d91">AVStreamParseType</a> need_parsing;</div><div class="line"><a name="l01077"></a><span class="lineno"><a class="line" href="structAVStream.html#a1cd124860be31d0d275bb838ace6a98c"> 1077</a></span>&#160;    <span class="keyword">struct </span><a class="code" href="structAVCodecParserContext.html">AVCodecParserContext</a> *<a class="code" href="structAVCodecParserContext.html#a540286a805755b5b1f9d213f9f1d7109">parser</a>;</div><div class="line"><a name="l01078"></a><span class="lineno"> 1078</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01079"></a><span class="lineno"> 1079</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01080"></a><span class="lineno"> 1080</span>&#160;<span class="comment">     * last packet in packet_buffer for this stream when muxing.</span></div><div class="line"><a name="l01081"></a><span class="lineno"> 1081</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01082"></a><span class="lineno"><a class="line" href="structAVStream.html#adc161a5c5773d42cea315a5ad0454cf2"> 1082</a></span>&#160;    <span class="keyword">struct </span><a class="code" href="structAVPacketList.html">AVPacketList</a> *last_in_packet_buffer;</div><div class="line"><a name="l01083"></a><span class="lineno"> 1083</span>&#160;    <a class="code" href="structAVProbeData.html">AVProbeData</a> probe_data;</div><div class="line"><a name="l01084"></a><span class="lineno"> 1084</span>&#160;<span class="preprocessor">#define MAX_REORDER_DELAY 16</span></div><div class="line"><a name="l01085"></a><span class="lineno"><a class="line" href="structAVStream.html#acd70b72d0c0514643a5c11b2c7c8202c"> 1085</a></span>&#160;    int64_t pts_buffer[<a class="code" href="avformat_8h.html#a1a5362deb573c857ad801ec212ef3583">MAX_REORDER_DELAY</a>+1];</div><div class="line"><a name="l01086"></a><span class="lineno"><a class="line" href="structAVStream.html#a5b1079c1e244d644a86457e7e27545c1"> 1086</a></span>&#160;</div><div class="line"><a name="l01087"></a><span class="lineno"> 1087</span>&#160;    <a class="code" href="structAVIndexEntry.html">AVIndexEntry</a> *index_entries; <span class="comment">/**&lt; Only used if the format does not</span></div><div class="line"><a name="l01088"></a><span class="lineno"> 1088</span>&#160;<span class="comment">                                    support seeking natively. */</span></div><div class="line"><a name="l01089"></a><span class="lineno"> 1089</span>&#160;    <span class="keywordtype">int</span> nb_index_entries;</div><div class="line"><a name="l01090"></a><span class="lineno"> 1090</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index_entries_allocated_size;</div><div class="line"><a name="l01091"></a><span class="lineno"><a class="line" href="structAVStream.html#ab8d53bc29f0761a3f87ec0b5ed7dc8d4"> 1091</a></span>&#160;<span class="comment"></span></div><div class="line"><a name="l01092"></a><span class="lineno"><a class="line" href="structAVStream.html#a9749c451ce3c41a2345933252c4f96c6"> 1092</a></span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01093"></a><span class="lineno"><a class="line" href="avformat_8h.html#a1a5362deb573c857ad801ec212ef3583"> 1093</a></span>&#160;<span class="comment">     * Stream Identifier</span></div><div class="line"><a name="l01094"></a><span class="lineno"><a class="line" href="structAVStream.html#ac13a11eddbc6618f2a7cb66b75f6eb68"> 1094</a></span>&#160;<span class="comment">     * This is the MPEG-TS stream identifier +1</span></div><div class="line"><a name="l01095"></a><span class="lineno"> 1095</span>&#160;<span class="comment">     * 0 means unknown</span></div><div class="line"><a name="l01096"></a><span class="lineno"><a class="line" href="structAVStream.html#abd901928978d19dc6dee65e88f28c6ad"> 1096</a></span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01097"></a><span class="lineno"> 1097</span>&#160;    <span class="keywordtype">int</span> stream_identifier;</div><div class="line"><a name="l01098"></a><span class="lineno"><a class="line" href="structAVStream.html#a79b269ebc3f36441cf8e8a8e8ea347f8"> 1098</a></span>&#160;</div><div class="line"><a name="l01099"></a><span class="lineno"><a class="line" href="structAVStream.html#a03161c9bc3f6339876506750a9c8681f"> 1099</a></span>&#160;    int64_t interleaver_chunk_size;</div><div class="line"><a name="l01100"></a><span class="lineno"> 1100</span>&#160;    int64_t interleaver_chunk_duration;</div><div class="line"><a name="l01101"></a><span class="lineno"> 1101</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01102"></a><span class="lineno"> 1102</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01103"></a><span class="lineno"> 1103</span>&#160;<span class="comment">     * stream probing state</span></div><div class="line"><a name="l01104"></a><span class="lineno"> 1104</span>&#160;<span class="comment">     * -1   -&gt; probing finished</span></div><div class="line"><a name="l01105"></a><span class="lineno"> 1105</span>&#160;<span class="comment">     *  0   -&gt; no probing requested</span></div><div class="line"><a name="l01106"></a><span class="lineno"><a class="line" href="structAVStream.html#a1f5662cbf07c0b0d6a190f040ba93e16"> 1106</a></span>&#160;<span class="comment">     * rest -&gt; perform probing with request_probe being the minimum score to accept.</span></div><div class="line"><a name="l01107"></a><span class="lineno"> 1107</span>&#160;<span class="comment">     * NOT PART OF PUBLIC API</span></div><div class="line"><a name="l01108"></a><span class="lineno"><a class="line" href="structAVStream.html#af131ef55cdd62eebd3b337c6eb261007"> 1108</a></span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01109"></a><span class="lineno"><a class="line" href="structAVStream.html#a56c15542ff9ba2e0ee860cbb7532600a"> 1109</a></span>&#160;    <span class="keywordtype">int</span> request_probe;<span class="comment"></span></div><div class="line"><a name="l01110"></a><span class="lineno"> 1110</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01111"></a><span class="lineno"> 1111</span>&#160;<span class="comment">     * Indicates that everything up to the next keyframe</span></div><div class="line"><a name="l01112"></a><span class="lineno"> 1112</span>&#160;<span class="comment">     * should be discarded.</span></div><div class="line"><a name="l01113"></a><span class="lineno"> 1113</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01114"></a><span class="lineno"> 1114</span>&#160;    <span class="keywordtype">int</span> skip_to_keyframe;</div><div class="line"><a name="l01115"></a><span class="lineno"> 1115</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01116"></a><span class="lineno"> 1116</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01117"></a><span class="lineno"> 1117</span>&#160;<span class="comment">     * Number of samples to skip at the start of the frame decoded from the next packet.</span></div><div class="line"><a name="l01118"></a><span class="lineno"><a class="line" href="structAVStream.html#ab31d9fb6014bb52726ec3144a5d11218"> 1118</a></span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01119"></a><span class="lineno"> 1119</span>&#160;    <span class="keywordtype">int</span> skip_samples;</div><div class="line"><a name="l01120"></a><span class="lineno"> 1120</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01121"></a><span class="lineno"> 1121</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01122"></a><span class="lineno"> 1122</span>&#160;<span class="comment">     * If not 0, the number of samples that should be skipped from the start of</span></div><div class="line"><a name="l01123"></a><span class="lineno"><a class="line" href="structAVStream.html#a097cabf56050028604b398d097c2a5a5"> 1123</a></span>&#160;<span class="comment">     * the stream (the samples are removed from packets with pts==0, which also</span></div><div class="line"><a name="l01124"></a><span class="lineno"> 1124</span>&#160;<span class="comment">     * assumes negative timestamps do not happen).</span></div><div class="line"><a name="l01125"></a><span class="lineno"> 1125</span>&#160;<span class="comment">     * Intended for use with formats such as mp3 with ad-hoc gapless audio</span></div><div class="line"><a name="l01126"></a><span class="lineno"> 1126</span>&#160;<span class="comment">     * support.</span></div><div class="line"><a name="l01127"></a><span class="lineno"> 1127</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01128"></a><span class="lineno"><a class="line" href="structAVStream.html#a50093ce4f0989bfbcac3d04fedc2093a"> 1128</a></span>&#160;    int64_t start_skip_samples;</div><div class="line"><a name="l01129"></a><span class="lineno"> 1129</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01130"></a><span class="lineno"> 1130</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01131"></a><span class="lineno"> 1131</span>&#160;<span class="comment">     * If not 0, the first audio sample that should be discarded from the stream.</span></div><div class="line"><a name="l01132"></a><span class="lineno"> 1132</span>&#160;<span class="comment">     * This is broken by design (needs global sample count), but can&#39;t be</span></div><div class="line"><a name="l01133"></a><span class="lineno"> 1133</span>&#160;<span class="comment">     * avoided for broken by design formats such as mp3 with ad-hoc gapless</span></div><div class="line"><a name="l01134"></a><span class="lineno"> 1134</span>&#160;<span class="comment">     * audio support.</span></div><div class="line"><a name="l01135"></a><span class="lineno"> 1135</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01136"></a><span class="lineno"> 1136</span>&#160;    int64_t first_discard_sample;</div><div class="line"><a name="l01137"></a><span class="lineno"><a class="line" href="structAVStream.html#a8e462c640917bd7058ac3cf716564cd8"> 1137</a></span>&#160;<span class="comment"></span></div><div class="line"><a name="l01138"></a><span class="lineno"> 1138</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01139"></a><span class="lineno"> 1139</span>&#160;<span class="comment">     * The sample after last sample that is intended to be discarded after</span></div><div class="line"><a name="l01140"></a><span class="lineno"> 1140</span>&#160;<span class="comment">     * first_discard_sample. Works on frame boundaries only. Used to prevent</span></div><div class="line"><a name="l01141"></a><span class="lineno"> 1141</span>&#160;<span class="comment">     * early EOF if the gapless info is broken (considered concatenated mp3s).</span></div><div class="line"><a name="l01142"></a><span class="lineno"> 1142</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01143"></a><span class="lineno"> 1143</span>&#160;    int64_t last_discard_sample;</div><div class="line"><a name="l01144"></a><span class="lineno"> 1144</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01145"></a><span class="lineno"><a class="line" href="structAVStream.html#ad40dedb50c20e0669176e257eedf1bc0"> 1145</a></span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01146"></a><span class="lineno"> 1146</span>&#160;<span class="comment">     * Number of internally decoded frames, used internally in libavformat, do not access</span></div><div class="line"><a name="l01147"></a><span class="lineno"> 1147</span>&#160;<span class="comment">     * its lifetime differs from info which is why it is not in that structure.</span></div><div class="line"><a name="l01148"></a><span class="lineno"> 1148</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01149"></a><span class="lineno"> 1149</span>&#160;    <span class="keywordtype">int</span> nb_decoded_frames;</div><div class="line"><a name="l01150"></a><span class="lineno"> 1150</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01151"></a><span class="lineno"> 1151</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01152"></a><span class="lineno"><a class="line" href="structAVStream.html#a9c52fc235fbdf30acd2d817824f3289a"> 1152</a></span>&#160;<span class="comment">     * Timestamp offset added to timestamps before muxing</span></div><div class="line"><a name="l01153"></a><span class="lineno"> 1153</span>&#160;<span class="comment">     * NOT PART OF PUBLIC API</span></div><div class="line"><a name="l01154"></a><span class="lineno"> 1154</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01155"></a><span class="lineno"> 1155</span>&#160;    int64_t mux_ts_offset;</div><div class="line"><a name="l01156"></a><span class="lineno"> 1156</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01157"></a><span class="lineno"> 1157</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01158"></a><span class="lineno"><a class="line" href="structAVStream.html#a8937969e00c765697d7a8e55a0221e04"> 1158</a></span>&#160;<span class="comment">     * Internal data to check for wrapping of the time stamp</span></div><div class="line"><a name="l01159"></a><span class="lineno"> 1159</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01160"></a><span class="lineno"> 1160</span>&#160;    int64_t pts_wrap_reference;</div><div class="line"><a name="l01161"></a><span class="lineno"> 1161</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01162"></a><span class="lineno"> 1162</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01163"></a><span class="lineno"> 1163</span>&#160;<span class="comment">     * Options for behavior, when a wrap is detected.</span></div><div class="line"><a name="l01164"></a><span class="lineno"><a class="line" href="structAVStream.html#ae0598c5dc8ff45ac6cb56a7a23847a37"> 1164</a></span>&#160;<span class="comment">     *</span></div><div class="line"><a name="l01165"></a><span class="lineno"> 1165</span>&#160;<span class="comment">     * Defined by AV_PTS_WRAP_ values.</span></div><div class="line"><a name="l01166"></a><span class="lineno"> 1166</span>&#160;<span class="comment">     *</span></div><div class="line"><a name="l01167"></a><span class="lineno"> 1167</span>&#160;<span class="comment">     * If correction is enabled, there are two possibilities:</span></div><div class="line"><a name="l01168"></a><span class="lineno"> 1168</span>&#160;<span class="comment">     * If the first time stamp is near the wrap point, the wrap offset</span></div><div class="line"><a name="l01169"></a><span class="lineno"><a class="line" href="structAVStream.html#a5456b9e13c27ed10d42259f46297da5d"> 1169</a></span>&#160;<span class="comment">     * will be subtracted, which will create negative time stamps.</span></div><div class="line"><a name="l01170"></a><span class="lineno"> 1170</span>&#160;<span class="comment">     * Otherwise the offset will be added.</span></div><div class="line"><a name="l01171"></a><span class="lineno"> 1171</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01172"></a><span class="lineno"> 1172</span>&#160;    <span class="keywordtype">int</span> pts_wrap_behavior;</div><div class="line"><a name="l01173"></a><span class="lineno"> 1173</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01174"></a><span class="lineno"> 1174</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01175"></a><span class="lineno"> 1175</span>&#160;<span class="comment">     * Internal data to prevent doing update_initial_durations() twice</span></div><div class="line"><a name="l01176"></a><span class="lineno"> 1176</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01177"></a><span class="lineno"> 1177</span>&#160;    <span class="keywordtype">int</span> update_initial_durations_done;</div><div class="line"><a name="l01178"></a><span class="lineno"> 1178</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01179"></a><span class="lineno"> 1179</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01180"></a><span class="lineno"> 1180</span>&#160;<span class="comment">     * Internal data to generate dts from pts</span></div><div class="line"><a name="l01181"></a><span class="lineno"><a class="line" href="structAVStream.html#aeb3eeb80578432b07b73cb5951c07c5c"> 1181</a></span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01182"></a><span class="lineno"> 1182</span>&#160;    int64_t pts_reorder_error[<a class="code" href="avformat_8h.html#a1a5362deb573c857ad801ec212ef3583">MAX_REORDER_DELAY</a>+1];</div><div class="line"><a name="l01183"></a><span class="lineno"> 1183</span>&#160;    uint8_t pts_reorder_error_count[<a class="code" href="avformat_8h.html#a1a5362deb573c857ad801ec212ef3583">MAX_REORDER_DELAY</a>+1];</div><div class="line"><a name="l01184"></a><span class="lineno"> 1184</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01185"></a><span class="lineno"> 1185</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01186"></a><span class="lineno"><a class="line" href="structAVStream.html#a93fae347b93594cbe8ce7d414519b78a"> 1186</a></span>&#160;<span class="comment">     * Internal data to analyze DTS and detect faulty mpeg streams</span></div><div class="line"><a name="l01187"></a><span class="lineno"> 1187</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01188"></a><span class="lineno"> 1188</span>&#160;    int64_t last_dts_for_order_check;</div><div class="line"><a name="l01189"></a><span class="lineno"> 1189</span>&#160;    uint8_t dts_ordered;</div><div class="line"><a name="l01190"></a><span class="lineno"> 1190</span>&#160;    uint8_t dts_misordered;</div><div class="line"><a name="l01191"></a><span class="lineno"><a class="line" href="structAVStream.html#ad3e2b5f6e98424f1e5e5bfc909cee38b"> 1191</a></span>&#160;<span class="comment"></span></div><div class="line"><a name="l01192"></a><span class="lineno"><a class="line" href="structAVStream.html#acd6fe77bbabf1ad6727492a2749e5275"> 1192</a></span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01193"></a><span class="lineno"> 1193</span>&#160;<span class="comment">     * Internal data to inject global side data</span></div><div class="line"><a name="l01194"></a><span class="lineno"> 1194</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01195"></a><span class="lineno"> 1195</span>&#160;    <span class="keywordtype">int</span> inject_global_side_data;</div><div class="line"><a name="l01196"></a><span class="lineno"> 1196</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01197"></a><span class="lineno"><a class="line" href="structAVStream.html#ada8c3bd5c2de4c1b5f0895e088167e03"> 1197</a></span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01198"></a><span class="lineno"><a class="line" href="structAVStream.html#a936ec7b1aa699303d20e4489ad4054e3"> 1198</a></span>&#160;<span class="comment">     * display aspect ratio (0 if unknown)</span></div><div class="line"><a name="l01199"></a><span class="lineno"><a class="line" href="structAVStream.html#a02b107869ea9e14c784d1bfdade3ebf2"> 1199</a></span>&#160;<span class="comment">     * - encoding: unused</span></div><div class="line"><a name="l01200"></a><span class="lineno"> 1200</span>&#160;<span class="comment">     * - decoding: Set by libavformat to calculate sample_aspect_ratio internally</span></div><div class="line"><a name="l01201"></a><span class="lineno"> 1201</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01202"></a><span class="lineno"> 1202</span>&#160;    <a class="code" href="structAVRational.html">AVRational</a> display_aspect_ratio;</div><div class="line"><a name="l01203"></a><span class="lineno"> 1203</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01204"></a><span class="lineno"><a class="line" href="structAVStream.html#ab266c3ac8277c4bdf1199b5b1b2b1873"> 1204</a></span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01205"></a><span class="lineno"> 1205</span>&#160;<span class="comment">     * An opaque field for libavformat internal usage.</span></div><div class="line"><a name="l01206"></a><span class="lineno"> 1206</span>&#160;<span class="comment">     * Must not be accessed in any way by callers.</span></div><div class="line"><a name="l01207"></a><span class="lineno"> 1207</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01208"></a><span class="lineno"> 1208</span>&#160;    <a class="code" href="avformat_8h.html#a5989dd9dc73f1e05d7cce92a056180bd">AVStreamInternal</a> *<span class="keyword">internal</span>;</div><div class="line"><a name="l01209"></a><span class="lineno"> 1209</span>&#160;} <a class="code" href="structAVStream.html">AVStream</a>;</div><div class="line"><a name="l01210"></a><span class="lineno"> 1210</span>&#160;</div><div class="line"><a name="l01211"></a><span class="lineno"><a class="line" href="structAVStream.html#a36740140a5b28afefab96c546e268df3"> 1211</a></span>&#160;<span class="preprocessor">#if FF_API_FORMAT_GET_SET</span></div><div class="line"><a name="l01212"></a><span class="lineno"> 1212</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l01213"></a><span class="lineno"> 1213</span>&#160;<span class="comment"> * Accessors for some AVStream fields. These used to be provided for ABI</span></div><div class="line"><a name="l01214"></a><span class="lineno"> 1214</span>&#160;<span class="comment"> * compatibility, and do not need to be used anymore.</span></div><div class="line"><a name="l01215"></a><span class="lineno"> 1215</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l01216"></a><span class="lineno"> 1216</span>&#160;<a class="code" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a></div><div class="line"><a name="l01217"></a><span class="lineno"><a class="line" href="structAVStream.html#ae495a86ddec02af7d5a2805beba9ac9f"> 1217</a></span>&#160;<a class="code" href="structAVRational.html">AVRational</a> av_stream_get_r_frame_rate(<span class="keyword">const</span> <a class="code" href="structAVStream.html">AVStream</a> *s);</div><div class="line"><a name="l01218"></a><span class="lineno"> 1218</span>&#160;<a class="code" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a></div><div class="line"><a name="l01219"></a><span class="lineno"> 1219</span>&#160;<span class="keywordtype">void</span>       av_stream_set_r_frame_rate(<a class="code" href="structAVStream.html">AVStream</a> *s, <a class="code" href="structAVRational.html">AVRational</a> r);</div><div class="line"><a name="l01220"></a><span class="lineno"> 1220</span>&#160;<a class="code" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a></div><div class="line"><a name="l01221"></a><span class="lineno"> 1221</span>&#160;<span class="keywordtype">char</span>* av_stream_get_recommended_encoder_configuration(<span class="keyword">const</span> <a class="code" href="structAVStream.html">AVStream</a> *s);</div><div class="line"><a name="l01222"></a><span class="lineno"> 1222</span>&#160;<a class="code" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a></div><div class="line"><a name="l01223"></a><span class="lineno"> 1223</span>&#160;<span class="keywordtype">void</span>  av_stream_set_recommended_encoder_configuration(<a class="code" href="structAVStream.html">AVStream</a> *s, <span class="keywordtype">char</span> *configuration);</div><div class="line"><a name="l01224"></a><span class="lineno"> 1224</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l01225"></a><span class="lineno"> 1225</span>&#160;</div><div class="line"><a name="l01226"></a><span class="lineno"> 1226</span>&#160;<span class="keyword">struct </span><a class="code" href="structAVCodecParserContext.html">AVCodecParserContext</a> *<a class="code" href="avformat_8h.html#a125e78a8250557501479986fead28a43">av_stream_get_parser</a>(<span class="keyword">const</span> <a class="code" href="structAVStream.html">AVStream</a> *s);</div><div class="line"><a name="l01227"></a><span class="lineno"> 1227</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01228"></a><span class="lineno"> 1228</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l01229"></a><span class="lineno"> 1229</span>&#160;<span class="comment"> * Returns the pts of the last muxed packet + its duration</span></div><div class="line"><a name="l01230"></a><span class="lineno"> 1230</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l01231"></a><span class="lineno"> 1231</span>&#160;<span class="comment"> * the retuned value is undefined when used with a demuxer.</span></div><div class="line"><a name="l01232"></a><span class="lineno"> 1232</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l01233"></a><span class="lineno"> 1233</span>&#160;int64_t    <a class="code" href="avformat_8h.html#aea2211b21ee4a9a443886c2e0a63be1c">av_stream_get_end_pts</a>(<span class="keyword">const</span> <a class="code" href="structAVStream.html">AVStream</a> *st);</div><div class="line"><a name="l01234"></a><span class="lineno"> 1234</span>&#160;</div><div class="line"><a name="l01235"></a><span class="lineno"> 1235</span>&#160;<span class="preprocessor">#define AV_PROGRAM_RUNNING 1</span></div><div class="line"><a name="l01236"></a><span class="lineno"> 1236</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01237"></a><span class="lineno"> 1237</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l01238"></a><span class="lineno"> 1238</span>&#160;<span class="comment"> * New fields can be added to the end with minor version bumps.</span></div><div class="line"><a name="l01239"></a><span class="lineno"> 1239</span>&#160;<span class="comment"> * Removal, reordering and changes to existing fields require a major</span></div><div class="line"><a name="l01240"></a><span class="lineno"> 1240</span>&#160;<span class="comment"> * version bump.</span></div><div class="line"><a name="l01241"></a><span class="lineno"> 1241</span>&#160;<span class="comment"> * sizeof(AVProgram) must not be used outside libav*.</span></div><div class="line"><a name="l01242"></a><span class="lineno"> 1242</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l01243"></a><span class="lineno"> 1243</span>&#160;<span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structAVProgram.html">AVProgram</a> {</div><div class="line"><a name="l01244"></a><span class="lineno"><a class="line" href="avformat_8h.html#a1f70b27f61ebf7a52fd53515af132f60"> 1244</a></span>&#160;    <span class="keywordtype">int</span>            id;</div><div class="line"><a name="l01245"></a><span class="lineno"> 1245</span>&#160;    <span class="keywordtype">int</span>            flags;</div><div class="line"><a name="l01246"></a><span class="lineno"> 1246</span>&#160;    <span class="keyword">enum</span> <a class="code" href="group__lavc__decoding.html#ga352363bce7d3ed82c101b3bc001d1c16">AVDiscard</a> discard;        <span class="comment">///&lt; selects which program to discard and which to feed to the caller</span></div><div class="line"><a name="l01247"></a><span class="lineno"> 1247</span>&#160;<span class="comment"></span>    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   *stream_index;</div><div class="line"><a name="l01248"></a><span class="lineno"> 1248</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>   nb_stream_indexes;</div><div class="line"><a name="l01249"></a><span class="lineno"> 1249</span>&#160;    <a class="code" href="group__lavu__dict.html#ga1d7cc0833bee918994a600556410315f">AVDictionary</a> *metadata;</div><div class="line"><a name="l01250"></a><span class="lineno"> 1250</span>&#160;</div><div class="line"><a name="l01251"></a><span class="lineno"> 1251</span>&#160;    <span class="keywordtype">int</span> program_num;</div><div class="line"><a name="l01252"></a><span class="lineno"><a class="line" href="structAVProgram.html"> 1252</a></span>&#160;    <span class="keywordtype">int</span> pmt_pid;</div><div class="line"><a name="l01253"></a><span class="lineno"><a class="line" href="structAVProgram.html#a10cc799a98b37335e820b0bdb386eb95"> 1253</a></span>&#160;    <span class="keywordtype">int</span> pcr_pid;</div><div class="line"><a name="l01254"></a><span class="lineno"><a class="line" href="structAVProgram.html#a8c87564167b87f54be9171778d51fe49"> 1254</a></span>&#160;</div><div class="line"><a name="l01255"></a><span class="lineno"><a class="line" href="structAVProgram.html#a9c7a07c08a1f960aaa49f3f47633af5c"> 1255</a></span>&#160;    <span class="comment">/*****************************************************************</span></div><div class="line"><a name="l01256"></a><span class="lineno"><a class="line" href="structAVProgram.html#a7967d41af4812ed61a28762e988c7a02"> 1256</a></span>&#160;<span class="comment">     * All fields below this line are not part of the public API. They</span></div><div class="line"><a name="l01257"></a><span class="lineno"><a class="line" href="structAVProgram.html#a136cf29d2aa5b0e4c6d743406c5e39d1"> 1257</a></span>&#160;<span class="comment">     * may not be used outside of libavformat and can be changed and</span></div><div class="line"><a name="l01258"></a><span class="lineno"><a class="line" href="structAVProgram.html#ae9dab38d4694e3da9cba0f882f4e43d3"> 1258</a></span>&#160;<span class="comment">     * removed at will.</span></div><div class="line"><a name="l01259"></a><span class="lineno"> 1259</span>&#160;<span class="comment">     * New public fields should be added right above.</span></div><div class="line"><a name="l01260"></a><span class="lineno"><a class="line" href="structAVProgram.html#a4c1539ea3c98da979b95a59a3ea163cb"> 1260</a></span>&#160;<span class="comment">     *****************************************************************</span></div><div class="line"><a name="l01261"></a><span class="lineno"><a class="line" href="structAVProgram.html#a02011963a63c291c6dc6d4eefa56cd69"> 1261</a></span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01262"></a><span class="lineno"><a class="line" href="structAVProgram.html#a7e026323df87e84a72ec5e5c8ce341a5"> 1262</a></span>&#160;    int64_t start_time;</div><div class="line"><a name="l01263"></a><span class="lineno"> 1263</span>&#160;    int64_t end_time;</div><div class="line"><a name="l01264"></a><span class="lineno"> 1264</span>&#160;</div><div class="line"><a name="l01265"></a><span class="lineno"> 1265</span>&#160;    int64_t pts_wrap_reference;    <span class="comment">///&lt; reference dts for wrap detection</span></div><div class="line"><a name="l01266"></a><span class="lineno"> 1266</span>&#160;<span class="comment"></span>    <span class="keywordtype">int</span> pts_wrap_behavior;         <span class="comment">///&lt; behavior on wrap detection</span></div><div class="line"><a name="l01267"></a><span class="lineno"> 1267</span>&#160;<span class="comment"></span>} <a class="code" href="structAVProgram.html">AVProgram</a>;</div><div class="line"><a name="l01268"></a><span class="lineno"> 1268</span>&#160;</div><div class="line"><a name="l01269"></a><span class="lineno"> 1269</span>&#160;<span class="preprocessor">#define AVFMTCTX_NOHEADER      0x0001 </span><span class="comment">/**&lt; signal that no header is present</span></div><div class="line"><a name="l01270"></a><span class="lineno"> 1270</span>&#160;<span class="comment">                                         (streams are added dynamically) */</span><span class="preprocessor"></span></div><div class="line"><a name="l01271"></a><span class="lineno"><a class="line" href="structAVProgram.html#a2276db4d51695120664d527f20b7c532"> 1271</a></span>&#160;</div><div class="line"><a name="l01272"></a><span class="lineno"><a class="line" href="structAVProgram.html#a5a7795c918153d0f64d68a838e172db4"> 1272</a></span>&#160;<span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structAVChapter.html">AVChapter</a> {</div><div class="line"><a name="l01273"></a><span class="lineno"> 1273</span>&#160;    <span class="keywordtype">int</span> id;                 <span class="comment">///&lt; unique ID to identify the chapter</span></div><div class="line"><a name="l01274"></a><span class="lineno"><a class="line" href="structAVProgram.html#a7e539e286876577e158039f6e7678452"> 1274</a></span>&#160;<span class="comment"></span>    <a class="code" href="structAVRational.html">AVRational</a> time_base;   <span class="comment">///&lt; time base in which the start/end timestamps are specified</span></div><div class="line"><a name="l01275"></a><span class="lineno"><a class="line" href="structAVProgram.html#aa3f8af78093a910ff766ac5af381758b"> 1275</a></span>&#160;<span class="comment"></span>    int64_t start, end;     <span class="comment">///&lt; chapter start/end time in time_base units</span></div><div class="line"><a name="l01276"></a><span class="lineno"> 1276</span>&#160;<span class="comment"></span>    <a class="code" href="group__lavu__dict.html#ga1d7cc0833bee918994a600556410315f">AVDictionary</a> *metadata;</div><div class="line"><a name="l01277"></a><span class="lineno"> 1277</span>&#160;} <a class="code" href="structAVChapter.html">AVChapter</a>;</div><div class="line"><a name="l01278"></a><span class="lineno"><a class="line" href="avformat_8h.html#a42e3c3d72e561fdc501613962fccc4aa"> 1278</a></span>&#160;</div><div class="line"><a name="l01279"></a><span class="lineno"> 1279</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01280"></a><span class="lineno"> 1280</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l01281"></a><span class="lineno"> 1281</span>&#160;<span class="comment"> * Callback used by devices to communicate with application.</span></div><div class="line"><a name="l01282"></a><span class="lineno"><a class="line" href="structAVChapter.html"> 1282</a></span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l01283"></a><span class="lineno"><a class="line" href="structAVChapter.html#a2a48026c205e948f8bfaafe92d41f752"> 1283</a></span>&#160;<span class="keyword">typedef</span> int (*<a class="code" href="avformat_8h.html#a80856b99bcf4373936fb4fba028b11ca">av_format_control_message</a>)(<span class="keyword">struct </span><a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s, <span class="keywordtype">int</span> type,</div><div class="line"><a name="l01284"></a><span class="lineno"><a class="line" href="structAVChapter.html#acb5cb6ce9bb6b9f4b970a919f4899818"> 1284</a></span>&#160;                                         <span class="keywordtype">void</span> *data, <span class="keywordtype">size_t</span> data_size);</div><div class="line"><a name="l01285"></a><span class="lineno"><a class="line" href="structAVChapter.html#a499a5062224e22249be6f2d16f74c449"> 1285</a></span>&#160;</div><div class="line"><a name="l01286"></a><span class="lineno"><a class="line" href="structAVChapter.html#a998ea9c9f86547970d58f0b405d55332"> 1286</a></span>&#160;<span class="keyword">typedef</span> int (*<a class="code" href="avformat_8h.html#a6f7cab62acdf2bce2883a3c82cf1a27c">AVOpenCallback</a>)(<span class="keyword">struct </span><a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s, <a class="code" href="structAVIOContext.html">AVIOContext</a> **<a class="code" href="structAVFormatContext.html#a1e7324262b6b78522e52064daaa7bc87">pb</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *url, <span class="keywordtype">int</span> <a class="code" href="structAVFormatContext.html#a32379cc371463b235d54235d4af06a15">flags</a>,</div><div class="line"><a name="l01287"></a><span class="lineno"> 1287</span>&#160;                              <span class="keyword">const</span> <a class="code" href="structAVIOInterruptCB.html">AVIOInterruptCB</a> *int_cb, <a class="code" href="group__lavu__dict.html#ga1d7cc0833bee918994a600556410315f">AVDictionary</a> **options);</div><div class="line"><a name="l01288"></a><span class="lineno"> 1288</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01289"></a><span class="lineno"> 1289</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l01290"></a><span class="lineno"> 1290</span>&#160;<span class="comment"> * The duration of a video can be estimated through various ways, and this enum can be used</span></div><div class="line"><a name="l01291"></a><span class="lineno"> 1291</span>&#160;<span class="comment"> * to know how the duration was estimated.</span></div><div class="line"><a name="l01292"></a><span class="lineno"> 1292</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l01293"></a><span class="lineno"><a class="line" href="avformat_8h.html#a80856b99bcf4373936fb4fba028b11ca"> 1293</a></span>&#160;<span class="keyword">enum</span> <a class="code" href="avformat_8h.html#a7c2692ffa20d3e888e40e79eeda6d73b">AVDurationEstimationMethod</a> {</div><div class="line"><a name="l01294"></a><span class="lineno"> 1294</span>&#160;    <a class="code" href="avformat_8h.html#a7c2692ffa20d3e888e40e79eeda6d73bac94465d3290399477775fe094ab8f75a">AVFMT_DURATION_FROM_PTS</a>,    <span class="comment">///&lt; Duration accurately estimated from PTSes</span></div><div class="line"><a name="l01295"></a><span class="lineno"> 1295</span>&#160;<span class="comment"></span>    <a class="code" href="avformat_8h.html#a7c2692ffa20d3e888e40e79eeda6d73bae92edb9576c3d6dd68f49a849a2ec6c0">AVFMT_DURATION_FROM_STREAM</a>, <span class="comment">///&lt; Duration estimated from a stream with a known duration</span></div><div class="line"><a name="l01296"></a><span class="lineno"><a class="line" href="avformat_8h.html#a6f7cab62acdf2bce2883a3c82cf1a27c"> 1296</a></span>&#160;<span class="comment"></span>    <a class="code" href="avformat_8h.html#a7c2692ffa20d3e888e40e79eeda6d73ba6185e1e7f8dfae85596779408ef496b2">AVFMT_DURATION_FROM_BITRATE</a> <span class="comment">///&lt; Duration estimated from bitrate (less accurate)</span></div><div class="line"><a name="l01297"></a><span class="lineno"> 1297</span>&#160;<span class="comment"></span>};</div><div class="line"><a name="l01298"></a><span class="lineno"> 1298</span>&#160;</div><div class="line"><a name="l01299"></a><span class="lineno"> 1299</span>&#160;<span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="avformat_8h.html#a7bec8d592652431045d81a02fef74f28">AVFormatInternal</a> <a class="code" href="avformat_8h.html#a7bec8d592652431045d81a02fef74f28">AVFormatInternal</a>;</div><div class="line"><a name="l01300"></a><span class="lineno"> 1300</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01301"></a><span class="lineno"> 1301</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l01302"></a><span class="lineno"> 1302</span>&#160;<span class="comment"> * Format I/O context.</span></div><div class="line"><a name="l01303"></a><span class="lineno"><a class="line" href="avformat_8h.html#a7c2692ffa20d3e888e40e79eeda6d73b"> 1303</a></span>&#160;<span class="comment"> * New fields can be added to the end with minor version bumps.</span></div><div class="line"><a name="l01304"></a><span class="lineno"><a class="line" href="avformat_8h.html#a7c2692ffa20d3e888e40e79eeda6d73bac94465d3290399477775fe094ab8f75a"> 1304</a></span>&#160;<span class="comment"> * Removal, reordering and changes to existing fields require a major</span></div><div class="line"><a name="l01305"></a><span class="lineno"><a class="line" href="avformat_8h.html#a7c2692ffa20d3e888e40e79eeda6d73bae92edb9576c3d6dd68f49a849a2ec6c0"> 1305</a></span>&#160;<span class="comment"> * version bump.</span></div><div class="line"><a name="l01306"></a><span class="lineno"><a class="line" href="avformat_8h.html#a7c2692ffa20d3e888e40e79eeda6d73ba6185e1e7f8dfae85596779408ef496b2"> 1306</a></span>&#160;<span class="comment"> * sizeof(AVFormatContext) must not be used outside libav*, use</span></div><div class="line"><a name="l01307"></a><span class="lineno"> 1307</span>&#160;<span class="comment"> * avformat_alloc_context() to create an AVFormatContext.</span></div><div class="line"><a name="l01308"></a><span class="lineno"> 1308</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l01309"></a><span class="lineno"><a class="line" href="avformat_8h.html#a7bec8d592652431045d81a02fef74f28"> 1309</a></span>&#160;<span class="comment"> * Fields can be accessed through AVOptions (av_opt*),</span></div><div class="line"><a name="l01310"></a><span class="lineno"> 1310</span>&#160;<span class="comment"> * the name string used matches the associated command line parameter name and</span></div><div class="line"><a name="l01311"></a><span class="lineno"> 1311</span>&#160;<span class="comment"> * can be found in libavformat/options_table.h.</span></div><div class="line"><a name="l01312"></a><span class="lineno"> 1312</span>&#160;<span class="comment"> * The AVOption/command line parameter names differ in some cases from the C</span></div><div class="line"><a name="l01313"></a><span class="lineno"> 1313</span>&#160;<span class="comment"> * structure field names for historic reasons or brevity.</span></div><div class="line"><a name="l01314"></a><span class="lineno"> 1314</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l01315"></a><span class="lineno"> 1315</span>&#160;<span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structAVFormatContext.html">AVFormatContext</a> {<span class="comment"></span></div><div class="line"><a name="l01316"></a><span class="lineno"> 1316</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01317"></a><span class="lineno"> 1317</span>&#160;<span class="comment">     * A class for logging and @ref avoptions. Set by avformat_alloc_context().</span></div><div class="line"><a name="l01318"></a><span class="lineno"> 1318</span>&#160;<span class="comment">     * Exports (de)muxer private options if they exist.</span></div><div class="line"><a name="l01319"></a><span class="lineno"> 1319</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01320"></a><span class="lineno"> 1320</span>&#160;    <span class="keyword">const</span> <a class="code" href="structAVClass.html">AVClass</a> *av_class;</div><div class="line"><a name="l01321"></a><span class="lineno"> 1321</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01322"></a><span class="lineno"> 1322</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01323"></a><span class="lineno"> 1323</span>&#160;<span class="comment">     * The input container format.</span></div><div class="line"><a name="l01324"></a><span class="lineno"> 1324</span>&#160;<span class="comment">     *</span></div><div class="line"><a name="l01325"></a><span class="lineno"><a class="line" href="structAVFormatContext.html"> 1325</a></span>&#160;<span class="comment">     * Demuxing only, set by avformat_open_input().</span></div><div class="line"><a name="l01326"></a><span class="lineno"> 1326</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01327"></a><span class="lineno"> 1327</span>&#160;    <span class="keyword">struct </span><a class="code" href="structAVInputFormat.html">AVInputFormat</a> *iformat;</div><div class="line"><a name="l01328"></a><span class="lineno"> 1328</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01329"></a><span class="lineno"> 1329</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01330"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a0c396740b9a2487aa57d4352d2dc1687"> 1330</a></span>&#160;<span class="comment">     * The output container format.</span></div><div class="line"><a name="l01331"></a><span class="lineno"> 1331</span>&#160;<span class="comment">     *</span></div><div class="line"><a name="l01332"></a><span class="lineno"> 1332</span>&#160;<span class="comment">     * Muxing only, must be set by the caller before avformat_write_header().</span></div><div class="line"><a name="l01333"></a><span class="lineno"> 1333</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01334"></a><span class="lineno"> 1334</span>&#160;    <span class="keyword">struct </span><a class="code" href="structAVOutputFormat.html">AVOutputFormat</a> *oformat;</div><div class="line"><a name="l01335"></a><span class="lineno"> 1335</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01336"></a><span class="lineno"> 1336</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01337"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a78efc5a53c21c8d81197445207ac4374"> 1337</a></span>&#160;<span class="comment">     * Format private data. This is an AVOptions-enabled struct</span></div><div class="line"><a name="l01338"></a><span class="lineno"> 1338</span>&#160;<span class="comment">     * if and only if iformat/oformat.priv_class is not NULL.</span></div><div class="line"><a name="l01339"></a><span class="lineno"> 1339</span>&#160;<span class="comment">     *</span></div><div class="line"><a name="l01340"></a><span class="lineno"> 1340</span>&#160;<span class="comment">     * - muxing: set by avformat_write_header()</span></div><div class="line"><a name="l01341"></a><span class="lineno"> 1341</span>&#160;<span class="comment">     * - demuxing: set by avformat_open_input()</span></div><div class="line"><a name="l01342"></a><span class="lineno"> 1342</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01343"></a><span class="lineno"> 1343</span>&#160;    <span class="keywordtype">void</span> *priv_data;</div><div class="line"><a name="l01344"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a20d80ac07e38ff5c268d15aaf2798b98"> 1344</a></span>&#160;<span class="comment"></span></div><div class="line"><a name="l01345"></a><span class="lineno"> 1345</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01346"></a><span class="lineno"> 1346</span>&#160;<span class="comment">     * I/O context.</span></div><div class="line"><a name="l01347"></a><span class="lineno"> 1347</span>&#160;<span class="comment">     *</span></div><div class="line"><a name="l01348"></a><span class="lineno"> 1348</span>&#160;<span class="comment">     * - demuxing: either set by the user before avformat_open_input() (then</span></div><div class="line"><a name="l01349"></a><span class="lineno"> 1349</span>&#160;<span class="comment">     *             the user must close it manually) or set by avformat_open_input().</span></div><div class="line"><a name="l01350"></a><span class="lineno"> 1350</span>&#160;<span class="comment">     * - muxing: set by the user before avformat_write_header(). The caller must</span></div><div class="line"><a name="l01351"></a><span class="lineno"> 1351</span>&#160;<span class="comment">     *           take care of closing / freeing the IO context.</span></div><div class="line"><a name="l01352"></a><span class="lineno"> 1352</span>&#160;<span class="comment">     *</span></div><div class="line"><a name="l01353"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#ac4c0777e54085af2f3f1b27130e2b21b"> 1353</a></span>&#160;<span class="comment">     * Do NOT set this field if AVFMT_NOFILE flag is set in</span></div><div class="line"><a name="l01354"></a><span class="lineno"> 1354</span>&#160;<span class="comment">     * iformat/oformat.flags. In such a case, the (de)muxer will handle</span></div><div class="line"><a name="l01355"></a><span class="lineno"> 1355</span>&#160;<span class="comment">     * I/O in some other way and this field will be NULL.</span></div><div class="line"><a name="l01356"></a><span class="lineno"> 1356</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01357"></a><span class="lineno"> 1357</span>&#160;    <a class="code" href="structAVIOContext.html">AVIOContext</a> *pb;</div><div class="line"><a name="l01358"></a><span class="lineno"> 1358</span>&#160;</div><div class="line"><a name="l01359"></a><span class="lineno"> 1359</span>&#160;    <span class="comment">/* stream info */</span><span class="comment"></span></div><div class="line"><a name="l01360"></a><span class="lineno"> 1360</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01361"></a><span class="lineno"> 1361</span>&#160;<span class="comment">     * Flags signalling stream properties. A combination of AVFMTCTX_*.</span></div><div class="line"><a name="l01362"></a><span class="lineno"> 1362</span>&#160;<span class="comment">     * Set by libavformat.</span></div><div class="line"><a name="l01363"></a><span class="lineno"> 1363</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01364"></a><span class="lineno"> 1364</span>&#160;    <span class="keywordtype">int</span> ctx_flags;</div><div class="line"><a name="l01365"></a><span class="lineno"> 1365</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01366"></a><span class="lineno"> 1366</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01367"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a1e7324262b6b78522e52064daaa7bc87"> 1367</a></span>&#160;<span class="comment">     * Number of elements in AVFormatContext.streams.</span></div><div class="line"><a name="l01368"></a><span class="lineno"> 1368</span>&#160;<span class="comment">     *</span></div><div class="line"><a name="l01369"></a><span class="lineno"> 1369</span>&#160;<span class="comment">     * Set by avformat_new_stream(), must not be modified by any other code.</span></div><div class="line"><a name="l01370"></a><span class="lineno"> 1370</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01371"></a><span class="lineno"> 1371</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nb_streams;<span class="comment"></span></div><div class="line"><a name="l01372"></a><span class="lineno"> 1372</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01373"></a><span class="lineno"> 1373</span>&#160;<span class="comment">     * A list of all streams in the file. New streams are created with</span></div><div class="line"><a name="l01374"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a4e6076343df1ffc2e16cedbba3f3f397"> 1374</a></span>&#160;<span class="comment">     * avformat_new_stream().</span></div><div class="line"><a name="l01375"></a><span class="lineno"> 1375</span>&#160;<span class="comment">     *</span></div><div class="line"><a name="l01376"></a><span class="lineno"> 1376</span>&#160;<span class="comment">     * - demuxing: streams are created by libavformat in avformat_open_input().</span></div><div class="line"><a name="l01377"></a><span class="lineno"> 1377</span>&#160;<span class="comment">     *             If AVFMTCTX_NOHEADER is set in ctx_flags, then new streams may also</span></div><div class="line"><a name="l01378"></a><span class="lineno"> 1378</span>&#160;<span class="comment">     *             appear in av_read_frame().</span></div><div class="line"><a name="l01379"></a><span class="lineno"> 1379</span>&#160;<span class="comment">     * - muxing: streams are created by the user before avformat_write_header().</span></div><div class="line"><a name="l01380"></a><span class="lineno"> 1380</span>&#160;<span class="comment">     *</span></div><div class="line"><a name="l01381"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a0b748d924898b08b89ff4974afd17285"> 1381</a></span>&#160;<span class="comment">     * Freed by libavformat in avformat_free_context().</span></div><div class="line"><a name="l01382"></a><span class="lineno"> 1382</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01383"></a><span class="lineno"> 1383</span>&#160;    <a class="code" href="structAVStream.html">AVStream</a> **streams;</div><div class="line"><a name="l01384"></a><span class="lineno"> 1384</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01385"></a><span class="lineno"> 1385</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01386"></a><span class="lineno"> 1386</span>&#160;<span class="comment">     * input or output filename</span></div><div class="line"><a name="l01387"></a><span class="lineno"> 1387</span>&#160;<span class="comment">     *</span></div><div class="line"><a name="l01388"></a><span class="lineno"> 1388</span>&#160;<span class="comment">     * - demuxing: set by avformat_open_input()</span></div><div class="line"><a name="l01389"></a><span class="lineno"> 1389</span>&#160;<span class="comment">     * - muxing: may be set by the caller before avformat_write_header()</span></div><div class="line"><a name="l01390"></a><span class="lineno"> 1390</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01391"></a><span class="lineno"> 1391</span>&#160;    <span class="keywordtype">char</span> <a class="code" href="structAVProbeData.html#a0e8504127aff8af25cc9f3c6400b9651">filename</a>[1024];</div><div class="line"><a name="l01392"></a><span class="lineno"> 1392</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01393"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#acfefb6b6cf21e87a0dcbd1a547ba2348"> 1393</a></span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01394"></a><span class="lineno"> 1394</span>&#160;<span class="comment">     * Position of the first frame of the component, in</span></div><div class="line"><a name="l01395"></a><span class="lineno"> 1395</span>&#160;<span class="comment">     * AV_TIME_BASE fractional seconds. NEVER set this value directly:</span></div><div class="line"><a name="l01396"></a><span class="lineno"> 1396</span>&#160;<span class="comment">     * It is deduced from the AVStream values.</span></div><div class="line"><a name="l01397"></a><span class="lineno"> 1397</span>&#160;<span class="comment">     *</span></div><div class="line"><a name="l01398"></a><span class="lineno"> 1398</span>&#160;<span class="comment">     * Demuxing only, set by libavformat.</span></div><div class="line"><a name="l01399"></a><span class="lineno"> 1399</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01400"></a><span class="lineno"> 1400</span>&#160;    int64_t start_time;</div><div class="line"><a name="l01401"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a65a978cf0ca3c0f0da52840d2e97f9ea"> 1401</a></span>&#160;<span class="comment"></span></div><div class="line"><a name="l01402"></a><span class="lineno"> 1402</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01403"></a><span class="lineno"> 1403</span>&#160;<span class="comment">     * Duration of the stream, in AV_TIME_BASE fractional</span></div><div class="line"><a name="l01404"></a><span class="lineno"> 1404</span>&#160;<span class="comment">     * seconds. Only set this value if you know none of the individual stream</span></div><div class="line"><a name="l01405"></a><span class="lineno"> 1405</span>&#160;<span class="comment">     * durations and also do not set any of them. This is deduced from the</span></div><div class="line"><a name="l01406"></a><span class="lineno"> 1406</span>&#160;<span class="comment">     * AVStream values if not set.</span></div><div class="line"><a name="l01407"></a><span class="lineno"> 1407</span>&#160;<span class="comment">     *</span></div><div class="line"><a name="l01408"></a><span class="lineno"> 1408</span>&#160;<span class="comment">     * Demuxing only, set by libavformat.</span></div><div class="line"><a name="l01409"></a><span class="lineno"> 1409</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01410"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a2590129e00adfa726ab2033a10e905e9"> 1410</a></span>&#160;    int64_t duration;</div><div class="line"><a name="l01411"></a><span class="lineno"> 1411</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01412"></a><span class="lineno"> 1412</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01413"></a><span class="lineno"> 1413</span>&#160;<span class="comment">     * Total stream bitrate in bit/s, 0 if not</span></div><div class="line"><a name="l01414"></a><span class="lineno"> 1414</span>&#160;<span class="comment">     * available. Never set it directly if the file_size and the</span></div><div class="line"><a name="l01415"></a><span class="lineno"> 1415</span>&#160;<span class="comment">     * duration are known as FFmpeg can compute it automatically.</span></div><div class="line"><a name="l01416"></a><span class="lineno"> 1416</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01417"></a><span class="lineno"> 1417</span>&#160;    int64_t bit_rate;</div><div class="line"><a name="l01418"></a><span class="lineno"> 1418</span>&#160;</div><div class="line"><a name="l01419"></a><span class="lineno"> 1419</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> packet_size;</div><div class="line"><a name="l01420"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#ad0ea78ac48f5bb0a15a15c1c472744d9"> 1420</a></span>&#160;    <span class="keywordtype">int</span> max_delay;</div><div class="line"><a name="l01421"></a><span class="lineno"> 1421</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01422"></a><span class="lineno"> 1422</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01423"></a><span class="lineno"> 1423</span>&#160;<span class="comment">     * Flags modifying the (de)muxer behaviour. A combination of AVFMT_FLAG_*.</span></div><div class="line"><a name="l01424"></a><span class="lineno"> 1424</span>&#160;<span class="comment">     * Set by the user before avformat_open_input() / avformat_write_header().</span></div><div class="line"><a name="l01425"></a><span class="lineno"> 1425</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01426"></a><span class="lineno"> 1426</span>&#160;    <span class="keywordtype">int</span> <a class="code" href="structAVOutputFormat.html#aad55a00e728a020c1dcfaaf695320445">flags</a>;</div><div class="line"><a name="l01427"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a972a02b9e3b542a426e323a8f8e3ea41"> 1427</a></span>&#160;<span class="preprocessor">#define AVFMT_FLAG_GENPTS       0x0001 </span><span class="comment">///&lt; Generate missing pts even if it requires parsing future frames.</span></div><div class="line"><a name="l01428"></a><span class="lineno"> 1428</span>&#160;<span class="comment"></span>#define AVFMT_FLAG_IGNIDX       0x0002 <span class="comment">///&lt; Ignore index.</span></div><div class="line"><a name="l01429"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a0739c2952969d3c67788f02ea829f549"> 1429</a></span>&#160;<span class="comment"></span>#define AVFMT_FLAG_NONBLOCK     0x0004 <span class="comment">///&lt; Do not block when reading packets from input.</span></div><div class="line"><a name="l01430"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a58422ed3d461b3440a15cf057ac5f5b7"> 1430</a></span>&#160;<span class="comment"></span>#define AVFMT_FLAG_IGNDTS       0x0008 <span class="comment">///&lt; Ignore DTS on frames that contain both DTS &amp; PTS</span></div><div class="line"><a name="l01431"></a><span class="lineno"> 1431</span>&#160;<span class="comment"></span>#define AVFMT_FLAG_NOFILLIN     0x0010 <span class="comment">///&lt; Do not infer any values from other values, just return what is stored in the container</span></div><div class="line"><a name="l01432"></a><span class="lineno"> 1432</span>&#160;<span class="comment"></span>#define AVFMT_FLAG_NOPARSE      0x0020 <span class="comment">///&lt; Do not use AVParsers, you also must set AVFMT_FLAG_NOFILLIN as the fillin code works on frames and no parsing -&gt; no frames. Also seeking to frames can not work if parsing to find frame boundaries has been disabled</span></div><div class="line"><a name="l01433"></a><span class="lineno"> 1433</span>&#160;<span class="comment"></span>#define AVFMT_FLAG_NOBUFFER     0x0040 <span class="comment">///&lt; Do not buffer frames when possible</span></div><div class="line"><a name="l01434"></a><span class="lineno"> 1434</span>&#160;<span class="comment"></span>#define AVFMT_FLAG_CUSTOM_IO    0x0080 <span class="comment">///&lt; The caller has supplied a custom AVIOContext, don&#39;t avio_close() it.</span></div><div class="line"><a name="l01435"></a><span class="lineno"> 1435</span>&#160;<span class="comment"></span>#define AVFMT_FLAG_DISCARD_CORRUPT  0x0100 <span class="comment">///&lt; Discard frames marked corrupted</span></div><div class="line"><a name="l01436"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a32379cc371463b235d54235d4af06a15"> 1436</a></span>&#160;<span class="comment"></span>#define AVFMT_FLAG_FLUSH_PACKETS    0x0200 <span class="comment">///&lt; Flush the AVIOContext every packet.</span></div><div class="line"><a name="l01437"></a><span class="lineno"><a class="line" href="avformat_8h.html#a69e2c8bc119c0245ff6092f9db4d12ae"> 1437</a></span>&#160;<span class="comment"></span><span class="comment">/**</span></div><div class="line"><a name="l01438"></a><span class="lineno"><a class="line" href="avformat_8h.html#a2d5c3fab0686ccb9f517dec49048d421"> 1438</a></span>&#160;<span class="comment"> * When muxing, try to avoid writing any random/volatile data to the output.</span></div><div class="line"><a name="l01439"></a><span class="lineno"><a class="line" href="avformat_8h.html#a4fd189c4f2464afad342133be7bf6aeb"> 1439</a></span>&#160;<span class="comment"> * This includes any random IDs, real-time timestamps/dates, muxer version, etc.</span></div><div class="line"><a name="l01440"></a><span class="lineno"><a class="line" href="avformat_8h.html#a48978eb2565907e8794910a1178897e0"> 1440</a></span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l01441"></a><span class="lineno"><a class="line" href="avformat_8h.html#acafe6c256110801c5bfb79da1d4ec0fa"> 1441</a></span>&#160;<span class="comment"> * This flag is mainly intended for testing.</span></div><div class="line"><a name="l01442"></a><span class="lineno"><a class="line" href="avformat_8h.html#af94b1dbe5f4e7c0ab04dc05ea18c1d81"> 1442</a></span>&#160;<span class="comment"> */</span><span class="preprocessor"></span></div><div class="line"><a name="l01443"></a><span class="lineno"><a class="line" href="avformat_8h.html#aee579ebc55f7067a964fbfd09c14e8c2"> 1443</a></span>&#160;<span class="preprocessor">#define AVFMT_FLAG_BITEXACT         0x0400</span></div><div class="line"><a name="l01444"></a><span class="lineno"><a class="line" href="avformat_8h.html#ac5fdea71141dcc30346a57df75cf408e"> 1444</a></span>&#160;<span class="preprocessor">#define AVFMT_FLAG_MP4A_LATM    0x8000 </span><span class="comment">///&lt; Enable RTP MP4A-LATM payload</span></div><div class="line"><a name="l01445"></a><span class="lineno"><a class="line" href="avformat_8h.html#a936da4a8820e0d9206856620ee451a10"> 1445</a></span>&#160;<span class="comment"></span>#define AVFMT_FLAG_SORT_DTS    0x10000 <span class="comment">///&lt; try to interleave outputted packets by dts (using this flag can slow demuxing down)</span></div><div class="line"><a name="l01446"></a><span class="lineno"><a class="line" href="avformat_8h.html#a1d9ca54477304fc143bc6594c4dec102"> 1446</a></span>&#160;<span class="comment"></span>#define AVFMT_FLAG_PRIV_OPT    0x20000 <span class="comment">///&lt; Enable use of private options by delaying codec open (this could be made default once all code is converted)</span></div><div class="line"><a name="l01447"></a><span class="lineno"> 1447</span>&#160;<span class="comment"></span>#if FF_API_LAVF_KEEPSIDE_FLAG</div><div class="line"><a name="l01448"></a><span class="lineno"> 1448</span>&#160;<span class="preprocessor">#define AVFMT_FLAG_KEEP_SIDE_DATA 0x40000 </span><span class="comment">///&lt; Deprecated, does nothing.</span></div><div class="line"><a name="l01449"></a><span class="lineno"> 1449</span>&#160;<span class="comment"></span>#endif</div><div class="line"><a name="l01450"></a><span class="lineno"> 1450</span>&#160;<span class="preprocessor">#define AVFMT_FLAG_FAST_SEEK   0x80000 </span><span class="comment">///&lt; Enable fast, but inaccurate seeks for some formats</span></div><div class="line"><a name="l01451"></a><span class="lineno"> 1451</span>&#160;<span class="comment"></span>#define AVFMT_FLAG_SHORTEST   0x100000 <span class="comment">///&lt; Stop muxing when the shortest stream stops.</span></div><div class="line"><a name="l01452"></a><span class="lineno"> 1452</span>&#160;<span class="comment"></span>#define AVFMT_FLAG_AUTO_BSF   0x200000 <span class="comment">///&lt; Add bitstream filters as requested by the muxer</span></div><div class="line"><a name="l01453"></a><span class="lineno"><a class="line" href="avformat_8h.html#a2fa1d95841e62af509ba733a11c1b25b"> 1453</a></span>&#160;<span class="comment"></span></div><div class="line"><a name="l01454"></a><span class="lineno"><a class="line" href="avformat_8h.html#a3b150996e2b51660a01398a161c0cd1d"> 1454</a></span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01455"></a><span class="lineno"><a class="line" href="avformat_8h.html#a19d3097af30fbd65caa79464657ce4bd"> 1455</a></span>&#160;<span class="comment">     * Maximum size of the data read from input for determining</span></div><div class="line"><a name="l01456"></a><span class="lineno"><a class="line" href="avformat_8h.html#a50b1ae2089b32bf048b79ff3bd7175f4"> 1456</a></span>&#160;<span class="comment">     * the input container format.</span></div><div class="line"><a name="l01457"></a><span class="lineno"> 1457</span>&#160;<span class="comment">     * Demuxing only, set by the caller before avformat_open_input().</span></div><div class="line"><a name="l01458"></a><span class="lineno"> 1458</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01459"></a><span class="lineno"> 1459</span>&#160;    int64_t probesize;</div><div class="line"><a name="l01460"></a><span class="lineno"><a class="line" href="avformat_8h.html#a68c81e3fd8f1229965ae6dfceb42f5bf"> 1460</a></span>&#160;<span class="comment"></span></div><div class="line"><a name="l01461"></a><span class="lineno"><a class="line" href="avformat_8h.html#a0353bdeb6ae20a2f655a6ab288e95030"> 1461</a></span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01462"></a><span class="lineno"><a class="line" href="avformat_8h.html#aa1683260287285a2a6a91476a5f2ffd5"> 1462</a></span>&#160;<span class="comment">     * Maximum duration (in AV_TIME_BASE units) of the data read</span></div><div class="line"><a name="l01463"></a><span class="lineno"> 1463</span>&#160;<span class="comment">     * from input in avformat_find_stream_info().</span></div><div class="line"><a name="l01464"></a><span class="lineno"> 1464</span>&#160;<span class="comment">     * Demuxing only, set by the caller before avformat_find_stream_info().</span></div><div class="line"><a name="l01465"></a><span class="lineno"> 1465</span>&#160;<span class="comment">     * Can be set to 0 to let avformat choose using a heuristic.</span></div><div class="line"><a name="l01466"></a><span class="lineno"> 1466</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01467"></a><span class="lineno"> 1467</span>&#160;    int64_t max_analyze_duration;</div><div class="line"><a name="l01468"></a><span class="lineno"> 1468</span>&#160;</div><div class="line"><a name="l01469"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#acb47a2a7362ac575b4986e0028786a41"> 1469</a></span>&#160;    <span class="keyword">const</span> uint8_t *key;</div><div class="line"><a name="l01470"></a><span class="lineno"> 1470</span>&#160;    <span class="keywordtype">int</span> keylen;</div><div class="line"><a name="l01471"></a><span class="lineno"> 1471</span>&#160;</div><div class="line"><a name="l01472"></a><span class="lineno"> 1472</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nb_programs;</div><div class="line"><a name="l01473"></a><span class="lineno"> 1473</span>&#160;    <a class="code" href="structAVProgram.html">AVProgram</a> **programs;</div><div class="line"><a name="l01474"></a><span class="lineno"> 1474</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01475"></a><span class="lineno"> 1475</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01476"></a><span class="lineno"> 1476</span>&#160;<span class="comment">     * Forced video codec_id.</span></div><div class="line"><a name="l01477"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a4d860662c014f88277c8f20e238fa694"> 1477</a></span>&#160;<span class="comment">     * Demuxing: Set by user.</span></div><div class="line"><a name="l01478"></a><span class="lineno"> 1478</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01479"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a19cb4471ba011fc7adc5e17344c608f5"> 1479</a></span>&#160;    <span class="keyword">enum</span> <a class="code" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a> video_codec_id;</div><div class="line"><a name="l01480"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a1f2c1db3070cc100938eaed81ff3767d"> 1480</a></span>&#160;<span class="comment"></span></div><div class="line"><a name="l01481"></a><span class="lineno"> 1481</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01482"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a58c8c4d0ea974e0fcb0ce06fb1174f9f"> 1482</a></span>&#160;<span class="comment">     * Forced audio codec_id.</span></div><div class="line"><a name="l01483"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a4c2c5a4c758966349ff513e95154d062"> 1483</a></span>&#160;<span class="comment">     * Demuxing: Set by user.</span></div><div class="line"><a name="l01484"></a><span class="lineno"> 1484</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01485"></a><span class="lineno"> 1485</span>&#160;    <span class="keyword">enum</span> <a class="code" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a> audio_codec_id;</div><div class="line"><a name="l01486"></a><span class="lineno"> 1486</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01487"></a><span class="lineno"> 1487</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01488"></a><span class="lineno"> 1488</span>&#160;<span class="comment">     * Forced subtitle codec_id.</span></div><div class="line"><a name="l01489"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#ab179ade0dbe905ab2867b7001bf618ec"> 1489</a></span>&#160;<span class="comment">     * Demuxing: Set by user.</span></div><div class="line"><a name="l01490"></a><span class="lineno"> 1490</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01491"></a><span class="lineno"> 1491</span>&#160;    <span class="keyword">enum</span> <a class="code" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a> subtitle_codec_id;</div><div class="line"><a name="l01492"></a><span class="lineno"> 1492</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01493"></a><span class="lineno"> 1493</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01494"></a><span class="lineno"> 1494</span>&#160;<span class="comment">     * Maximum amount of memory in bytes to use for the index of each stream.</span></div><div class="line"><a name="l01495"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a1c99fc118bf047959a0284bffc2c1a9a"> 1495</a></span>&#160;<span class="comment">     * If the index exceeds this size, entries will be discarded as</span></div><div class="line"><a name="l01496"></a><span class="lineno"> 1496</span>&#160;<span class="comment">     * needed to maintain a smaller size. This can lead to slower or less</span></div><div class="line"><a name="l01497"></a><span class="lineno"> 1497</span>&#160;<span class="comment">     * accurate seeking (depends on demuxer).</span></div><div class="line"><a name="l01498"></a><span class="lineno"> 1498</span>&#160;<span class="comment">     * Demuxers for which a full in-memory index is mandatory will ignore</span></div><div class="line"><a name="l01499"></a><span class="lineno"> 1499</span>&#160;<span class="comment">     * this.</span></div><div class="line"><a name="l01500"></a><span class="lineno"> 1500</span>&#160;<span class="comment">     * - muxing: unused</span></div><div class="line"><a name="l01501"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#acca61846d663b15e5a56b35c903e4d3b"> 1501</a></span>&#160;<span class="comment">     * - demuxing: set by user</span></div><div class="line"><a name="l01502"></a><span class="lineno"> 1502</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01503"></a><span class="lineno"> 1503</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_index_size;</div><div class="line"><a name="l01504"></a><span class="lineno"> 1504</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01505"></a><span class="lineno"> 1505</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01506"></a><span class="lineno"> 1506</span>&#160;<span class="comment">     * Maximum amount of memory in bytes to use for buffering frames</span></div><div class="line"><a name="l01507"></a><span class="lineno"> 1507</span>&#160;<span class="comment">     * obtained from realtime capture devices.</span></div><div class="line"><a name="l01508"></a><span class="lineno"> 1508</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01509"></a><span class="lineno"> 1509</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_picture_buffer;</div><div class="line"><a name="l01510"></a><span class="lineno"> 1510</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01511"></a><span class="lineno"> 1511</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01512"></a><span class="lineno"> 1512</span>&#160;<span class="comment">     * Number of chapters in AVChapter array.</span></div><div class="line"><a name="l01513"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#ab0470d586a71d4f356194d202591617d"> 1513</a></span>&#160;<span class="comment">     * When muxing, chapters are normally written in the file header,</span></div><div class="line"><a name="l01514"></a><span class="lineno"> 1514</span>&#160;<span class="comment">     * so nb_chapters should normally be initialized before write_header</span></div><div class="line"><a name="l01515"></a><span class="lineno"> 1515</span>&#160;<span class="comment">     * is called. Some muxers (e.g. mov and mkv) can also write chapters</span></div><div class="line"><a name="l01516"></a><span class="lineno"> 1516</span>&#160;<span class="comment">     * in the trailer.  To write chapters in the trailer, nb_chapters</span></div><div class="line"><a name="l01517"></a><span class="lineno"> 1517</span>&#160;<span class="comment">     * must be zero when write_header is called and non-zero when</span></div><div class="line"><a name="l01518"></a><span class="lineno"> 1518</span>&#160;<span class="comment">     * write_trailer is called.</span></div><div class="line"><a name="l01519"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#ae188350a3838a14a233bf272d68998be"> 1519</a></span>&#160;<span class="comment">     * - muxing: set by user</span></div><div class="line"><a name="l01520"></a><span class="lineno"> 1520</span>&#160;<span class="comment">     * - demuxing: set by libavformat</span></div><div class="line"><a name="l01521"></a><span class="lineno"> 1521</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01522"></a><span class="lineno"> 1522</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nb_chapters;</div><div class="line"><a name="l01523"></a><span class="lineno"> 1523</span>&#160;    <a class="code" href="structAVChapter.html">AVChapter</a> **chapters;</div><div class="line"><a name="l01524"></a><span class="lineno"> 1524</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01525"></a><span class="lineno"> 1525</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01526"></a><span class="lineno"> 1526</span>&#160;<span class="comment">     * Metadata that applies to the whole file.</span></div><div class="line"><a name="l01527"></a><span class="lineno"> 1527</span>&#160;<span class="comment">     *</span></div><div class="line"><a name="l01528"></a><span class="lineno"> 1528</span>&#160;<span class="comment">     * - demuxing: set by libavformat in avformat_open_input()</span></div><div class="line"><a name="l01529"></a><span class="lineno"> 1529</span>&#160;<span class="comment">     * - muxing: may be set by the caller before avformat_write_header()</span></div><div class="line"><a name="l01530"></a><span class="lineno"> 1530</span>&#160;<span class="comment">     *</span></div><div class="line"><a name="l01531"></a><span class="lineno"> 1531</span>&#160;<span class="comment">     * Freed by libavformat in avformat_free_context().</span></div><div class="line"><a name="l01532"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a6f60043baf4abd0d201ccefc27bb4306"> 1532</a></span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01533"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#ac17d5fc2dcdb00806cc83b02d9f940f3"> 1533</a></span>&#160;    <a class="code" href="group__lavu__dict.html#ga1d7cc0833bee918994a600556410315f">AVDictionary</a> *metadata;</div><div class="line"><a name="l01534"></a><span class="lineno"> 1534</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01535"></a><span class="lineno"> 1535</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01536"></a><span class="lineno"> 1536</span>&#160;<span class="comment">     * Start time of the stream in real world time, in microseconds</span></div><div class="line"><a name="l01537"></a><span class="lineno"> 1537</span>&#160;<span class="comment">     * since the Unix epoch (00:00 1st January 1970). That is, pts=0 in the</span></div><div class="line"><a name="l01538"></a><span class="lineno"> 1538</span>&#160;<span class="comment">     * stream was captured at this real world time.</span></div><div class="line"><a name="l01539"></a><span class="lineno"> 1539</span>&#160;<span class="comment">     * - muxing: Set by the caller before avformat_write_header(). If set to</span></div><div class="line"><a name="l01540"></a><span class="lineno"> 1540</span>&#160;<span class="comment">     *           either 0 or AV_NOPTS_VALUE, then the current wall-time will</span></div><div class="line"><a name="l01541"></a><span class="lineno"> 1541</span>&#160;<span class="comment">     *           be used.</span></div><div class="line"><a name="l01542"></a><span class="lineno"> 1542</span>&#160;<span class="comment">     * - demuxing: Set by libavformat. AV_NOPTS_VALUE if unknown. Note that</span></div><div class="line"><a name="l01543"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a3019a56080ed2e3297ff25bc2ff88adf"> 1543</a></span>&#160;<span class="comment">     *             the value may become known after some number of frames</span></div><div class="line"><a name="l01544"></a><span class="lineno"> 1544</span>&#160;<span class="comment">     *             have been received.</span></div><div class="line"><a name="l01545"></a><span class="lineno"> 1545</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01546"></a><span class="lineno"> 1546</span>&#160;    int64_t start_time_realtime;</div><div class="line"><a name="l01547"></a><span class="lineno"> 1547</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01548"></a><span class="lineno"> 1548</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01549"></a><span class="lineno"> 1549</span>&#160;<span class="comment">     * The number of frames used for determining the framerate in</span></div><div class="line"><a name="l01550"></a><span class="lineno"> 1550</span>&#160;<span class="comment">     * avformat_find_stream_info().</span></div><div class="line"><a name="l01551"></a><span class="lineno"> 1551</span>&#160;<span class="comment">     * Demuxing only, set by the caller before avformat_find_stream_info().</span></div><div class="line"><a name="l01552"></a><span class="lineno"> 1552</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01553"></a><span class="lineno"> 1553</span>&#160;    <span class="keywordtype">int</span> fps_probe_size;</div><div class="line"><a name="l01554"></a><span class="lineno"> 1554</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01555"></a><span class="lineno"> 1555</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01556"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#aa5ddb5cee1df28f21739133f2e37f1c5"> 1556</a></span>&#160;<span class="comment">     * Error recognition; higher values will detect more errors but may</span></div><div class="line"><a name="l01557"></a><span class="lineno"> 1557</span>&#160;<span class="comment">     * misdetect some more or less valid parts as errors.</span></div><div class="line"><a name="l01558"></a><span class="lineno"> 1558</span>&#160;<span class="comment">     * Demuxing only, set by the caller before avformat_open_input().</span></div><div class="line"><a name="l01559"></a><span class="lineno"> 1559</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01560"></a><span class="lineno"> 1560</span>&#160;    <span class="keywordtype">int</span> error_recognition;</div><div class="line"><a name="l01561"></a><span class="lineno"> 1561</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01562"></a><span class="lineno"> 1562</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01563"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a517e6b5dcada506a49ef413d4d8d477a"> 1563</a></span>&#160;<span class="comment">     * Custom interrupt callbacks for the I/O layer.</span></div><div class="line"><a name="l01564"></a><span class="lineno"> 1564</span>&#160;<span class="comment">     *</span></div><div class="line"><a name="l01565"></a><span class="lineno"> 1565</span>&#160;<span class="comment">     * demuxing: set by the user before avformat_open_input().</span></div><div class="line"><a name="l01566"></a><span class="lineno"> 1566</span>&#160;<span class="comment">     * muxing: set by the user before avformat_write_header()</span></div><div class="line"><a name="l01567"></a><span class="lineno"> 1567</span>&#160;<span class="comment">     * (mainly useful for AVFMT_NOFILE formats). The callback</span></div><div class="line"><a name="l01568"></a><span class="lineno"> 1568</span>&#160;<span class="comment">     * should also be passed to avio_open2() if it&#39;s used to</span></div><div class="line"><a name="l01569"></a><span class="lineno"> 1569</span>&#160;<span class="comment">     * open the file.</span></div><div class="line"><a name="l01570"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#aeebb15a72d1503e641b633aeb3be0bf0"> 1570</a></span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01571"></a><span class="lineno"> 1571</span>&#160;    <a class="code" href="structAVIOInterruptCB.html">AVIOInterruptCB</a> interrupt_callback;</div><div class="line"><a name="l01572"></a><span class="lineno"> 1572</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01573"></a><span class="lineno"> 1573</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01574"></a><span class="lineno"> 1574</span>&#160;<span class="comment">     * Flags to enable debugging.</span></div><div class="line"><a name="l01575"></a><span class="lineno"> 1575</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01576"></a><span class="lineno"> 1576</span>&#160;    <span class="keywordtype">int</span> debug;</div><div class="line"><a name="l01577"></a><span class="lineno"> 1577</span>&#160;<span class="preprocessor">#define FF_FDEBUG_TS        0x0001</span></div><div class="line"><a name="l01578"></a><span class="lineno"> 1578</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01579"></a><span class="lineno"> 1579</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01580"></a><span class="lineno"> 1580</span>&#160;<span class="comment">     * Maximum buffering duration for interleaving.</span></div><div class="line"><a name="l01581"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a5b37acfe4024d92ee510064e80920b40"> 1581</a></span>&#160;<span class="comment">     *</span></div><div class="line"><a name="l01582"></a><span class="lineno"> 1582</span>&#160;<span class="comment">     * To ensure all the streams are interleaved correctly,</span></div><div class="line"><a name="l01583"></a><span class="lineno"> 1583</span>&#160;<span class="comment">     * av_interleaved_write_frame() will wait until it has at least one packet</span></div><div class="line"><a name="l01584"></a><span class="lineno"> 1584</span>&#160;<span class="comment">     * for each stream before actually writing any packets to the output file.</span></div><div class="line"><a name="l01585"></a><span class="lineno"> 1585</span>&#160;<span class="comment">     * When some streams are &quot;sparse&quot; (i.e. there are large gaps between</span></div><div class="line"><a name="l01586"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#ab4478e9742f661800cf7e0af84136cae"> 1586</a></span>&#160;<span class="comment">     * successive packets), this can result in excessive buffering.</span></div><div class="line"><a name="l01587"></a><span class="lineno"><a class="line" href="avformat_8h.html#a3d60713d578ad1ef6505e05779c112cf"> 1587</a></span>&#160;<span class="comment">     *</span></div><div class="line"><a name="l01588"></a><span class="lineno"> 1588</span>&#160;<span class="comment">     * This field specifies the maximum difference between the timestamps of the</span></div><div class="line"><a name="l01589"></a><span class="lineno"> 1589</span>&#160;<span class="comment">     * first and the last packet in the muxing queue, above which libavformat</span></div><div class="line"><a name="l01590"></a><span class="lineno"> 1590</span>&#160;<span class="comment">     * will output a packet regardless of whether it has queued a packet for all</span></div><div class="line"><a name="l01591"></a><span class="lineno"> 1591</span>&#160;<span class="comment">     * the streams.</span></div><div class="line"><a name="l01592"></a><span class="lineno"> 1592</span>&#160;<span class="comment">     *</span></div><div class="line"><a name="l01593"></a><span class="lineno"> 1593</span>&#160;<span class="comment">     * Muxing only, set by the caller before avformat_write_header().</span></div><div class="line"><a name="l01594"></a><span class="lineno"> 1594</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01595"></a><span class="lineno"> 1595</span>&#160;    int64_t max_interleave_delta;</div><div class="line"><a name="l01596"></a><span class="lineno"> 1596</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01597"></a><span class="lineno"> 1597</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01598"></a><span class="lineno"> 1598</span>&#160;<span class="comment">     * Allow non-standard and experimental extension</span></div><div class="line"><a name="l01599"></a><span class="lineno"> 1599</span>&#160;<span class="comment">     * @see AVCodecContext.strict_std_compliance</span></div><div class="line"><a name="l01600"></a><span class="lineno"> 1600</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01601"></a><span class="lineno"> 1601</span>&#160;    <span class="keywordtype">int</span> strict_std_compliance;</div><div class="line"><a name="l01602"></a><span class="lineno"> 1602</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01603"></a><span class="lineno"> 1603</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01604"></a><span class="lineno"> 1604</span>&#160;<span class="comment">     * Flags for the user to detect events happening on the file. Flags must</span></div><div class="line"><a name="l01605"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a00edb6b7a31f8dabfa668334ca1f92d7"> 1605</a></span>&#160;<span class="comment">     * be cleared by the user once the event has been handled.</span></div><div class="line"><a name="l01606"></a><span class="lineno"> 1606</span>&#160;<span class="comment">     * A combination of AVFMT_EVENT_FLAG_*.</span></div><div class="line"><a name="l01607"></a><span class="lineno"> 1607</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01608"></a><span class="lineno"> 1608</span>&#160;    <span class="keywordtype">int</span> event_flags;</div><div class="line"><a name="l01609"></a><span class="lineno"> 1609</span>&#160;<span class="preprocessor">#define AVFMT_EVENT_FLAG_METADATA_UPDATED 0x0001 </span><span class="comment">///&lt; The call resulted in updated metadata.</span></div><div class="line"><a name="l01610"></a><span class="lineno"> 1610</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01611"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a5017684cf0a84c990f60c8d50adec144"> 1611</a></span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01612"></a><span class="lineno"> 1612</span>&#160;<span class="comment">     * Maximum number of packets to read while waiting for the first timestamp.</span></div><div class="line"><a name="l01613"></a><span class="lineno"> 1613</span>&#160;<span class="comment">     * Decoding only.</span></div><div class="line"><a name="l01614"></a><span class="lineno"> 1614</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01615"></a><span class="lineno"> 1615</span>&#160;    <span class="keywordtype">int</span> max_ts_probe;</div><div class="line"><a name="l01616"></a><span class="lineno"> 1616</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01617"></a><span class="lineno"> 1617</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01618"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a0302506d4b3434da77b8b3db43821aa0"> 1618</a></span>&#160;<span class="comment">     * Avoid negative timestamps during muxing.</span></div><div class="line"><a name="l01619"></a><span class="lineno"><a class="line" href="avformat_8h.html#a19485b8b52e579db560875e9a1e44e7a"> 1619</a></span>&#160;<span class="comment">     * Any value of the AVFMT_AVOID_NEG_TS_* constants.</span></div><div class="line"><a name="l01620"></a><span class="lineno"> 1620</span>&#160;<span class="comment">     * Note, this only works when using av_interleaved_write_frame. (interleave_packet_per_dts is in use)</span></div><div class="line"><a name="l01621"></a><span class="lineno"> 1621</span>&#160;<span class="comment">     * - muxing: Set by user</span></div><div class="line"><a name="l01622"></a><span class="lineno"> 1622</span>&#160;<span class="comment">     * - demuxing: unused</span></div><div class="line"><a name="l01623"></a><span class="lineno"> 1623</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01624"></a><span class="lineno"> 1624</span>&#160;    <span class="keywordtype">int</span> avoid_negative_ts;</div><div class="line"><a name="l01625"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#ad7854e5186dd14ce91dea1dfd0bb826f"> 1625</a></span>&#160;<span class="preprocessor">#define AVFMT_AVOID_NEG_TS_AUTO             -1 </span><span class="comment">///&lt; Enabled when required by target format</span></div><div class="line"><a name="l01626"></a><span class="lineno"> 1626</span>&#160;<span class="comment"></span>#define AVFMT_AVOID_NEG_TS_MAKE_NON_NEGATIVE 1 <span class="comment">///&lt; Shift timestamps so they are non negative</span></div><div class="line"><a name="l01627"></a><span class="lineno"> 1627</span>&#160;<span class="comment"></span>#define AVFMT_AVOID_NEG_TS_MAKE_ZERO         2 <span class="comment">///&lt; Shift timestamps so that they start at 0</span></div><div class="line"><a name="l01628"></a><span class="lineno"> 1628</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01629"></a><span class="lineno"> 1629</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01630"></a><span class="lineno"> 1630</span>&#160;<span class="comment">     * Transport stream id.</span></div><div class="line"><a name="l01631"></a><span class="lineno"> 1631</span>&#160;<span class="comment">     * This will be moved into demuxer private options. Thus no API/ABI compatibility</span></div><div class="line"><a name="l01632"></a><span class="lineno"> 1632</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01633"></a><span class="lineno"> 1633</span>&#160;    <span class="keywordtype">int</span> ts_id;</div><div class="line"><a name="l01634"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a032c7d859883eddc9d87a9e3b2cc3853"> 1634</a></span>&#160;<span class="comment"></span></div><div class="line"><a name="l01635"></a><span class="lineno"><a class="line" href="avformat_8h.html#a8de664fdbd6e2a5bd327f75b185a97ef"> 1635</a></span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01636"></a><span class="lineno"><a class="line" href="avformat_8h.html#ab82d3e1a4a5bba30941fcc4402317831"> 1636</a></span>&#160;<span class="comment">     * Audio preload in microseconds.</span></div><div class="line"><a name="l01637"></a><span class="lineno"><a class="line" href="avformat_8h.html#aeb387b52a67154ded3aeee38400f358a"> 1637</a></span>&#160;<span class="comment">     * Note, not all formats support this and unpredictable things may happen if it is used when not supported.</span></div><div class="line"><a name="l01638"></a><span class="lineno"> 1638</span>&#160;<span class="comment">     * - encoding: Set by user</span></div><div class="line"><a name="l01639"></a><span class="lineno"> 1639</span>&#160;<span class="comment">     * - decoding: unused</span></div><div class="line"><a name="l01640"></a><span class="lineno"> 1640</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01641"></a><span class="lineno"> 1641</span>&#160;    <span class="keywordtype">int</span> audio_preload;</div><div class="line"><a name="l01642"></a><span class="lineno"> 1642</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01643"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a5d331e9a0609a93dd4593af6c118cc4b"> 1643</a></span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01644"></a><span class="lineno"> 1644</span>&#160;<span class="comment">     * Max chunk time in microseconds.</span></div><div class="line"><a name="l01645"></a><span class="lineno"> 1645</span>&#160;<span class="comment">     * Note, not all formats support this and unpredictable things may happen if it is used when not supported.</span></div><div class="line"><a name="l01646"></a><span class="lineno"> 1646</span>&#160;<span class="comment">     * - encoding: Set by user</span></div><div class="line"><a name="l01647"></a><span class="lineno"> 1647</span>&#160;<span class="comment">     * - decoding: unused</span></div><div class="line"><a name="l01648"></a><span class="lineno"> 1648</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01649"></a><span class="lineno"> 1649</span>&#160;    <span class="keywordtype">int</span> max_chunk_duration;</div><div class="line"><a name="l01650"></a><span class="lineno"> 1650</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01651"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#ac02383c2106cca8022f8a293399aed58"> 1651</a></span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01652"></a><span class="lineno"> 1652</span>&#160;<span class="comment">     * Max chunk size in bytes</span></div><div class="line"><a name="l01653"></a><span class="lineno"> 1653</span>&#160;<span class="comment">     * Note, not all formats support this and unpredictable things may happen if it is used when not supported.</span></div><div class="line"><a name="l01654"></a><span class="lineno"> 1654</span>&#160;<span class="comment">     * - encoding: Set by user</span></div><div class="line"><a name="l01655"></a><span class="lineno"> 1655</span>&#160;<span class="comment">     * - decoding: unused</span></div><div class="line"><a name="l01656"></a><span class="lineno"> 1656</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01657"></a><span class="lineno"> 1657</span>&#160;    <span class="keywordtype">int</span> max_chunk_size;</div><div class="line"><a name="l01658"></a><span class="lineno"> 1658</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01659"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#ae20c589e20f22f74f1687702de6d2e8e"> 1659</a></span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01660"></a><span class="lineno"> 1660</span>&#160;<span class="comment">     * forces the use of wallclock timestamps as pts/dts of packets</span></div><div class="line"><a name="l01661"></a><span class="lineno"> 1661</span>&#160;<span class="comment">     * This has undefined results in the presence of B frames.</span></div><div class="line"><a name="l01662"></a><span class="lineno"> 1662</span>&#160;<span class="comment">     * - encoding: unused</span></div><div class="line"><a name="l01663"></a><span class="lineno"> 1663</span>&#160;<span class="comment">     * - decoding: Set by user</span></div><div class="line"><a name="l01664"></a><span class="lineno"> 1664</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01665"></a><span class="lineno"> 1665</span>&#160;    <span class="keywordtype">int</span> use_wallclock_as_timestamps;</div><div class="line"><a name="l01666"></a><span class="lineno"> 1666</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01667"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a3d8cfff712c81d1cbc725b40ce02f7e7"> 1667</a></span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01668"></a><span class="lineno"> 1668</span>&#160;<span class="comment">     * avio flags, used to force AVIO_FLAG_DIRECT.</span></div><div class="line"><a name="l01669"></a><span class="lineno"> 1669</span>&#160;<span class="comment">     * - encoding: unused</span></div><div class="line"><a name="l01670"></a><span class="lineno"> 1670</span>&#160;<span class="comment">     * - decoding: Set by user</span></div><div class="line"><a name="l01671"></a><span class="lineno"> 1671</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01672"></a><span class="lineno"> 1672</span>&#160;    <span class="keywordtype">int</span> avio_flags;</div><div class="line"><a name="l01673"></a><span class="lineno"> 1673</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01674"></a><span class="lineno"> 1674</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01675"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a90251622aa2b78badbb846274aff4633"> 1675</a></span>&#160;<span class="comment">     * The duration field can be estimated through various ways, and this field can be used</span></div><div class="line"><a name="l01676"></a><span class="lineno"> 1676</span>&#160;<span class="comment">     * to know how the duration was estimated.</span></div><div class="line"><a name="l01677"></a><span class="lineno"> 1677</span>&#160;<span class="comment">     * - encoding: unused</span></div><div class="line"><a name="l01678"></a><span class="lineno"> 1678</span>&#160;<span class="comment">     * - decoding: Read by user</span></div><div class="line"><a name="l01679"></a><span class="lineno"> 1679</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01680"></a><span class="lineno"> 1680</span>&#160;    <span class="keyword">enum</span> <a class="code" href="avformat_8h.html#a7c2692ffa20d3e888e40e79eeda6d73b">AVDurationEstimationMethod</a> duration_estimation_method;</div><div class="line"><a name="l01681"></a><span class="lineno"> 1681</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01682"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a5e6814c9de3c272396f07e2ff18c7b27"> 1682</a></span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01683"></a><span class="lineno"> 1683</span>&#160;<span class="comment">     * Skip initial bytes when opening stream</span></div><div class="line"><a name="l01684"></a><span class="lineno"> 1684</span>&#160;<span class="comment">     * - encoding: unused</span></div><div class="line"><a name="l01685"></a><span class="lineno"> 1685</span>&#160;<span class="comment">     * - decoding: Set by user</span></div><div class="line"><a name="l01686"></a><span class="lineno"> 1686</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01687"></a><span class="lineno"> 1687</span>&#160;    int64_t skip_initial_bytes;</div><div class="line"><a name="l01688"></a><span class="lineno"> 1688</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01689"></a><span class="lineno"> 1689</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01690"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a95035552afae17c1b7cd701ad72e67b5"> 1690</a></span>&#160;<span class="comment">     * Correct single timestamp overflows</span></div><div class="line"><a name="l01691"></a><span class="lineno"> 1691</span>&#160;<span class="comment">     * - encoding: unused</span></div><div class="line"><a name="l01692"></a><span class="lineno"> 1692</span>&#160;<span class="comment">     * - decoding: Set by user</span></div><div class="line"><a name="l01693"></a><span class="lineno"> 1693</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01694"></a><span class="lineno"> 1694</span>&#160;    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> correct_ts_overflow;</div><div class="line"><a name="l01695"></a><span class="lineno"> 1695</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01696"></a><span class="lineno"> 1696</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01697"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#ad9042cdda3a644e4ef46bfeffa34e4f3"> 1697</a></span>&#160;<span class="comment">     * Force seeking to any (also non key) frames.</span></div><div class="line"><a name="l01698"></a><span class="lineno"> 1698</span>&#160;<span class="comment">     * - encoding: unused</span></div><div class="line"><a name="l01699"></a><span class="lineno"> 1699</span>&#160;<span class="comment">     * - decoding: Set by user</span></div><div class="line"><a name="l01700"></a><span class="lineno"> 1700</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01701"></a><span class="lineno"> 1701</span>&#160;    <span class="keywordtype">int</span> seek2any;</div><div class="line"><a name="l01702"></a><span class="lineno"> 1702</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01703"></a><span class="lineno"> 1703</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01704"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#afe4c7f02033d4b58b3636b9e42db25de"> 1704</a></span>&#160;<span class="comment">     * Flush the I/O context after each packet.</span></div><div class="line"><a name="l01705"></a><span class="lineno"> 1705</span>&#160;<span class="comment">     * - encoding: Set by user</span></div><div class="line"><a name="l01706"></a><span class="lineno"> 1706</span>&#160;<span class="comment">     * - decoding: unused</span></div><div class="line"><a name="l01707"></a><span class="lineno"> 1707</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01708"></a><span class="lineno"> 1708</span>&#160;    <span class="keywordtype">int</span> flush_packets;</div><div class="line"><a name="l01709"></a><span class="lineno"> 1709</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01710"></a><span class="lineno"> 1710</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01711"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a41a1f108aa38e851f65ff4f0a70ce5a5"> 1711</a></span>&#160;<span class="comment">     * format probing score.</span></div><div class="line"><a name="l01712"></a><span class="lineno"> 1712</span>&#160;<span class="comment">     * The maximal score is AVPROBE_SCORE_MAX, its set when the demuxer probes</span></div><div class="line"><a name="l01713"></a><span class="lineno"> 1713</span>&#160;<span class="comment">     * the format.</span></div><div class="line"><a name="l01714"></a><span class="lineno"> 1714</span>&#160;<span class="comment">     * - encoding: unused</span></div><div class="line"><a name="l01715"></a><span class="lineno"> 1715</span>&#160;<span class="comment">     * - decoding: set by avformat, read by user</span></div><div class="line"><a name="l01716"></a><span class="lineno"> 1716</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01717"></a><span class="lineno"> 1717</span>&#160;    <span class="keywordtype">int</span> probe_score;</div><div class="line"><a name="l01718"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a1fdd77fff4c7df1e30ce1d42e10922e9"> 1718</a></span>&#160;<span class="comment"></span></div><div class="line"><a name="l01719"></a><span class="lineno"> 1719</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01720"></a><span class="lineno"> 1720</span>&#160;<span class="comment">     * number of bytes to read maximally to identify format.</span></div><div class="line"><a name="l01721"></a><span class="lineno"> 1721</span>&#160;<span class="comment">     * - encoding: unused</span></div><div class="line"><a name="l01722"></a><span class="lineno"> 1722</span>&#160;<span class="comment">     * - decoding: set by user</span></div><div class="line"><a name="l01723"></a><span class="lineno"> 1723</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01724"></a><span class="lineno"> 1724</span>&#160;    <span class="keywordtype">int</span> format_probesize;</div><div class="line"><a name="l01725"></a><span class="lineno"> 1725</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01726"></a><span class="lineno"> 1726</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01727"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a65f11f94f40f83866ebe651c8ae111cf"> 1727</a></span>&#160;<span class="comment">     * &#39;,&#39; separated list of allowed decoders.</span></div><div class="line"><a name="l01728"></a><span class="lineno"> 1728</span>&#160;<span class="comment">     * If NULL then all are allowed</span></div><div class="line"><a name="l01729"></a><span class="lineno"> 1729</span>&#160;<span class="comment">     * - encoding: unused</span></div><div class="line"><a name="l01730"></a><span class="lineno"> 1730</span>&#160;<span class="comment">     * - decoding: set by user</span></div><div class="line"><a name="l01731"></a><span class="lineno"> 1731</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01732"></a><span class="lineno"> 1732</span>&#160;    <span class="keywordtype">char</span> *codec_whitelist;</div><div class="line"><a name="l01733"></a><span class="lineno"> 1733</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01734"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a7d1f665ecabe03e3d18accbb1ebb32b1"> 1734</a></span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01735"></a><span class="lineno"> 1735</span>&#160;<span class="comment">     * &#39;,&#39; separated list of allowed demuxers.</span></div><div class="line"><a name="l01736"></a><span class="lineno"> 1736</span>&#160;<span class="comment">     * If NULL then all are allowed</span></div><div class="line"><a name="l01737"></a><span class="lineno"> 1737</span>&#160;<span class="comment">     * - encoding: unused</span></div><div class="line"><a name="l01738"></a><span class="lineno"> 1738</span>&#160;<span class="comment">     * - decoding: set by user</span></div><div class="line"><a name="l01739"></a><span class="lineno"> 1739</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01740"></a><span class="lineno"> 1740</span>&#160;    <span class="keywordtype">char</span> *format_whitelist;</div><div class="line"><a name="l01741"></a><span class="lineno"> 1741</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01742"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#aa3b43e2a040a3ce658620711a8345234"> 1742</a></span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01743"></a><span class="lineno"> 1743</span>&#160;<span class="comment">     * An opaque field for libavformat internal usage.</span></div><div class="line"><a name="l01744"></a><span class="lineno"> 1744</span>&#160;<span class="comment">     * Must not be accessed in any way by callers.</span></div><div class="line"><a name="l01745"></a><span class="lineno"> 1745</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01746"></a><span class="lineno"> 1746</span>&#160;    <a class="code" href="avformat_8h.html#a7bec8d592652431045d81a02fef74f28">AVFormatInternal</a> *<span class="keyword">internal</span>;</div><div class="line"><a name="l01747"></a><span class="lineno"> 1747</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01748"></a><span class="lineno"> 1748</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01749"></a><span class="lineno"> 1749</span>&#160;<span class="comment">     * IO repositioned flag.</span></div><div class="line"><a name="l01750"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#abcaa5a7c53d4b0224a5fc2d23e88ea03"> 1750</a></span>&#160;<span class="comment">     * This is set by avformat when the underlaying IO context read pointer</span></div><div class="line"><a name="l01751"></a><span class="lineno"> 1751</span>&#160;<span class="comment">     * is repositioned, for example when doing byte based seeking.</span></div><div class="line"><a name="l01752"></a><span class="lineno"> 1752</span>&#160;<span class="comment">     * Demuxers can use the flag to detect such changes.</span></div><div class="line"><a name="l01753"></a><span class="lineno"> 1753</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01754"></a><span class="lineno"> 1754</span>&#160;    <span class="keywordtype">int</span> io_repositioned;</div><div class="line"><a name="l01755"></a><span class="lineno"> 1755</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01756"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a8a8bec51da36db65ff864f88a85805d9"> 1756</a></span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01757"></a><span class="lineno"> 1757</span>&#160;<span class="comment">     * Forced video codec.</span></div><div class="line"><a name="l01758"></a><span class="lineno"> 1758</span>&#160;<span class="comment">     * This allows forcing a specific decoder, even when there are multiple with</span></div><div class="line"><a name="l01759"></a><span class="lineno"> 1759</span>&#160;<span class="comment">     * the same codec_id.</span></div><div class="line"><a name="l01760"></a><span class="lineno"> 1760</span>&#160;<span class="comment">     * Demuxing: Set by user</span></div><div class="line"><a name="l01761"></a><span class="lineno"> 1761</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01762"></a><span class="lineno"> 1762</span>&#160;    <a class="code" href="structAVCodec.html">AVCodec</a> *<a class="code" href="structAVOutputFormat.html#a1354a9c8542b1b698157218336bd4754">video_codec</a>;</div><div class="line"><a name="l01763"></a><span class="lineno"> 1763</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01764"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a45afe89c377463a1b9446ac94b3c513b"> 1764</a></span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01765"></a><span class="lineno"> 1765</span>&#160;<span class="comment">     * Forced audio codec.</span></div><div class="line"><a name="l01766"></a><span class="lineno"> 1766</span>&#160;<span class="comment">     * This allows forcing a specific decoder, even when there are multiple with</span></div><div class="line"><a name="l01767"></a><span class="lineno"> 1767</span>&#160;<span class="comment">     * the same codec_id.</span></div><div class="line"><a name="l01768"></a><span class="lineno"> 1768</span>&#160;<span class="comment">     * Demuxing: Set by user</span></div><div class="line"><a name="l01769"></a><span class="lineno"> 1769</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01770"></a><span class="lineno"> 1770</span>&#160;    <a class="code" href="structAVCodec.html">AVCodec</a> *<a class="code" href="structAVOutputFormat.html#a2e4fff0aa061984d586ea08ecad96141">audio_codec</a>;</div><div class="line"><a name="l01771"></a><span class="lineno"> 1771</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01772"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a1891d82f7f853a16ebcba7cae939c4f0"> 1772</a></span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01773"></a><span class="lineno"> 1773</span>&#160;<span class="comment">     * Forced subtitle codec.</span></div><div class="line"><a name="l01774"></a><span class="lineno"> 1774</span>&#160;<span class="comment">     * This allows forcing a specific decoder, even when there are multiple with</span></div><div class="line"><a name="l01775"></a><span class="lineno"> 1775</span>&#160;<span class="comment">     * the same codec_id.</span></div><div class="line"><a name="l01776"></a><span class="lineno"> 1776</span>&#160;<span class="comment">     * Demuxing: Set by user</span></div><div class="line"><a name="l01777"></a><span class="lineno"> 1777</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01778"></a><span class="lineno"> 1778</span>&#160;    <a class="code" href="structAVCodec.html">AVCodec</a> *<a class="code" href="structAVOutputFormat.html#adc8b4d7a5f6610e1816dd522e362217c">subtitle_codec</a>;</div><div class="line"><a name="l01779"></a><span class="lineno"> 1779</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01780"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#ab73f76ceac8ed711c56decc2d64456f0"> 1780</a></span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01781"></a><span class="lineno"> 1781</span>&#160;<span class="comment">     * Forced data codec.</span></div><div class="line"><a name="l01782"></a><span class="lineno"> 1782</span>&#160;<span class="comment">     * This allows forcing a specific decoder, even when there are multiple with</span></div><div class="line"><a name="l01783"></a><span class="lineno"> 1783</span>&#160;<span class="comment">     * the same codec_id.</span></div><div class="line"><a name="l01784"></a><span class="lineno"> 1784</span>&#160;<span class="comment">     * Demuxing: Set by user</span></div><div class="line"><a name="l01785"></a><span class="lineno"> 1785</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01786"></a><span class="lineno"> 1786</span>&#160;    <a class="code" href="structAVCodec.html">AVCodec</a> *<a class="code" href="structAVOutputFormat.html#ac4c06882481a62fd0de7396909b02796">data_codec</a>;</div><div class="line"><a name="l01787"></a><span class="lineno"> 1787</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01788"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a9cc6a317755fa4f65b0bab36bcb18c87"> 1788</a></span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01789"></a><span class="lineno"> 1789</span>&#160;<span class="comment">     * Number of bytes to be written as padding in a metadata header.</span></div><div class="line"><a name="l01790"></a><span class="lineno"> 1790</span>&#160;<span class="comment">     * Demuxing: Unused.</span></div><div class="line"><a name="l01791"></a><span class="lineno"> 1791</span>&#160;<span class="comment">     * Muxing: Set by user via av_format_set_metadata_header_padding.</span></div><div class="line"><a name="l01792"></a><span class="lineno"> 1792</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01793"></a><span class="lineno"> 1793</span>&#160;    <span class="keywordtype">int</span> metadata_header_padding;</div><div class="line"><a name="l01794"></a><span class="lineno"> 1794</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01795"></a><span class="lineno"> 1795</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01796"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a6f39359931d266a5cd68223ca68dd3a1"> 1796</a></span>&#160;<span class="comment">     * User data.</span></div><div class="line"><a name="l01797"></a><span class="lineno"> 1797</span>&#160;<span class="comment">     * This is a place for some private data of the user.</span></div><div class="line"><a name="l01798"></a><span class="lineno"> 1798</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01799"></a><span class="lineno"> 1799</span>&#160;    <span class="keywordtype">void</span> *opaque;</div><div class="line"><a name="l01800"></a><span class="lineno"> 1800</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01801"></a><span class="lineno"> 1801</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01802"></a><span class="lineno"> 1802</span>&#160;<span class="comment">     * Callback used by devices to communicate with application.</span></div><div class="line"><a name="l01803"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a6fc5a51cf62b6e8ad379c1ac57d4a0c4"> 1803</a></span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01804"></a><span class="lineno"> 1804</span>&#160;    <a class="code" href="avformat_8h.html#a80856b99bcf4373936fb4fba028b11ca">av_format_control_message</a> control_message_cb;</div><div class="line"><a name="l01805"></a><span class="lineno"> 1805</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01806"></a><span class="lineno"> 1806</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01807"></a><span class="lineno"> 1807</span>&#160;<span class="comment">     * Output timestamp offset, in microseconds.</span></div><div class="line"><a name="l01808"></a><span class="lineno"> 1808</span>&#160;<span class="comment">     * Muxing: set by user</span></div><div class="line"><a name="l01809"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a71797838db59ca0682dd2d18b149134e"> 1809</a></span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01810"></a><span class="lineno"> 1810</span>&#160;    int64_t output_ts_offset;</div><div class="line"><a name="l01811"></a><span class="lineno"> 1811</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01812"></a><span class="lineno"> 1812</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01813"></a><span class="lineno"> 1813</span>&#160;<span class="comment">     * dump format separator.</span></div><div class="line"><a name="l01814"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#ab569e23a4966ca1f708fb498dd6b3d5f"> 1814</a></span>&#160;<span class="comment">     * can be &quot;, &quot; or &quot;\n      &quot; or anything else</span></div><div class="line"><a name="l01815"></a><span class="lineno"> 1815</span>&#160;<span class="comment">     * - muxing: Set by user.</span></div><div class="line"><a name="l01816"></a><span class="lineno"> 1816</span>&#160;<span class="comment">     * - demuxing: Set by user.</span></div><div class="line"><a name="l01817"></a><span class="lineno"> 1817</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01818"></a><span class="lineno"> 1818</span>&#160;    uint8_t *dump_separator;</div><div class="line"><a name="l01819"></a><span class="lineno"> 1819</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01820"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a711dc3e6159c44dc31843f915b893a12"> 1820</a></span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01821"></a><span class="lineno"> 1821</span>&#160;<span class="comment">     * Forced Data codec_id.</span></div><div class="line"><a name="l01822"></a><span class="lineno"> 1822</span>&#160;<span class="comment">     * Demuxing: Set by user.</span></div><div class="line"><a name="l01823"></a><span class="lineno"> 1823</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01824"></a><span class="lineno"> 1824</span>&#160;    <span class="keyword">enum</span> <a class="code" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a> data_codec_id;</div><div class="line"><a name="l01825"></a><span class="lineno"> 1825</span>&#160;</div><div class="line"><a name="l01826"></a><span class="lineno"> 1826</span>&#160;<span class="preprocessor">#if FF_API_OLD_OPEN_CALLBACKS</span></div><div class="line"><a name="l01827"></a><span class="lineno"> 1827</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01828"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#afeccb79eb120b1c79d7d269e8049237a"> 1828</a></span>&#160;<span class="comment">     * Called to open further IO contexts when needed for demuxing.</span></div><div class="line"><a name="l01829"></a><span class="lineno"> 1829</span>&#160;<span class="comment">     *</span></div><div class="line"><a name="l01830"></a><span class="lineno"> 1830</span>&#160;<span class="comment">     * This can be set by the user application to perform security checks on</span></div><div class="line"><a name="l01831"></a><span class="lineno"> 1831</span>&#160;<span class="comment">     * the URLs before opening them.</span></div><div class="line"><a name="l01832"></a><span class="lineno"> 1832</span>&#160;<span class="comment">     * The function should behave like avio_open2(), AVFormatContext is provided</span></div><div class="line"><a name="l01833"></a><span class="lineno"> 1833</span>&#160;<span class="comment">     * as contextual information and to reach AVFormatContext.opaque.</span></div><div class="line"><a name="l01834"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a2112b67f2f7a58bde5b6d13dc353b58d"> 1834</a></span>&#160;<span class="comment">     *</span></div><div class="line"><a name="l01835"></a><span class="lineno"> 1835</span>&#160;<span class="comment">     * If NULL then some simple checks are used together with avio_open2().</span></div><div class="line"><a name="l01836"></a><span class="lineno"> 1836</span>&#160;<span class="comment">     *</span></div><div class="line"><a name="l01837"></a><span class="lineno"> 1837</span>&#160;<span class="comment">     * Must not be accessed directly from outside avformat.</span></div><div class="line"><a name="l01838"></a><span class="lineno"> 1838</span>&#160;<span class="comment">     * @See av_format_set_open_cb()</span></div><div class="line"><a name="l01839"></a><span class="lineno"> 1839</span>&#160;<span class="comment">     *</span></div><div class="line"><a name="l01840"></a><span class="lineno"> 1840</span>&#160;<span class="comment">     * Demuxing: Set by user.</span></div><div class="line"><a name="l01841"></a><span class="lineno"> 1841</span>&#160;<span class="comment">     *</span></div><div class="line"><a name="l01842"></a><span class="lineno"> 1842</span>&#160;<span class="comment">     * @deprecated Use io_open and io_close.</span></div><div class="line"><a name="l01843"></a><span class="lineno"> 1843</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01844"></a><span class="lineno"> 1844</span>&#160;    <a class="code" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a></div><div class="line"><a name="l01845"></a><span class="lineno"> 1845</span>&#160;    int (*open_cb)(<span class="keyword">struct </span><a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s, <a class="code" href="structAVIOContext.html">AVIOContext</a> **p, <span class="keyword">const</span> <span class="keywordtype">char</span> *url, <span class="keywordtype">int</span> <a class="code" href="structAVFormatContext.html#a32379cc371463b235d54235d4af06a15">flags</a>, <span class="keyword">const</span> <a class="code" href="structAVIOInterruptCB.html">AVIOInterruptCB</a> *int_cb, <a class="code" href="group__lavu__dict.html#ga1d7cc0833bee918994a600556410315f">AVDictionary</a> **options);</div><div class="line"><a name="l01846"></a><span class="lineno"> 1846</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l01847"></a><span class="lineno"> 1847</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01848"></a><span class="lineno"> 1848</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01849"></a><span class="lineno"> 1849</span>&#160;<span class="comment">     * &#39;,&#39; separated list of allowed protocols.</span></div><div class="line"><a name="l01850"></a><span class="lineno"> 1850</span>&#160;<span class="comment">     * - encoding: unused</span></div><div class="line"><a name="l01851"></a><span class="lineno"> 1851</span>&#160;<span class="comment">     * - decoding: set by user</span></div><div class="line"><a name="l01852"></a><span class="lineno"> 1852</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01853"></a><span class="lineno"> 1853</span>&#160;    <span class="keywordtype">char</span> *<a class="code" href="structAVFormatContext.html#adfa686249f83379ee2e3d5b295d9f442">protocol_whitelist</a>;</div><div class="line"><a name="l01854"></a><span class="lineno"> 1854</span>&#160;</div><div class="line"><a name="l01855"></a><span class="lineno"> 1855</span>&#160;    <span class="comment">/*</span></div><div class="line"><a name="l01856"></a><span class="lineno"> 1856</span>&#160;<span class="comment">     * A callback for opening new IO streams.</span></div><div class="line"><a name="l01857"></a><span class="lineno"> 1857</span>&#160;<span class="comment">     *</span></div><div class="line"><a name="l01858"></a><span class="lineno"> 1858</span>&#160;<span class="comment">     * Whenever a muxer or a demuxer needs to open an IO stream (typically from</span></div><div class="line"><a name="l01859"></a><span class="lineno"> 1859</span>&#160;<span class="comment">     * avformat_open_input() for demuxers, but for certain formats can happen at</span></div><div class="line"><a name="l01860"></a><span class="lineno"> 1860</span>&#160;<span class="comment">     * other times as well), it will call this callback to obtain an IO context.</span></div><div class="line"><a name="l01861"></a><span class="lineno"> 1861</span>&#160;<span class="comment">     *</span></div><div class="line"><a name="l01862"></a><span class="lineno"> 1862</span>&#160;<span class="comment">     * @param s the format context</span></div><div class="line"><a name="l01863"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#adfa686249f83379ee2e3d5b295d9f442"> 1863</a></span>&#160;<span class="comment">     * @param pb on success, the newly opened IO context should be returned here</span></div><div class="line"><a name="l01864"></a><span class="lineno"> 1864</span>&#160;<span class="comment">     * @param url the url to open</span></div><div class="line"><a name="l01865"></a><span class="lineno"> 1865</span>&#160;<span class="comment">     * @param flags a combination of AVIO_FLAG_*</span></div><div class="line"><a name="l01866"></a><span class="lineno"> 1866</span>&#160;<span class="comment">     * @param options a dictionary of additional options, with the same</span></div><div class="line"><a name="l01867"></a><span class="lineno"> 1867</span>&#160;<span class="comment">     *                semantics as in avio_open2()</span></div><div class="line"><a name="l01868"></a><span class="lineno"> 1868</span>&#160;<span class="comment">     * @return 0 on success, a negative AVERROR code on failure</span></div><div class="line"><a name="l01869"></a><span class="lineno"> 1869</span>&#160;<span class="comment">     *</span></div><div class="line"><a name="l01870"></a><span class="lineno"> 1870</span>&#160;<span class="comment">     * @note Certain muxers and demuxers do nesting, i.e. they open one or more</span></div><div class="line"><a name="l01871"></a><span class="lineno"> 1871</span>&#160;<span class="comment">     * additional internal format contexts. Thus the AVFormatContext pointer</span></div><div class="line"><a name="l01872"></a><span class="lineno"> 1872</span>&#160;<span class="comment">     * passed to this callback may be different from the one facing the caller.</span></div><div class="line"><a name="l01873"></a><span class="lineno"> 1873</span>&#160;<span class="comment">     * It will, however, have the same &#39;opaque&#39; field.</span></div><div class="line"><a name="l01874"></a><span class="lineno"> 1874</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01875"></a><span class="lineno"> 1875</span>&#160;    int (*<a class="code" href="structAVFormatContext.html#af3f615ad9ff79fb90f4eb136a1f58065">io_open</a>)(<span class="keyword">struct </span><a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s, <a class="code" href="structAVIOContext.html">AVIOContext</a> **<a class="code" href="structAVFormatContext.html#a1e7324262b6b78522e52064daaa7bc87">pb</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *url,</div><div class="line"><a name="l01876"></a><span class="lineno"> 1876</span>&#160;                   <span class="keywordtype">int</span> <a class="code" href="structAVFormatContext.html#a32379cc371463b235d54235d4af06a15">flags</a>, <a class="code" href="group__lavu__dict.html#ga1d7cc0833bee918994a600556410315f">AVDictionary</a> **options);</div><div class="line"><a name="l01877"></a><span class="lineno"> 1877</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01878"></a><span class="lineno"> 1878</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01879"></a><span class="lineno"> 1879</span>&#160;<span class="comment">     * A callback for closing the streams opened with AVFormatContext.io_open().</span></div><div class="line"><a name="l01880"></a><span class="lineno"> 1880</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01881"></a><span class="lineno"> 1881</span>&#160;    void (*<a class="code" href="structAVFormatContext.html#a88077ea47abd7cd3fefe7828f778a686">io_close</a>)(<span class="keyword">struct </span><a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s, <a class="code" href="structAVIOContext.html">AVIOContext</a> *<a class="code" href="structAVFormatContext.html#a1e7324262b6b78522e52064daaa7bc87">pb</a>);</div><div class="line"><a name="l01882"></a><span class="lineno"> 1882</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01883"></a><span class="lineno"> 1883</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01884"></a><span class="lineno"> 1884</span>&#160;<span class="comment">     * &#39;,&#39; separated list of disallowed protocols.</span></div><div class="line"><a name="l01885"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#af3f615ad9ff79fb90f4eb136a1f58065"> 1885</a></span>&#160;<span class="comment">     * - encoding: unused</span></div><div class="line"><a name="l01886"></a><span class="lineno"> 1886</span>&#160;<span class="comment">     * - decoding: set by user</span></div><div class="line"><a name="l01887"></a><span class="lineno"> 1887</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01888"></a><span class="lineno"> 1888</span>&#160;    <span class="keywordtype">char</span> *<a class="code" href="structAVFormatContext.html#ae06bb84162881843504ecd870c328690">protocol_blacklist</a>;</div><div class="line"><a name="l01889"></a><span class="lineno"> 1889</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01890"></a><span class="lineno"> 1890</span>&#160;<span class="comment">    /**</span></div><div class="line"><a name="l01891"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a88077ea47abd7cd3fefe7828f778a686"> 1891</a></span>&#160;<span class="comment">     * The maximum number of streams.</span></div><div class="line"><a name="l01892"></a><span class="lineno"> 1892</span>&#160;<span class="comment">     * - encoding: unused</span></div><div class="line"><a name="l01893"></a><span class="lineno"> 1893</span>&#160;<span class="comment">     * - decoding: set by user</span></div><div class="line"><a name="l01894"></a><span class="lineno"> 1894</span>&#160;<span class="comment">     */</span></div><div class="line"><a name="l01895"></a><span class="lineno"> 1895</span>&#160;    <span class="keywordtype">int</span> <a class="code" href="structAVFormatContext.html#a11bf0a9a1ba16bc402c6a237b58b4da1">max_streams</a>;</div><div class="line"><a name="l01896"></a><span class="lineno"> 1896</span>&#160;} <a class="code" href="structAVFormatContext.html">AVFormatContext</a>;</div><div class="line"><a name="l01897"></a><span class="lineno"> 1897</span>&#160;</div><div class="line"><a name="l01898"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#ae06bb84162881843504ecd870c328690"> 1898</a></span>&#160;<span class="preprocessor">#if FF_API_FORMAT_GET_SET</span></div><div class="line"><a name="l01899"></a><span class="lineno"> 1899</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l01900"></a><span class="lineno"> 1900</span>&#160;<span class="comment"> * Accessors for some AVFormatContext fields. These used to be provided for ABI</span></div><div class="line"><a name="l01901"></a><span class="lineno"> 1901</span>&#160;<span class="comment"> * compatibility, and do not need to be used anymore.</span></div><div class="line"><a name="l01902"></a><span class="lineno"> 1902</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l01903"></a><span class="lineno"> 1903</span>&#160;<a class="code" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a></div><div class="line"><a name="l01904"></a><span class="lineno"> 1904</span>&#160;<span class="keywordtype">int</span> av_format_get_probe_score(<span class="keyword">const</span> <a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s);</div><div class="line"><a name="l01905"></a><span class="lineno"><a class="line" href="structAVFormatContext.html#a11bf0a9a1ba16bc402c6a237b58b4da1"> 1905</a></span>&#160;<a class="code" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a></div><div class="line"><a name="l01906"></a><span class="lineno"> 1906</span>&#160;<a class="code" href="structAVCodec.html">AVCodec</a> * av_format_get_video_codec(<span class="keyword">const</span> <a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s);</div><div class="line"><a name="l01907"></a><span class="lineno"> 1907</span>&#160;<a class="code" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a></div><div class="line"><a name="l01908"></a><span class="lineno"> 1908</span>&#160;<span class="keywordtype">void</span>      av_format_set_video_codec(<a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s, <a class="code" href="structAVCodec.html">AVCodec</a> *c);</div><div class="line"><a name="l01909"></a><span class="lineno"> 1909</span>&#160;<a class="code" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a></div><div class="line"><a name="l01910"></a><span class="lineno"> 1910</span>&#160;<a class="code" href="structAVCodec.html">AVCodec</a> * av_format_get_audio_codec(<span class="keyword">const</span> <a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s);</div><div class="line"><a name="l01911"></a><span class="lineno"> 1911</span>&#160;<a class="code" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a></div><div class="line"><a name="l01912"></a><span class="lineno"> 1912</span>&#160;<span class="keywordtype">void</span>      av_format_set_audio_codec(<a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s, <a class="code" href="structAVCodec.html">AVCodec</a> *c);</div><div class="line"><a name="l01913"></a><span class="lineno"> 1913</span>&#160;<a class="code" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a></div><div class="line"><a name="l01914"></a><span class="lineno"> 1914</span>&#160;<a class="code" href="structAVCodec.html">AVCodec</a> * av_format_get_subtitle_codec(<span class="keyword">const</span> <a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s);</div><div class="line"><a name="l01915"></a><span class="lineno"> 1915</span>&#160;<a class="code" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a></div><div class="line"><a name="l01916"></a><span class="lineno"> 1916</span>&#160;<span class="keywordtype">void</span>      av_format_set_subtitle_codec(<a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s, <a class="code" href="structAVCodec.html">AVCodec</a> *c);</div><div class="line"><a name="l01917"></a><span class="lineno"> 1917</span>&#160;<a class="code" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a></div><div class="line"><a name="l01918"></a><span class="lineno"> 1918</span>&#160;<a class="code" href="structAVCodec.html">AVCodec</a> * av_format_get_data_codec(<span class="keyword">const</span> <a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s);</div><div class="line"><a name="l01919"></a><span class="lineno"> 1919</span>&#160;<a class="code" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a></div><div class="line"><a name="l01920"></a><span class="lineno"> 1920</span>&#160;<span class="keywordtype">void</span>      av_format_set_data_codec(<a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s, <a class="code" href="structAVCodec.html">AVCodec</a> *c);</div><div class="line"><a name="l01921"></a><span class="lineno"> 1921</span>&#160;<a class="code" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a></div><div class="line"><a name="l01922"></a><span class="lineno"> 1922</span>&#160;<span class="keywordtype">int</span>       av_format_get_metadata_header_padding(<span class="keyword">const</span> <a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s);</div><div class="line"><a name="l01923"></a><span class="lineno"> 1923</span>&#160;<a class="code" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a></div><div class="line"><a name="l01924"></a><span class="lineno"> 1924</span>&#160;<span class="keywordtype">void</span>      av_format_set_metadata_header_padding(<a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s, <span class="keywordtype">int</span> c);</div><div class="line"><a name="l01925"></a><span class="lineno"> 1925</span>&#160;<a class="code" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a></div><div class="line"><a name="l01926"></a><span class="lineno"> 1926</span>&#160;<span class="keywordtype">void</span> *    av_format_get_opaque(<span class="keyword">const</span> <a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s);</div><div class="line"><a name="l01927"></a><span class="lineno"> 1927</span>&#160;<a class="code" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a></div><div class="line"><a name="l01928"></a><span class="lineno"> 1928</span>&#160;<span class="keywordtype">void</span>      av_format_set_opaque(<a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s, <span class="keywordtype">void</span> *<a class="code" href="structAVFormatContext.html#a71797838db59ca0682dd2d18b149134e">opaque</a>);</div><div class="line"><a name="l01929"></a><span class="lineno"> 1929</span>&#160;<a class="code" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a></div><div class="line"><a name="l01930"></a><span class="lineno"> 1930</span>&#160;<a class="code" href="avformat_8h.html#a80856b99bcf4373936fb4fba028b11ca">av_format_control_message</a> av_format_get_control_message_cb(<span class="keyword">const</span> <a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s);</div><div class="line"><a name="l01931"></a><span class="lineno"> 1931</span>&#160;<a class="code" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a></div><div class="line"><a name="l01932"></a><span class="lineno"> 1932</span>&#160;<span class="keywordtype">void</span>      av_format_set_control_message_cb(<a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s, <a class="code" href="avformat_8h.html#a80856b99bcf4373936fb4fba028b11ca">av_format_control_message</a> callback);</div><div class="line"><a name="l01933"></a><span class="lineno"> 1933</span>&#160;<span class="preprocessor">#if FF_API_OLD_OPEN_CALLBACKS</span></div><div class="line"><a name="l01934"></a><span class="lineno"> 1934</span>&#160;<a class="code" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> <a class="code" href="avformat_8h.html#a6f7cab62acdf2bce2883a3c82cf1a27c">AVOpenCallback</a> av_format_get_open_cb(<span class="keyword">const</span> <a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s);</div><div class="line"><a name="l01935"></a><span class="lineno"> 1935</span>&#160;<a class="code" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a> <span class="keywordtype">void</span> av_format_set_open_cb(<a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s, <a class="code" href="avformat_8h.html#a6f7cab62acdf2bce2883a3c82cf1a27c">AVOpenCallback</a> callback);</div><div class="line"><a name="l01936"></a><span class="lineno"> 1936</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l01937"></a><span class="lineno"> 1937</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l01938"></a><span class="lineno"> 1938</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01939"></a><span class="lineno"> 1939</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l01940"></a><span class="lineno"> 1940</span>&#160;<span class="comment"> * This function will cause global side data to be injected in the next packet</span></div><div class="line"><a name="l01941"></a><span class="lineno"> 1941</span>&#160;<span class="comment"> * of each stream as well as after any subsequent seek.</span></div><div class="line"><a name="l01942"></a><span class="lineno"> 1942</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l01943"></a><span class="lineno"> 1943</span>&#160;<span class="keywordtype">void</span> <a class="code" href="avformat_8h.html#aa3a096ee52bc6b1e0f31278d26996777">av_format_inject_global_side_data</a>(<a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s);</div><div class="line"><a name="l01944"></a><span class="lineno"> 1944</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01945"></a><span class="lineno"> 1945</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l01946"></a><span class="lineno"> 1946</span>&#160;<span class="comment"> * Returns the method used to set ctx-&gt;duration.</span></div><div class="line"><a name="l01947"></a><span class="lineno"> 1947</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l01948"></a><span class="lineno"> 1948</span>&#160;<span class="comment"> * @return AVFMT_DURATION_FROM_PTS, AVFMT_DURATION_FROM_STREAM, or AVFMT_DURATION_FROM_BITRATE.</span></div><div class="line"><a name="l01949"></a><span class="lineno"> 1949</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l01950"></a><span class="lineno"> 1950</span>&#160;<span class="keyword">enum</span> <a class="code" href="avformat_8h.html#a7c2692ffa20d3e888e40e79eeda6d73b">AVDurationEstimationMethod</a> <a class="code" href="avformat_8h.html#ac7070b68d7ca5fd577f9f835556ebeff">av_fmt_ctx_get_duration_estimation_method</a>(<span class="keyword">const</span> <a class="code" href="structAVFormatContext.html">AVFormatContext</a>* ctx);</div><div class="line"><a name="l01951"></a><span class="lineno"> 1951</span>&#160;</div><div class="line"><a name="l01952"></a><span class="lineno"> 1952</span>&#160;<span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structAVPacketList.html">AVPacketList</a> {</div><div class="line"><a name="l01953"></a><span class="lineno"> 1953</span>&#160;    <a class="code" href="structAVPacket.html">AVPacket</a> <a class="code" href="demuxing__decoding_8c.html#a3d4c6562f0b27cf0cacbbea5c038c090">pkt</a>;</div><div class="line"><a name="l01954"></a><span class="lineno"> 1954</span>&#160;    <span class="keyword">struct </span><a class="code" href="structAVPacketList.html">AVPacketList</a> *<a class="code" href="structAVPacketList.html#a6a1d0f1a75cfafa4643b93752edef643">next</a>;</div><div class="line"><a name="l01955"></a><span class="lineno"> 1955</span>&#160;} <a class="code" href="structAVPacketList.html">AVPacketList</a>;</div><div class="line"><a name="l01956"></a><span class="lineno"> 1956</span>&#160;</div><div class="line"><a name="l01957"></a><span class="lineno"> 1957</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01958"></a><span class="lineno"> 1958</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l01959"></a><span class="lineno"> 1959</span>&#160;<span class="comment"> * @defgroup lavf_core Core functions</span></div><div class="line"><a name="l01960"></a><span class="lineno"> 1960</span>&#160;<span class="comment"> * @ingroup libavf</span></div><div class="line"><a name="l01961"></a><span class="lineno"> 1961</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l01962"></a><span class="lineno"><a class="line" href="structAVPacketList.html"> 1962</a></span>&#160;<span class="comment"> * Functions for querying libavformat capabilities, allocating core structures,</span></div><div class="line"><a name="l01963"></a><span class="lineno"><a class="line" href="structAVPacketList.html#a2d7ef80c60c0c3a804248ab691b9c5a7"> 1963</a></span>&#160;<span class="comment"> * etc.</span></div><div class="line"><a name="l01964"></a><span class="lineno"><a class="line" href="structAVPacketList.html#a6a1d0f1a75cfafa4643b93752edef643"> 1964</a></span>&#160;<span class="comment"> * @{</span></div><div class="line"><a name="l01965"></a><span class="lineno"> 1965</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l01966"></a><span class="lineno"> 1966</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01967"></a><span class="lineno"> 1967</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l01968"></a><span class="lineno"> 1968</span>&#160;<span class="comment"> * Return the LIBAVFORMAT_VERSION_INT constant.</span></div><div class="line"><a name="l01969"></a><span class="lineno"> 1969</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l01970"></a><span class="lineno"> 1970</span>&#160;<span class="keywordtype">unsigned</span> <a class="code" href="group__lavf__core.html#gaf2d4e0fee66cef99dea2153933e6b907">avformat_version</a>(<span class="keywordtype">void</span>);</div><div class="line"><a name="l01971"></a><span class="lineno"> 1971</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01972"></a><span class="lineno"> 1972</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l01973"></a><span class="lineno"> 1973</span>&#160;<span class="comment"> * Return the libavformat build-time configuration.</span></div><div class="line"><a name="l01974"></a><span class="lineno"> 1974</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l01975"></a><span class="lineno"> 1975</span>&#160;<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="group__lavf__core.html#ga5f48b0398d77d8eeb45d6c649e4e3404">avformat_configuration</a>(<span class="keywordtype">void</span>);</div><div class="line"><a name="l01976"></a><span class="lineno"> 1976</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01977"></a><span class="lineno"> 1977</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l01978"></a><span class="lineno"> 1978</span>&#160;<span class="comment"> * Return the libavformat license.</span></div><div class="line"><a name="l01979"></a><span class="lineno"> 1979</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l01980"></a><span class="lineno"> 1980</span>&#160;<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="group__lavf__core.html#ga160fef784175409f945c70e8931accc8">avformat_license</a>(<span class="keywordtype">void</span>);</div><div class="line"><a name="l01981"></a><span class="lineno"> 1981</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01982"></a><span class="lineno"> 1982</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l01983"></a><span class="lineno"> 1983</span>&#160;<span class="comment"> * Initialize libavformat and register all the muxers, demuxers and</span></div><div class="line"><a name="l01984"></a><span class="lineno"> 1984</span>&#160;<span class="comment"> * protocols. If you do not call this function, then you can select</span></div><div class="line"><a name="l01985"></a><span class="lineno"> 1985</span>&#160;<span class="comment"> * exactly which formats you want to support.</span></div><div class="line"><a name="l01986"></a><span class="lineno"> 1986</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l01987"></a><span class="lineno"> 1987</span>&#160;<span class="comment"> * @see av_register_input_format()</span></div><div class="line"><a name="l01988"></a><span class="lineno"> 1988</span>&#160;<span class="comment"> * @see av_register_output_format()</span></div><div class="line"><a name="l01989"></a><span class="lineno"> 1989</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l01990"></a><span class="lineno"> 1990</span>&#160;<span class="keywordtype">void</span> <a class="code" href="group__lavf__core.html#ga917265caec45ef5a0646356ed1a507e3">av_register_all</a>(<span class="keywordtype">void</span>);</div><div class="line"><a name="l01991"></a><span class="lineno"> 1991</span>&#160;</div><div class="line"><a name="l01992"></a><span class="lineno"> 1992</span>&#160;<span class="keywordtype">void</span> <a class="code" href="group__lavf__core.html#ga896f319308627b5b66fd41a4b1d53ae6">av_register_input_format</a>(<a class="code" href="structAVInputFormat.html">AVInputFormat</a> *format);</div><div class="line"><a name="l01993"></a><span class="lineno"> 1993</span>&#160;<span class="keywordtype">void</span> <a class="code" href="group__lavf__core.html#gabf0629358bc40c7874932ef6f4dda6b8">av_register_output_format</a>(<a class="code" href="structAVOutputFormat.html">AVOutputFormat</a> *format);</div><div class="line"><a name="l01994"></a><span class="lineno"> 1994</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01995"></a><span class="lineno"> 1995</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l01996"></a><span class="lineno"> 1996</span>&#160;<span class="comment"> * Do global initialization of network components. This is optional,</span></div><div class="line"><a name="l01997"></a><span class="lineno"> 1997</span>&#160;<span class="comment"> * but recommended, since it avoids the overhead of implicitly</span></div><div class="line"><a name="l01998"></a><span class="lineno"> 1998</span>&#160;<span class="comment"> * doing the setup for each session.</span></div><div class="line"><a name="l01999"></a><span class="lineno"> 1999</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02000"></a><span class="lineno"> 2000</span>&#160;<span class="comment"> * Calling this function will become mandatory if using network</span></div><div class="line"><a name="l02001"></a><span class="lineno"> 2001</span>&#160;<span class="comment"> * protocols at some major version bump.</span></div><div class="line"><a name="l02002"></a><span class="lineno"> 2002</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02003"></a><span class="lineno"> 2003</span>&#160;<span class="keywordtype">int</span> <a class="code" href="group__lavf__core.html#ga84542023693d61e8564c5d457979c932">avformat_network_init</a>(<span class="keywordtype">void</span>);</div><div class="line"><a name="l02004"></a><span class="lineno"> 2004</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02005"></a><span class="lineno"> 2005</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02006"></a><span class="lineno"> 2006</span>&#160;<span class="comment"> * Undo the initialization done by avformat_network_init.</span></div><div class="line"><a name="l02007"></a><span class="lineno"> 2007</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02008"></a><span class="lineno"> 2008</span>&#160;<span class="keywordtype">int</span> <a class="code" href="group__lavf__core.html#ga245f2875f80ce67ec3d1e0f54dacf2c4">avformat_network_deinit</a>(<span class="keywordtype">void</span>);</div><div class="line"><a name="l02009"></a><span class="lineno"> 2009</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02010"></a><span class="lineno"> 2010</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02011"></a><span class="lineno"> 2011</span>&#160;<span class="comment"> * If f is NULL, returns the first registered input format,</span></div><div class="line"><a name="l02012"></a><span class="lineno"> 2012</span>&#160;<span class="comment"> * if f is non-NULL, returns the next registered input format after f</span></div><div class="line"><a name="l02013"></a><span class="lineno"> 2013</span>&#160;<span class="comment"> * or NULL if f is the last one.</span></div><div class="line"><a name="l02014"></a><span class="lineno"> 2014</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02015"></a><span class="lineno"> 2015</span>&#160;<a class="code" href="structAVInputFormat.html">AVInputFormat</a>  *<a class="code" href="group__lavf__core.html#ga64ff7d30d32639e69fe57f99bb48f680">av_iformat_next</a>(<span class="keyword">const</span> <a class="code" href="structAVInputFormat.html">AVInputFormat</a>  *f);</div><div class="line"><a name="l02016"></a><span class="lineno"> 2016</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02017"></a><span class="lineno"> 2017</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02018"></a><span class="lineno"> 2018</span>&#160;<span class="comment"> * If f is NULL, returns the first registered output format,</span></div><div class="line"><a name="l02019"></a><span class="lineno"> 2019</span>&#160;<span class="comment"> * if f is non-NULL, returns the next registered output format after f</span></div><div class="line"><a name="l02020"></a><span class="lineno"> 2020</span>&#160;<span class="comment"> * or NULL if f is the last one.</span></div><div class="line"><a name="l02021"></a><span class="lineno"> 2021</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02022"></a><span class="lineno"> 2022</span>&#160;<a class="code" href="structAVOutputFormat.html">AVOutputFormat</a> *<a class="code" href="group__lavf__core.html#ga8fe016b9e8df67a5ffde855f2f891d71">av_oformat_next</a>(<span class="keyword">const</span> <a class="code" href="structAVOutputFormat.html">AVOutputFormat</a> *f);</div><div class="line"><a name="l02023"></a><span class="lineno"> 2023</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02024"></a><span class="lineno"> 2024</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02025"></a><span class="lineno"> 2025</span>&#160;<span class="comment"> * Allocate an AVFormatContext.</span></div><div class="line"><a name="l02026"></a><span class="lineno"> 2026</span>&#160;<span class="comment"> * avformat_free_context() can be used to free the context and everything</span></div><div class="line"><a name="l02027"></a><span class="lineno"> 2027</span>&#160;<span class="comment"> * allocated by the framework within it.</span></div><div class="line"><a name="l02028"></a><span class="lineno"> 2028</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02029"></a><span class="lineno"> 2029</span>&#160;<a class="code" href="structAVFormatContext.html">AVFormatContext</a> *<a class="code" href="group__lavf__core.html#gac7a91abf2f59648d995894711f070f62">avformat_alloc_context</a>(<span class="keywordtype">void</span>);</div><div class="line"><a name="l02030"></a><span class="lineno"> 2030</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02031"></a><span class="lineno"> 2031</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02032"></a><span class="lineno"> 2032</span>&#160;<span class="comment"> * Free an AVFormatContext and all its streams.</span></div><div class="line"><a name="l02033"></a><span class="lineno"> 2033</span>&#160;<span class="comment"> * @param s context to free</span></div><div class="line"><a name="l02034"></a><span class="lineno"> 2034</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02035"></a><span class="lineno"> 2035</span>&#160;<span class="keywordtype">void</span> <a class="code" href="group__lavf__core.html#gac2990b13b68e831a408fce8e1d0d6445">avformat_free_context</a>(<a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s);</div><div class="line"><a name="l02036"></a><span class="lineno"> 2036</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02037"></a><span class="lineno"> 2037</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02038"></a><span class="lineno"> 2038</span>&#160;<span class="comment"> * Get the AVClass for AVFormatContext. It can be used in combination with</span></div><div class="line"><a name="l02039"></a><span class="lineno"> 2039</span>&#160;<span class="comment"> * AV_OPT_SEARCH_FAKE_OBJ for examining options.</span></div><div class="line"><a name="l02040"></a><span class="lineno"> 2040</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02041"></a><span class="lineno"> 2041</span>&#160;<span class="comment"> * @see av_opt_find().</span></div><div class="line"><a name="l02042"></a><span class="lineno"> 2042</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02043"></a><span class="lineno"> 2043</span>&#160;<span class="keyword">const</span> <a class="code" href="structAVClass.html">AVClass</a> *<a class="code" href="group__lavf__core.html#ga6030789ce395ef543306bbe933619749">avformat_get_class</a>(<span class="keywordtype">void</span>);</div><div class="line"><a name="l02044"></a><span class="lineno"> 2044</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02045"></a><span class="lineno"> 2045</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02046"></a><span class="lineno"> 2046</span>&#160;<span class="comment"> * Add a new stream to a media file.</span></div><div class="line"><a name="l02047"></a><span class="lineno"> 2047</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02048"></a><span class="lineno"> 2048</span>&#160;<span class="comment"> * When demuxing, it is called by the demuxer in read_header(). If the</span></div><div class="line"><a name="l02049"></a><span class="lineno"> 2049</span>&#160;<span class="comment"> * flag AVFMTCTX_NOHEADER is set in s.ctx_flags, then it may also</span></div><div class="line"><a name="l02050"></a><span class="lineno"> 2050</span>&#160;<span class="comment"> * be called in read_packet().</span></div><div class="line"><a name="l02051"></a><span class="lineno"> 2051</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02052"></a><span class="lineno"> 2052</span>&#160;<span class="comment"> * When muxing, should be called by the user before avformat_write_header().</span></div><div class="line"><a name="l02053"></a><span class="lineno"> 2053</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02054"></a><span class="lineno"> 2054</span>&#160;<span class="comment"> * User is required to call avcodec_close() and avformat_free_context() to</span></div><div class="line"><a name="l02055"></a><span class="lineno"> 2055</span>&#160;<span class="comment"> * clean up the allocation by avformat_new_stream().</span></div><div class="line"><a name="l02056"></a><span class="lineno"> 2056</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02057"></a><span class="lineno"> 2057</span>&#160;<span class="comment"> * @param s media file handle</span></div><div class="line"><a name="l02058"></a><span class="lineno"> 2058</span>&#160;<span class="comment"> * @param c If non-NULL, the AVCodecContext corresponding to the new stream</span></div><div class="line"><a name="l02059"></a><span class="lineno"> 2059</span>&#160;<span class="comment"> * will be initialized to use this codec. This is needed for e.g. codec-specific</span></div><div class="line"><a name="l02060"></a><span class="lineno"> 2060</span>&#160;<span class="comment"> * defaults to be set, so codec should be provided if it is known.</span></div><div class="line"><a name="l02061"></a><span class="lineno"> 2061</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02062"></a><span class="lineno"> 2062</span>&#160;<span class="comment"> * @return newly created stream or NULL on error.</span></div><div class="line"><a name="l02063"></a><span class="lineno"> 2063</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02064"></a><span class="lineno"> 2064</span>&#160;<a class="code" href="structAVStream.html">AVStream</a> *<a class="code" href="group__lavf__core.html#gadcb0fd3e507d9b58fe78f61f8ad39827">avformat_new_stream</a>(<a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s, <span class="keyword">const</span> <a class="code" href="structAVCodec.html">AVCodec</a> *c);</div><div class="line"><a name="l02065"></a><span class="lineno"> 2065</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02066"></a><span class="lineno"> 2066</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02067"></a><span class="lineno"> 2067</span>&#160;<span class="comment"> * Wrap an existing array as stream side data.</span></div><div class="line"><a name="l02068"></a><span class="lineno"> 2068</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02069"></a><span class="lineno"> 2069</span>&#160;<span class="comment"> * @param st stream</span></div><div class="line"><a name="l02070"></a><span class="lineno"> 2070</span>&#160;<span class="comment"> * @param type side information type</span></div><div class="line"><a name="l02071"></a><span class="lineno"> 2071</span>&#160;<span class="comment"> * @param data the side data array. It must be allocated with the av_malloc()</span></div><div class="line"><a name="l02072"></a><span class="lineno"> 2072</span>&#160;<span class="comment"> *             family of functions. The ownership of the data is transferred to</span></div><div class="line"><a name="l02073"></a><span class="lineno"> 2073</span>&#160;<span class="comment"> *             st.</span></div><div class="line"><a name="l02074"></a><span class="lineno"> 2074</span>&#160;<span class="comment"> * @param size side information size</span></div><div class="line"><a name="l02075"></a><span class="lineno"> 2075</span>&#160;<span class="comment"> * @return zero on success, a negative AVERROR code on failure. On failure,</span></div><div class="line"><a name="l02076"></a><span class="lineno"> 2076</span>&#160;<span class="comment"> *         the stream is unchanged and the data remains owned by the caller.</span></div><div class="line"><a name="l02077"></a><span class="lineno"> 2077</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02078"></a><span class="lineno"> 2078</span>&#160;<span class="keywordtype">int</span> <a class="code" href="group__lavf__core.html#ga5c8d715704c153cb645982444063cc2b">av_stream_add_side_data</a>(<a class="code" href="structAVStream.html">AVStream</a> *st, <span class="keyword">enum</span> <a class="code" href="group__lavc__packet.html#ga9a80bfcacc586b483a973272800edb97">AVPacketSideDataType</a> type,</div><div class="line"><a name="l02079"></a><span class="lineno"> 2079</span>&#160;                            uint8_t *data, <span class="keywordtype">size_t</span> size);</div><div class="line"><a name="l02080"></a><span class="lineno"> 2080</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02081"></a><span class="lineno"> 2081</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02082"></a><span class="lineno"> 2082</span>&#160;<span class="comment"> * Allocate new information from stream.</span></div><div class="line"><a name="l02083"></a><span class="lineno"> 2083</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02084"></a><span class="lineno"> 2084</span>&#160;<span class="comment"> * @param stream stream</span></div><div class="line"><a name="l02085"></a><span class="lineno"> 2085</span>&#160;<span class="comment"> * @param type desired side information type</span></div><div class="line"><a name="l02086"></a><span class="lineno"> 2086</span>&#160;<span class="comment"> * @param size side information size</span></div><div class="line"><a name="l02087"></a><span class="lineno"> 2087</span>&#160;<span class="comment"> * @return pointer to fresh allocated data or NULL otherwise</span></div><div class="line"><a name="l02088"></a><span class="lineno"> 2088</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02089"></a><span class="lineno"> 2089</span>&#160;uint8_t *<a class="code" href="group__lavf__core.html#gae324697cedd36e7b47a1e142dc24b805">av_stream_new_side_data</a>(<a class="code" href="structAVStream.html">AVStream</a> *stream,</div><div class="line"><a name="l02090"></a><span class="lineno"> 2090</span>&#160;                                 <span class="keyword">enum</span> <a class="code" href="group__lavc__packet.html#ga9a80bfcacc586b483a973272800edb97">AVPacketSideDataType</a> type, <span class="keywordtype">int</span> size);<span class="comment"></span></div><div class="line"><a name="l02091"></a><span class="lineno"> 2091</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02092"></a><span class="lineno"> 2092</span>&#160;<span class="comment"> * Get side information from stream.</span></div><div class="line"><a name="l02093"></a><span class="lineno"> 2093</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02094"></a><span class="lineno"> 2094</span>&#160;<span class="comment"> * @param stream stream</span></div><div class="line"><a name="l02095"></a><span class="lineno"> 2095</span>&#160;<span class="comment"> * @param type desired side information type</span></div><div class="line"><a name="l02096"></a><span class="lineno"> 2096</span>&#160;<span class="comment"> * @param size pointer for side information size to store (optional)</span></div><div class="line"><a name="l02097"></a><span class="lineno"> 2097</span>&#160;<span class="comment"> * @return pointer to data if present or NULL otherwise</span></div><div class="line"><a name="l02098"></a><span class="lineno"> 2098</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02099"></a><span class="lineno"> 2099</span>&#160;uint8_t *<a class="code" href="group__lavf__core.html#ga2c3404067d7e9bc7b8443e3f58cf8e65">av_stream_get_side_data</a>(<span class="keyword">const</span> <a class="code" href="structAVStream.html">AVStream</a> *stream,</div><div class="line"><a name="l02100"></a><span class="lineno"> 2100</span>&#160;                                 <span class="keyword">enum</span> <a class="code" href="group__lavc__packet.html#ga9a80bfcacc586b483a973272800edb97">AVPacketSideDataType</a> type, <span class="keywordtype">int</span> *size);</div><div class="line"><a name="l02101"></a><span class="lineno"> 2101</span>&#160;</div><div class="line"><a name="l02102"></a><span class="lineno"> 2102</span>&#160;<a class="code" href="structAVProgram.html">AVProgram</a> *<a class="code" href="group__lavf__core.html#gab31f7c7c99dcadead38e8e83e0fdb828">av_new_program</a>(<a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s, <span class="keywordtype">int</span> <span class="keywordtype">id</span>);</div><div class="line"><a name="l02103"></a><span class="lineno"> 2103</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02104"></a><span class="lineno"> 2104</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02105"></a><span class="lineno"> 2105</span>&#160;<span class="comment"> * @}</span></div><div class="line"><a name="l02106"></a><span class="lineno"> 2106</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02107"></a><span class="lineno"> 2107</span>&#160;</div><div class="line"><a name="l02108"></a><span class="lineno"> 2108</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02109"></a><span class="lineno"> 2109</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02110"></a><span class="lineno"> 2110</span>&#160;<span class="comment"> * Allocate an AVFormatContext for an output format.</span></div><div class="line"><a name="l02111"></a><span class="lineno"> 2111</span>&#160;<span class="comment"> * avformat_free_context() can be used to free the context and</span></div><div class="line"><a name="l02112"></a><span class="lineno"> 2112</span>&#160;<span class="comment"> * everything allocated by the framework within it.</span></div><div class="line"><a name="l02113"></a><span class="lineno"> 2113</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02114"></a><span class="lineno"> 2114</span>&#160;<span class="comment"> * @param *ctx is set to the created format context, or to NULL in</span></div><div class="line"><a name="l02115"></a><span class="lineno"> 2115</span>&#160;<span class="comment"> * case of failure</span></div><div class="line"><a name="l02116"></a><span class="lineno"> 2116</span>&#160;<span class="comment"> * @param oformat format to use for allocating the context, if NULL</span></div><div class="line"><a name="l02117"></a><span class="lineno"> 2117</span>&#160;<span class="comment"> * format_name and filename are used instead</span></div><div class="line"><a name="l02118"></a><span class="lineno"> 2118</span>&#160;<span class="comment"> * @param format_name the name of output format to use for allocating the</span></div><div class="line"><a name="l02119"></a><span class="lineno"> 2119</span>&#160;<span class="comment"> * context, if NULL filename is used instead</span></div><div class="line"><a name="l02120"></a><span class="lineno"> 2120</span>&#160;<span class="comment"> * @param filename the name of the filename to use for allocating the</span></div><div class="line"><a name="l02121"></a><span class="lineno"> 2121</span>&#160;<span class="comment"> * context, may be NULL</span></div><div class="line"><a name="l02122"></a><span class="lineno"> 2122</span>&#160;<span class="comment"> * @return &gt;= 0 in case of success, a negative AVERROR code in case of</span></div><div class="line"><a name="l02123"></a><span class="lineno"> 2123</span>&#160;<span class="comment"> * failure</span></div><div class="line"><a name="l02124"></a><span class="lineno"> 2124</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02125"></a><span class="lineno"> 2125</span>&#160;<span class="keywordtype">int</span> <a class="code" href="avformat_8h.html#a6ddf3d982feb45fa5081420ee911f5d5">avformat_alloc_output_context2</a>(<a class="code" href="structAVFormatContext.html">AVFormatContext</a> **ctx, <a class="code" href="structAVOutputFormat.html">AVOutputFormat</a> *oformat,</div><div class="line"><a name="l02126"></a><span class="lineno"> 2126</span>&#160;                                   <span class="keyword">const</span> <span class="keywordtype">char</span> *format_name, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structAVProbeData.html#a0e8504127aff8af25cc9f3c6400b9651">filename</a>);</div><div class="line"><a name="l02127"></a><span class="lineno"> 2127</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02128"></a><span class="lineno"> 2128</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02129"></a><span class="lineno"> 2129</span>&#160;<span class="comment"> * @addtogroup lavf_decoding</span></div><div class="line"><a name="l02130"></a><span class="lineno"> 2130</span>&#160;<span class="comment"> * @{</span></div><div class="line"><a name="l02131"></a><span class="lineno"> 2131</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02132"></a><span class="lineno"> 2132</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02133"></a><span class="lineno"> 2133</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02134"></a><span class="lineno"> 2134</span>&#160;<span class="comment"> * Find AVInputFormat based on the short name of the input format.</span></div><div class="line"><a name="l02135"></a><span class="lineno"> 2135</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02136"></a><span class="lineno"> 2136</span>&#160;<a class="code" href="structAVInputFormat.html">AVInputFormat</a> *<a class="code" href="group__lavf__decoding.html#ga7d2f532c6653c2419b17956712fdf3da">av_find_input_format</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *short_name);</div><div class="line"><a name="l02137"></a><span class="lineno"> 2137</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02138"></a><span class="lineno"> 2138</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02139"></a><span class="lineno"> 2139</span>&#160;<span class="comment"> * Guess the file format.</span></div><div class="line"><a name="l02140"></a><span class="lineno"> 2140</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02141"></a><span class="lineno"> 2141</span>&#160;<span class="comment"> * @param pd        data to be probed</span></div><div class="line"><a name="l02142"></a><span class="lineno"> 2142</span>&#160;<span class="comment"> * @param is_opened Whether the file is already opened; determines whether</span></div><div class="line"><a name="l02143"></a><span class="lineno"> 2143</span>&#160;<span class="comment"> *                  demuxers with or without AVFMT_NOFILE are probed.</span></div><div class="line"><a name="l02144"></a><span class="lineno"> 2144</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02145"></a><span class="lineno"> 2145</span>&#160;<a class="code" href="structAVInputFormat.html">AVInputFormat</a> *<a class="code" href="group__lavf__decoding.html#gad8a1268228fff3aeae0aeaa99a767a24">av_probe_input_format</a>(<a class="code" href="structAVProbeData.html">AVProbeData</a> *pd, <span class="keywordtype">int</span> is_opened);</div><div class="line"><a name="l02146"></a><span class="lineno"> 2146</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02147"></a><span class="lineno"> 2147</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02148"></a><span class="lineno"> 2148</span>&#160;<span class="comment"> * Guess the file format.</span></div><div class="line"><a name="l02149"></a><span class="lineno"> 2149</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02150"></a><span class="lineno"> 2150</span>&#160;<span class="comment"> * @param pd        data to be probed</span></div><div class="line"><a name="l02151"></a><span class="lineno"> 2151</span>&#160;<span class="comment"> * @param is_opened Whether the file is already opened; determines whether</span></div><div class="line"><a name="l02152"></a><span class="lineno"> 2152</span>&#160;<span class="comment"> *                  demuxers with or without AVFMT_NOFILE are probed.</span></div><div class="line"><a name="l02153"></a><span class="lineno"> 2153</span>&#160;<span class="comment"> * @param score_max A probe score larger that this is required to accept a</span></div><div class="line"><a name="l02154"></a><span class="lineno"> 2154</span>&#160;<span class="comment"> *                  detection, the variable is set to the actual detection</span></div><div class="line"><a name="l02155"></a><span class="lineno"> 2155</span>&#160;<span class="comment"> *                  score afterwards.</span></div><div class="line"><a name="l02156"></a><span class="lineno"> 2156</span>&#160;<span class="comment"> *                  If the score is &lt;= AVPROBE_SCORE_MAX / 4 it is recommended</span></div><div class="line"><a name="l02157"></a><span class="lineno"> 2157</span>&#160;<span class="comment"> *                  to retry with a larger probe buffer.</span></div><div class="line"><a name="l02158"></a><span class="lineno"> 2158</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02159"></a><span class="lineno"> 2159</span>&#160;<a class="code" href="structAVInputFormat.html">AVInputFormat</a> *<a class="code" href="group__lavf__decoding.html#gae8b938f6e7c3741dd27a6c171e72f33d">av_probe_input_format2</a>(<a class="code" href="structAVProbeData.html">AVProbeData</a> *pd, <span class="keywordtype">int</span> is_opened, <span class="keywordtype">int</span> *score_max);</div><div class="line"><a name="l02160"></a><span class="lineno"> 2160</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02161"></a><span class="lineno"> 2161</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02162"></a><span class="lineno"> 2162</span>&#160;<span class="comment"> * Guess the file format.</span></div><div class="line"><a name="l02163"></a><span class="lineno"> 2163</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02164"></a><span class="lineno"> 2164</span>&#160;<span class="comment"> * @param is_opened Whether the file is already opened; determines whether</span></div><div class="line"><a name="l02165"></a><span class="lineno"> 2165</span>&#160;<span class="comment"> *                  demuxers with or without AVFMT_NOFILE are probed.</span></div><div class="line"><a name="l02166"></a><span class="lineno"> 2166</span>&#160;<span class="comment"> * @param score_ret The score of the best detection.</span></div><div class="line"><a name="l02167"></a><span class="lineno"> 2167</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02168"></a><span class="lineno"> 2168</span>&#160;<a class="code" href="structAVInputFormat.html">AVInputFormat</a> *<a class="code" href="group__lavf__decoding.html#ga7e4318244afd6c5fe55cec75d27258b2">av_probe_input_format3</a>(<a class="code" href="structAVProbeData.html">AVProbeData</a> *pd, <span class="keywordtype">int</span> is_opened, <span class="keywordtype">int</span> *score_ret);</div><div class="line"><a name="l02169"></a><span class="lineno"> 2169</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02170"></a><span class="lineno"> 2170</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02171"></a><span class="lineno"> 2171</span>&#160;<span class="comment"> * Probe a bytestream to determine the input format. Each time a probe returns</span></div><div class="line"><a name="l02172"></a><span class="lineno"> 2172</span>&#160;<span class="comment"> * with a score that is too low, the probe buffer size is increased and another</span></div><div class="line"><a name="l02173"></a><span class="lineno"> 2173</span>&#160;<span class="comment"> * attempt is made. When the maximum probe size is reached, the input format</span></div><div class="line"><a name="l02174"></a><span class="lineno"> 2174</span>&#160;<span class="comment"> * with the highest score is returned.</span></div><div class="line"><a name="l02175"></a><span class="lineno"> 2175</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02176"></a><span class="lineno"> 2176</span>&#160;<span class="comment"> * @param pb the bytestream to probe</span></div><div class="line"><a name="l02177"></a><span class="lineno"> 2177</span>&#160;<span class="comment"> * @param fmt the input format is put here</span></div><div class="line"><a name="l02178"></a><span class="lineno"> 2178</span>&#160;<span class="comment"> * @param url the url of the stream</span></div><div class="line"><a name="l02179"></a><span class="lineno"> 2179</span>&#160;<span class="comment"> * @param logctx the log context</span></div><div class="line"><a name="l02180"></a><span class="lineno"> 2180</span>&#160;<span class="comment"> * @param offset the offset within the bytestream to probe from</span></div><div class="line"><a name="l02181"></a><span class="lineno"> 2181</span>&#160;<span class="comment"> * @param max_probe_size the maximum probe buffer size (zero for default)</span></div><div class="line"><a name="l02182"></a><span class="lineno"> 2182</span>&#160;<span class="comment"> * @return the score in case of success, a negative value corresponding to an</span></div><div class="line"><a name="l02183"></a><span class="lineno"> 2183</span>&#160;<span class="comment"> *         the maximal score is AVPROBE_SCORE_MAX</span></div><div class="line"><a name="l02184"></a><span class="lineno"> 2184</span>&#160;<span class="comment"> * AVERROR code otherwise</span></div><div class="line"><a name="l02185"></a><span class="lineno"> 2185</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02186"></a><span class="lineno"> 2186</span>&#160;<span class="keywordtype">int</span> <a class="code" href="group__lavf__decoding.html#gafba896fafa5947fefeb47360f0bb0237">av_probe_input_buffer2</a>(<a class="code" href="structAVIOContext.html">AVIOContext</a> *pb, <a class="code" href="structAVInputFormat.html">AVInputFormat</a> **fmt,</div><div class="line"><a name="l02187"></a><span class="lineno"> 2187</span>&#160;                           <span class="keyword">const</span> <span class="keywordtype">char</span> *url, <span class="keywordtype">void</span> *logctx,</div><div class="line"><a name="l02188"></a><span class="lineno"> 2188</span>&#160;                           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> offset, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_probe_size);</div><div class="line"><a name="l02189"></a><span class="lineno"> 2189</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02190"></a><span class="lineno"> 2190</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02191"></a><span class="lineno"> 2191</span>&#160;<span class="comment"> * Like av_probe_input_buffer2() but returns 0 on success</span></div><div class="line"><a name="l02192"></a><span class="lineno"> 2192</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02193"></a><span class="lineno"> 2193</span>&#160;<span class="keywordtype">int</span> <a class="code" href="group__lavf__decoding.html#ga85cab6fb4038a82d90b4adea8c253943">av_probe_input_buffer</a>(<a class="code" href="structAVIOContext.html">AVIOContext</a> *pb, <a class="code" href="structAVInputFormat.html">AVInputFormat</a> **fmt,</div><div class="line"><a name="l02194"></a><span class="lineno"> 2194</span>&#160;                          <span class="keyword">const</span> <span class="keywordtype">char</span> *url, <span class="keywordtype">void</span> *logctx,</div><div class="line"><a name="l02195"></a><span class="lineno"> 2195</span>&#160;                          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> offset, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> max_probe_size);</div><div class="line"><a name="l02196"></a><span class="lineno"> 2196</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02197"></a><span class="lineno"> 2197</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02198"></a><span class="lineno"> 2198</span>&#160;<span class="comment"> * Open an input stream and read the header. The codecs are not opened.</span></div><div class="line"><a name="l02199"></a><span class="lineno"> 2199</span>&#160;<span class="comment"> * The stream must be closed with avformat_close_input().</span></div><div class="line"><a name="l02200"></a><span class="lineno"> 2200</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02201"></a><span class="lineno"> 2201</span>&#160;<span class="comment"> * @param ps Pointer to user-supplied AVFormatContext (allocated by avformat_alloc_context).</span></div><div class="line"><a name="l02202"></a><span class="lineno"> 2202</span>&#160;<span class="comment"> *           May be a pointer to NULL, in which case an AVFormatContext is allocated by this</span></div><div class="line"><a name="l02203"></a><span class="lineno"> 2203</span>&#160;<span class="comment"> *           function and written into ps.</span></div><div class="line"><a name="l02204"></a><span class="lineno"> 2204</span>&#160;<span class="comment"> *           Note that a user-supplied AVFormatContext will be freed on failure.</span></div><div class="line"><a name="l02205"></a><span class="lineno"> 2205</span>&#160;<span class="comment"> * @param url URL of the stream to open.</span></div><div class="line"><a name="l02206"></a><span class="lineno"> 2206</span>&#160;<span class="comment"> * @param fmt If non-NULL, this parameter forces a specific input format.</span></div><div class="line"><a name="l02207"></a><span class="lineno"> 2207</span>&#160;<span class="comment"> *            Otherwise the format is autodetected.</span></div><div class="line"><a name="l02208"></a><span class="lineno"> 2208</span>&#160;<span class="comment"> * @param options  A dictionary filled with AVFormatContext and demuxer-private options.</span></div><div class="line"><a name="l02209"></a><span class="lineno"> 2209</span>&#160;<span class="comment"> *                 On return this parameter will be destroyed and replaced with a dict containing</span></div><div class="line"><a name="l02210"></a><span class="lineno"> 2210</span>&#160;<span class="comment"> *                 options that were not found. May be NULL.</span></div><div class="line"><a name="l02211"></a><span class="lineno"> 2211</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02212"></a><span class="lineno"> 2212</span>&#160;<span class="comment"> * @return 0 on success, a negative AVERROR on failure.</span></div><div class="line"><a name="l02213"></a><span class="lineno"> 2213</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02214"></a><span class="lineno"> 2214</span>&#160;<span class="comment"> * @note If you want to use custom IO, preallocate the format context and set its pb field.</span></div><div class="line"><a name="l02215"></a><span class="lineno"> 2215</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02216"></a><span class="lineno"> 2216</span>&#160;<span class="keywordtype">int</span> <a class="code" href="group__lavf__decoding.html#ga31d601155e9035d5b0e7efedc894ee49">avformat_open_input</a>(<a class="code" href="structAVFormatContext.html">AVFormatContext</a> **ps, <span class="keyword">const</span> <span class="keywordtype">char</span> *url, <a class="code" href="structAVInputFormat.html">AVInputFormat</a> *fmt, <a class="code" href="group__lavu__dict.html#ga1d7cc0833bee918994a600556410315f">AVDictionary</a> **options);</div><div class="line"><a name="l02217"></a><span class="lineno"> 2217</span>&#160;</div><div class="line"><a name="l02218"></a><span class="lineno"> 2218</span>&#160;<a class="code" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a></div><div class="line"><a name="l02219"></a><span class="lineno"> 2219</span>&#160;<span class="keywordtype">int</span> <a class="code" href="group__lavf__decoding.html#ga71091e146791c4d181635485447c2830">av_demuxer_open</a>(<a class="code" href="structAVFormatContext.html">AVFormatContext</a> *ic);</div><div class="line"><a name="l02220"></a><span class="lineno"> 2220</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02221"></a><span class="lineno"> 2221</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02222"></a><span class="lineno"> 2222</span>&#160;<span class="comment"> * Read packets of a media file to get stream information. This</span></div><div class="line"><a name="l02223"></a><span class="lineno"> 2223</span>&#160;<span class="comment"> * is useful for file formats with no headers such as MPEG. This</span></div><div class="line"><a name="l02224"></a><span class="lineno"> 2224</span>&#160;<span class="comment"> * function also computes the real framerate in case of MPEG-2 repeat</span></div><div class="line"><a name="l02225"></a><span class="lineno"> 2225</span>&#160;<span class="comment"> * frame mode.</span></div><div class="line"><a name="l02226"></a><span class="lineno"> 2226</span>&#160;<span class="comment"> * The logical file position is not changed by this function;</span></div><div class="line"><a name="l02227"></a><span class="lineno"> 2227</span>&#160;<span class="comment"> * examined packets may be buffered for later processing.</span></div><div class="line"><a name="l02228"></a><span class="lineno"> 2228</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02229"></a><span class="lineno"> 2229</span>&#160;<span class="comment"> * @param ic media file handle</span></div><div class="line"><a name="l02230"></a><span class="lineno"> 2230</span>&#160;<span class="comment"> * @param options  If non-NULL, an ic.nb_streams long array of pointers to</span></div><div class="line"><a name="l02231"></a><span class="lineno"> 2231</span>&#160;<span class="comment"> *                 dictionaries, where i-th member contains options for</span></div><div class="line"><a name="l02232"></a><span class="lineno"> 2232</span>&#160;<span class="comment"> *                 codec corresponding to i-th stream.</span></div><div class="line"><a name="l02233"></a><span class="lineno"> 2233</span>&#160;<span class="comment"> *                 On return each dictionary will be filled with options that were not found.</span></div><div class="line"><a name="l02234"></a><span class="lineno"> 2234</span>&#160;<span class="comment"> * @return &gt;=0 if OK, AVERROR_xxx on error</span></div><div class="line"><a name="l02235"></a><span class="lineno"> 2235</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02236"></a><span class="lineno"> 2236</span>&#160;<span class="comment"> * @note this function isn&#39;t guaranteed to open all the codecs, so</span></div><div class="line"><a name="l02237"></a><span class="lineno"> 2237</span>&#160;<span class="comment"> *       options being non-empty at return is a perfectly normal behavior.</span></div><div class="line"><a name="l02238"></a><span class="lineno"> 2238</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02239"></a><span class="lineno"> 2239</span>&#160;<span class="comment"> * @todo Let the user decide somehow what information is needed so that</span></div><div class="line"><a name="l02240"></a><span class="lineno"> 2240</span>&#160;<span class="comment"> *       we do not waste time getting stuff the user does not need.</span></div><div class="line"><a name="l02241"></a><span class="lineno"> 2241</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02242"></a><span class="lineno"> 2242</span>&#160;<span class="keywordtype">int</span> <a class="code" href="group__lavf__decoding.html#gad42172e27cddafb81096939783b157bb">avformat_find_stream_info</a>(<a class="code" href="structAVFormatContext.html">AVFormatContext</a> *ic, <a class="code" href="group__lavu__dict.html#ga1d7cc0833bee918994a600556410315f">AVDictionary</a> **options);</div><div class="line"><a name="l02243"></a><span class="lineno"> 2243</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02244"></a><span class="lineno"> 2244</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02245"></a><span class="lineno"> 2245</span>&#160;<span class="comment"> * Find the programs which belong to a given stream.</span></div><div class="line"><a name="l02246"></a><span class="lineno"> 2246</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02247"></a><span class="lineno"> 2247</span>&#160;<span class="comment"> * @param ic    media file handle</span></div><div class="line"><a name="l02248"></a><span class="lineno"> 2248</span>&#160;<span class="comment"> * @param last  the last found program, the search will start after this</span></div><div class="line"><a name="l02249"></a><span class="lineno"> 2249</span>&#160;<span class="comment"> *              program, or from the beginning if it is NULL</span></div><div class="line"><a name="l02250"></a><span class="lineno"> 2250</span>&#160;<span class="comment"> * @param s     stream index</span></div><div class="line"><a name="l02251"></a><span class="lineno"> 2251</span>&#160;<span class="comment"> * @return the next program which belongs to s, NULL if no program is found or</span></div><div class="line"><a name="l02252"></a><span class="lineno"> 2252</span>&#160;<span class="comment"> *         the last program is not among the programs of ic.</span></div><div class="line"><a name="l02253"></a><span class="lineno"> 2253</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02254"></a><span class="lineno"> 2254</span>&#160;<a class="code" href="structAVProgram.html">AVProgram</a> *<a class="code" href="group__lavf__decoding.html#ga9edb9ac206ed05dc5baa9d168f31de48">av_find_program_from_stream</a>(<a class="code" href="structAVFormatContext.html">AVFormatContext</a> *ic, <a class="code" href="structAVProgram.html">AVProgram</a> *last, <span class="keywordtype">int</span> s);</div><div class="line"><a name="l02255"></a><span class="lineno"> 2255</span>&#160;</div><div class="line"><a name="l02256"></a><span class="lineno"> 2256</span>&#160;<span class="keywordtype">void</span> <a class="code" href="group__lavf__decoding.html#gaa59b7800da8ec11457c1e5b3fc295a20">av_program_add_stream_index</a>(<a class="code" href="structAVFormatContext.html">AVFormatContext</a> *ac, <span class="keywordtype">int</span> progid, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx);</div><div class="line"><a name="l02257"></a><span class="lineno"> 2257</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02258"></a><span class="lineno"> 2258</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02259"></a><span class="lineno"> 2259</span>&#160;<span class="comment"> * Find the &quot;best&quot; stream in the file.</span></div><div class="line"><a name="l02260"></a><span class="lineno"> 2260</span>&#160;<span class="comment"> * The best stream is determined according to various heuristics as the most</span></div><div class="line"><a name="l02261"></a><span class="lineno"> 2261</span>&#160;<span class="comment"> * likely to be what the user expects.</span></div><div class="line"><a name="l02262"></a><span class="lineno"> 2262</span>&#160;<span class="comment"> * If the decoder parameter is non-NULL, av_find_best_stream will find the</span></div><div class="line"><a name="l02263"></a><span class="lineno"> 2263</span>&#160;<span class="comment"> * default decoder for the stream&#39;s codec; streams for which no decoder can</span></div><div class="line"><a name="l02264"></a><span class="lineno"> 2264</span>&#160;<span class="comment"> * be found are ignored.</span></div><div class="line"><a name="l02265"></a><span class="lineno"> 2265</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02266"></a><span class="lineno"> 2266</span>&#160;<span class="comment"> * @param ic                media file handle</span></div><div class="line"><a name="l02267"></a><span class="lineno"> 2267</span>&#160;<span class="comment"> * @param type              stream type: video, audio, subtitles, etc.</span></div><div class="line"><a name="l02268"></a><span class="lineno"> 2268</span>&#160;<span class="comment"> * @param wanted_stream_nb  user-requested stream number,</span></div><div class="line"><a name="l02269"></a><span class="lineno"> 2269</span>&#160;<span class="comment"> *                          or -1 for automatic selection</span></div><div class="line"><a name="l02270"></a><span class="lineno"> 2270</span>&#160;<span class="comment"> * @param related_stream    try to find a stream related (eg. in the same</span></div><div class="line"><a name="l02271"></a><span class="lineno"> 2271</span>&#160;<span class="comment"> *                          program) to this one, or -1 if none</span></div><div class="line"><a name="l02272"></a><span class="lineno"> 2272</span>&#160;<span class="comment"> * @param decoder_ret       if non-NULL, returns the decoder for the</span></div><div class="line"><a name="l02273"></a><span class="lineno"> 2273</span>&#160;<span class="comment"> *                          selected stream</span></div><div class="line"><a name="l02274"></a><span class="lineno"> 2274</span>&#160;<span class="comment"> * @param flags             flags; none are currently defined</span></div><div class="line"><a name="l02275"></a><span class="lineno"> 2275</span>&#160;<span class="comment"> * @return  the non-negative stream number in case of success,</span></div><div class="line"><a name="l02276"></a><span class="lineno"> 2276</span>&#160;<span class="comment"> *          AVERROR_STREAM_NOT_FOUND if no stream with the requested type</span></div><div class="line"><a name="l02277"></a><span class="lineno"> 2277</span>&#160;<span class="comment"> *          could be found,</span></div><div class="line"><a name="l02278"></a><span class="lineno"> 2278</span>&#160;<span class="comment"> *          AVERROR_DECODER_NOT_FOUND if streams were found but no decoder</span></div><div class="line"><a name="l02279"></a><span class="lineno"> 2279</span>&#160;<span class="comment"> * @note  If av_find_best_stream returns successfully and decoder_ret is not</span></div><div class="line"><a name="l02280"></a><span class="lineno"> 2280</span>&#160;<span class="comment"> *        NULL, then *decoder_ret is guaranteed to be set to a valid AVCodec.</span></div><div class="line"><a name="l02281"></a><span class="lineno"> 2281</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02282"></a><span class="lineno"> 2282</span>&#160;<span class="keywordtype">int</span> <a class="code" href="group__lavf__decoding.html#gaa6fa468c922ff5c60a6021dcac09aff9">av_find_best_stream</a>(<a class="code" href="structAVFormatContext.html">AVFormatContext</a> *ic,</div><div class="line"><a name="l02283"></a><span class="lineno"> 2283</span>&#160;                        <span class="keyword">enum</span> <a class="code" href="group__lavu__misc.html#ga9a84bba4713dfced21a1a56163be1f48">AVMediaType</a> type,</div><div class="line"><a name="l02284"></a><span class="lineno"> 2284</span>&#160;                        <span class="keywordtype">int</span> wanted_stream_nb,</div><div class="line"><a name="l02285"></a><span class="lineno"> 2285</span>&#160;                        <span class="keywordtype">int</span> related_stream,</div><div class="line"><a name="l02286"></a><span class="lineno"> 2286</span>&#160;                        <a class="code" href="structAVCodec.html">AVCodec</a> **decoder_ret,</div><div class="line"><a name="l02287"></a><span class="lineno"> 2287</span>&#160;                        <span class="keywordtype">int</span> flags);</div><div class="line"><a name="l02288"></a><span class="lineno"> 2288</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02289"></a><span class="lineno"> 2289</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02290"></a><span class="lineno"> 2290</span>&#160;<span class="comment"> * Return the next frame of a stream.</span></div><div class="line"><a name="l02291"></a><span class="lineno"> 2291</span>&#160;<span class="comment"> * This function returns what is stored in the file, and does not validate</span></div><div class="line"><a name="l02292"></a><span class="lineno"> 2292</span>&#160;<span class="comment"> * that what is there are valid frames for the decoder. It will split what is</span></div><div class="line"><a name="l02293"></a><span class="lineno"> 2293</span>&#160;<span class="comment"> * stored in the file into frames and return one for each call. It will not</span></div><div class="line"><a name="l02294"></a><span class="lineno"> 2294</span>&#160;<span class="comment"> * omit invalid data between valid frames so as to give the decoder the maximum</span></div><div class="line"><a name="l02295"></a><span class="lineno"> 2295</span>&#160;<span class="comment"> * information possible for decoding.</span></div><div class="line"><a name="l02296"></a><span class="lineno"> 2296</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02297"></a><span class="lineno"> 2297</span>&#160;<span class="comment"> * If pkt-&gt;buf is NULL, then the packet is valid until the next</span></div><div class="line"><a name="l02298"></a><span class="lineno"> 2298</span>&#160;<span class="comment"> * av_read_frame() or until avformat_close_input(). Otherwise the packet</span></div><div class="line"><a name="l02299"></a><span class="lineno"> 2299</span>&#160;<span class="comment"> * is valid indefinitely. In both cases the packet must be freed with</span></div><div class="line"><a name="l02300"></a><span class="lineno"> 2300</span>&#160;<span class="comment"> * av_packet_unref when it is no longer needed. For video, the packet contains</span></div><div class="line"><a name="l02301"></a><span class="lineno"> 2301</span>&#160;<span class="comment"> * exactly one frame. For audio, it contains an integer number of frames if each</span></div><div class="line"><a name="l02302"></a><span class="lineno"> 2302</span>&#160;<span class="comment"> * frame has a known fixed size (e.g. PCM or ADPCM data). If the audio frames</span></div><div class="line"><a name="l02303"></a><span class="lineno"> 2303</span>&#160;<span class="comment"> * have a variable size (e.g. MPEG audio), then it contains one frame.</span></div><div class="line"><a name="l02304"></a><span class="lineno"> 2304</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02305"></a><span class="lineno"> 2305</span>&#160;<span class="comment"> * pkt-&gt;pts, pkt-&gt;dts and pkt-&gt;duration are always set to correct</span></div><div class="line"><a name="l02306"></a><span class="lineno"> 2306</span>&#160;<span class="comment"> * values in AVStream.time_base units (and guessed if the format cannot</span></div><div class="line"><a name="l02307"></a><span class="lineno"> 2307</span>&#160;<span class="comment"> * provide them). pkt-&gt;pts can be AV_NOPTS_VALUE if the video format</span></div><div class="line"><a name="l02308"></a><span class="lineno"> 2308</span>&#160;<span class="comment"> * has B-frames, so it is better to rely on pkt-&gt;dts if you do not</span></div><div class="line"><a name="l02309"></a><span class="lineno"> 2309</span>&#160;<span class="comment"> * decompress the payload.</span></div><div class="line"><a name="l02310"></a><span class="lineno"> 2310</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02311"></a><span class="lineno"> 2311</span>&#160;<span class="comment"> * @return 0 if OK, &lt; 0 on error or end of file</span></div><div class="line"><a name="l02312"></a><span class="lineno"> 2312</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02313"></a><span class="lineno"> 2313</span>&#160;<span class="keywordtype">int</span> <a class="code" href="group__lavf__decoding.html#ga4fdb3084415a82e3810de6ee60e46a61">av_read_frame</a>(<a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s, <a class="code" href="structAVPacket.html">AVPacket</a> *<a class="code" href="demuxing__decoding_8c.html#a3d4c6562f0b27cf0cacbbea5c038c090">pkt</a>);</div><div class="line"><a name="l02314"></a><span class="lineno"> 2314</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02315"></a><span class="lineno"> 2315</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02316"></a><span class="lineno"> 2316</span>&#160;<span class="comment"> * Seek to the keyframe at timestamp.</span></div><div class="line"><a name="l02317"></a><span class="lineno"> 2317</span>&#160;<span class="comment"> * &#39;timestamp&#39; in &#39;stream_index&#39;.</span></div><div class="line"><a name="l02318"></a><span class="lineno"> 2318</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02319"></a><span class="lineno"> 2319</span>&#160;<span class="comment"> * @param s media file handle</span></div><div class="line"><a name="l02320"></a><span class="lineno"> 2320</span>&#160;<span class="comment"> * @param stream_index If stream_index is (-1), a default</span></div><div class="line"><a name="l02321"></a><span class="lineno"> 2321</span>&#160;<span class="comment"> * stream is selected, and timestamp is automatically converted</span></div><div class="line"><a name="l02322"></a><span class="lineno"> 2322</span>&#160;<span class="comment"> * from AV_TIME_BASE units to the stream specific time_base.</span></div><div class="line"><a name="l02323"></a><span class="lineno"> 2323</span>&#160;<span class="comment"> * @param timestamp Timestamp in AVStream.time_base units</span></div><div class="line"><a name="l02324"></a><span class="lineno"> 2324</span>&#160;<span class="comment"> *        or, if no stream is specified, in AV_TIME_BASE units.</span></div><div class="line"><a name="l02325"></a><span class="lineno"> 2325</span>&#160;<span class="comment"> * @param flags flags which select direction and seeking mode</span></div><div class="line"><a name="l02326"></a><span class="lineno"> 2326</span>&#160;<span class="comment"> * @return &gt;= 0 on success</span></div><div class="line"><a name="l02327"></a><span class="lineno"> 2327</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02328"></a><span class="lineno"> 2328</span>&#160;<span class="keywordtype">int</span> <a class="code" href="group__lavf__decoding.html#gaa23f7619d8d4ea0857065d9979c75ac8">av_seek_frame</a>(<a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s, <span class="keywordtype">int</span> stream_index, int64_t timestamp,</div><div class="line"><a name="l02329"></a><span class="lineno"> 2329</span>&#160;                  <span class="keywordtype">int</span> flags);</div><div class="line"><a name="l02330"></a><span class="lineno"> 2330</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02331"></a><span class="lineno"> 2331</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02332"></a><span class="lineno"> 2332</span>&#160;<span class="comment"> * Seek to timestamp ts.</span></div><div class="line"><a name="l02333"></a><span class="lineno"> 2333</span>&#160;<span class="comment"> * Seeking will be done so that the point from which all active streams</span></div><div class="line"><a name="l02334"></a><span class="lineno"> 2334</span>&#160;<span class="comment"> * can be presented successfully will be closest to ts and within min/max_ts.</span></div><div class="line"><a name="l02335"></a><span class="lineno"> 2335</span>&#160;<span class="comment"> * Active streams are all streams that have AVStream.discard &lt; AVDISCARD_ALL.</span></div><div class="line"><a name="l02336"></a><span class="lineno"> 2336</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02337"></a><span class="lineno"> 2337</span>&#160;<span class="comment"> * If flags contain AVSEEK_FLAG_BYTE, then all timestamps are in bytes and</span></div><div class="line"><a name="l02338"></a><span class="lineno"> 2338</span>&#160;<span class="comment"> * are the file position (this may not be supported by all demuxers).</span></div><div class="line"><a name="l02339"></a><span class="lineno"> 2339</span>&#160;<span class="comment"> * If flags contain AVSEEK_FLAG_FRAME, then all timestamps are in frames</span></div><div class="line"><a name="l02340"></a><span class="lineno"> 2340</span>&#160;<span class="comment"> * in the stream with stream_index (this may not be supported by all demuxers).</span></div><div class="line"><a name="l02341"></a><span class="lineno"> 2341</span>&#160;<span class="comment"> * Otherwise all timestamps are in units of the stream selected by stream_index</span></div><div class="line"><a name="l02342"></a><span class="lineno"> 2342</span>&#160;<span class="comment"> * or if stream_index is -1, in AV_TIME_BASE units.</span></div><div class="line"><a name="l02343"></a><span class="lineno"> 2343</span>&#160;<span class="comment"> * If flags contain AVSEEK_FLAG_ANY, then non-keyframes are treated as</span></div><div class="line"><a name="l02344"></a><span class="lineno"> 2344</span>&#160;<span class="comment"> * keyframes (this may not be supported by all demuxers).</span></div><div class="line"><a name="l02345"></a><span class="lineno"> 2345</span>&#160;<span class="comment"> * If flags contain AVSEEK_FLAG_BACKWARD, it is ignored.</span></div><div class="line"><a name="l02346"></a><span class="lineno"> 2346</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02347"></a><span class="lineno"> 2347</span>&#160;<span class="comment"> * @param s media file handle</span></div><div class="line"><a name="l02348"></a><span class="lineno"> 2348</span>&#160;<span class="comment"> * @param stream_index index of the stream which is used as time base reference</span></div><div class="line"><a name="l02349"></a><span class="lineno"> 2349</span>&#160;<span class="comment"> * @param min_ts smallest acceptable timestamp</span></div><div class="line"><a name="l02350"></a><span class="lineno"> 2350</span>&#160;<span class="comment"> * @param ts target timestamp</span></div><div class="line"><a name="l02351"></a><span class="lineno"> 2351</span>&#160;<span class="comment"> * @param max_ts largest acceptable timestamp</span></div><div class="line"><a name="l02352"></a><span class="lineno"> 2352</span>&#160;<span class="comment"> * @param flags flags</span></div><div class="line"><a name="l02353"></a><span class="lineno"> 2353</span>&#160;<span class="comment"> * @return &gt;=0 on success, error code otherwise</span></div><div class="line"><a name="l02354"></a><span class="lineno"> 2354</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02355"></a><span class="lineno"> 2355</span>&#160;<span class="comment"> * @note This is part of the new seek API which is still under construction.</span></div><div class="line"><a name="l02356"></a><span class="lineno"> 2356</span>&#160;<span class="comment"> *       Thus do not use this yet. It may change at any time, do not expect</span></div><div class="line"><a name="l02357"></a><span class="lineno"> 2357</span>&#160;<span class="comment"> *       ABI compatibility yet!</span></div><div class="line"><a name="l02358"></a><span class="lineno"> 2358</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02359"></a><span class="lineno"> 2359</span>&#160;<span class="keywordtype">int</span> <a class="code" href="group__lavf__decoding.html#ga3b40fc8d2fda6992ae6ea2567d71ba30">avformat_seek_file</a>(<a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s, <span class="keywordtype">int</span> stream_index, int64_t min_ts, int64_t ts, int64_t max_ts, <span class="keywordtype">int</span> flags);</div><div class="line"><a name="l02360"></a><span class="lineno"> 2360</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02361"></a><span class="lineno"> 2361</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02362"></a><span class="lineno"> 2362</span>&#160;<span class="comment"> * Discard all internally buffered data. This can be useful when dealing with</span></div><div class="line"><a name="l02363"></a><span class="lineno"> 2363</span>&#160;<span class="comment"> * discontinuities in the byte stream. Generally works only with formats that</span></div><div class="line"><a name="l02364"></a><span class="lineno"> 2364</span>&#160;<span class="comment"> * can resync. This includes headerless formats like MPEG-TS/TS but should also</span></div><div class="line"><a name="l02365"></a><span class="lineno"> 2365</span>&#160;<span class="comment"> * work with NUT, Ogg and in a limited way AVI for example.</span></div><div class="line"><a name="l02366"></a><span class="lineno"> 2366</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02367"></a><span class="lineno"> 2367</span>&#160;<span class="comment"> * The set of streams, the detected duration, stream parameters and codecs do</span></div><div class="line"><a name="l02368"></a><span class="lineno"> 2368</span>&#160;<span class="comment"> * not change when calling this function. If you want a complete reset, it&#39;s</span></div><div class="line"><a name="l02369"></a><span class="lineno"> 2369</span>&#160;<span class="comment"> * better to open a new AVFormatContext.</span></div><div class="line"><a name="l02370"></a><span class="lineno"> 2370</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02371"></a><span class="lineno"> 2371</span>&#160;<span class="comment"> * This does not flush the AVIOContext (s-&gt;pb). If necessary, call</span></div><div class="line"><a name="l02372"></a><span class="lineno"> 2372</span>&#160;<span class="comment"> * avio_flush(s-&gt;pb) before calling this function.</span></div><div class="line"><a name="l02373"></a><span class="lineno"> 2373</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02374"></a><span class="lineno"> 2374</span>&#160;<span class="comment"> * @param s media file handle</span></div><div class="line"><a name="l02375"></a><span class="lineno"> 2375</span>&#160;<span class="comment"> * @return &gt;=0 on success, error code otherwise</span></div><div class="line"><a name="l02376"></a><span class="lineno"> 2376</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02377"></a><span class="lineno"> 2377</span>&#160;<span class="keywordtype">int</span> <a class="code" href="group__lavf__decoding.html#gaa03a82c5fd4fe3af312d229ca94cd6f3">avformat_flush</a>(<a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s);</div><div class="line"><a name="l02378"></a><span class="lineno"> 2378</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02379"></a><span class="lineno"> 2379</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02380"></a><span class="lineno"> 2380</span>&#160;<span class="comment"> * Start playing a network-based stream (e.g. RTSP stream) at the</span></div><div class="line"><a name="l02381"></a><span class="lineno"> 2381</span>&#160;<span class="comment"> * current position.</span></div><div class="line"><a name="l02382"></a><span class="lineno"> 2382</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02383"></a><span class="lineno"> 2383</span>&#160;<span class="keywordtype">int</span> <a class="code" href="group__lavf__decoding.html#ga7494bb63a59e79e9fe88eb1682d4d7b3">av_read_play</a>(<a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s);</div><div class="line"><a name="l02384"></a><span class="lineno"> 2384</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02385"></a><span class="lineno"> 2385</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02386"></a><span class="lineno"> 2386</span>&#160;<span class="comment"> * Pause a network-based stream (e.g. RTSP stream).</span></div><div class="line"><a name="l02387"></a><span class="lineno"> 2387</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02388"></a><span class="lineno"> 2388</span>&#160;<span class="comment"> * Use av_read_play() to resume it.</span></div><div class="line"><a name="l02389"></a><span class="lineno"> 2389</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02390"></a><span class="lineno"> 2390</span>&#160;<span class="keywordtype">int</span> <a class="code" href="group__lavf__decoding.html#ga27db687592d99f25ccf81a3b3ee8da9c">av_read_pause</a>(<a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s);</div><div class="line"><a name="l02391"></a><span class="lineno"> 2391</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02392"></a><span class="lineno"> 2392</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02393"></a><span class="lineno"> 2393</span>&#160;<span class="comment"> * Close an opened input AVFormatContext. Free it and all its contents</span></div><div class="line"><a name="l02394"></a><span class="lineno"> 2394</span>&#160;<span class="comment"> * and set *s to NULL.</span></div><div class="line"><a name="l02395"></a><span class="lineno"> 2395</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02396"></a><span class="lineno"> 2396</span>&#160;<span class="keywordtype">void</span> <a class="code" href="group__lavf__decoding.html#gae804b99aec044690162b8b9b110236a4">avformat_close_input</a>(<a class="code" href="structAVFormatContext.html">AVFormatContext</a> **s);<span class="comment"></span></div><div class="line"><a name="l02397"></a><span class="lineno"> 2397</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02398"></a><span class="lineno"> 2398</span>&#160;<span class="comment"> * @}</span></div><div class="line"><a name="l02399"></a><span class="lineno"> 2399</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02400"></a><span class="lineno"> 2400</span>&#160;</div><div class="line"><a name="l02401"></a><span class="lineno"> 2401</span>&#160;<span class="preprocessor">#define AVSEEK_FLAG_BACKWARD 1 </span><span class="comment">///&lt; seek backward</span></div><div class="line"><a name="l02402"></a><span class="lineno"> 2402</span>&#160;<span class="comment"></span>#define AVSEEK_FLAG_BYTE     2 <span class="comment">///&lt; seeking based on position in bytes</span></div><div class="line"><a name="l02403"></a><span class="lineno"> 2403</span>&#160;<span class="comment"></span>#define AVSEEK_FLAG_ANY      4 <span class="comment">///&lt; seek to any frame, even non-keyframes</span></div><div class="line"><a name="l02404"></a><span class="lineno"> 2404</span>&#160;<span class="comment"></span>#define AVSEEK_FLAG_FRAME    8 <span class="comment">///&lt; seeking based on frame number</span></div><div class="line"><a name="l02405"></a><span class="lineno"> 2405</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02406"></a><span class="lineno"> 2406</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02407"></a><span class="lineno"> 2407</span>&#160;<span class="comment"> * @addtogroup lavf_encoding</span></div><div class="line"><a name="l02408"></a><span class="lineno"> 2408</span>&#160;<span class="comment"> * @{</span></div><div class="line"><a name="l02409"></a><span class="lineno"> 2409</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02410"></a><span class="lineno"> 2410</span>&#160;</div><div class="line"><a name="l02411"></a><span class="lineno"><a class="line" href="avformat_8h.html#ac736f8f4afc930ca1cda0b43638cc678"> 2411</a></span>&#160;<span class="preprocessor">#define AVSTREAM_INIT_IN_WRITE_HEADER 0 </span><span class="comment">///&lt; stream parameters initialized in avformat_write_header</span></div><div class="line"><a name="l02412"></a><span class="lineno"><a class="line" href="avformat_8h.html#a754de906e0da116c009846547741f869"> 2412</a></span>&#160;<span class="comment"></span>#define AVSTREAM_INIT_IN_INIT_OUTPUT  1 <span class="comment">///&lt; stream parameters initialized in avformat_init_output</span></div><div class="line"><a name="l02413"></a><span class="lineno"><a class="line" href="avformat_8h.html#a998c3af80d050fd3d4f6a209fd5a87bc"> 2413</a></span>&#160;<span class="comment"></span></div><div class="line"><a name="l02414"></a><span class="lineno"><a class="line" href="avformat_8h.html#ab83ca408a574b40c76f681b616096fc8"> 2414</a></span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02415"></a><span class="lineno"> 2415</span>&#160;<span class="comment"> * Allocate the stream private data and write the stream header to</span></div><div class="line"><a name="l02416"></a><span class="lineno"> 2416</span>&#160;<span class="comment"> * an output media file.</span></div><div class="line"><a name="l02417"></a><span class="lineno"> 2417</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02418"></a><span class="lineno"> 2418</span>&#160;<span class="comment"> * @param s Media file handle, must be allocated with avformat_alloc_context().</span></div><div class="line"><a name="l02419"></a><span class="lineno"> 2419</span>&#160;<span class="comment"> *          Its oformat field must be set to the desired output format;</span></div><div class="line"><a name="l02420"></a><span class="lineno"> 2420</span>&#160;<span class="comment"> *          Its pb field must be set to an already opened AVIOContext.</span></div><div class="line"><a name="l02421"></a><span class="lineno"><a class="line" href="group__lavf__encoding.html#ga5396ff79e3c1ec7220765499f2efc74d"> 2421</a></span>&#160;<span class="comment"> * @param options  An AVDictionary filled with AVFormatContext and muxer-private options.</span></div><div class="line"><a name="l02422"></a><span class="lineno"><a class="line" href="group__lavf__encoding.html#ga5268e4fbbb73b5ed1e4083f44f565ffd"> 2422</a></span>&#160;<span class="comment"> *                 On return this parameter will be destroyed and replaced with a dict containing</span></div><div class="line"><a name="l02423"></a><span class="lineno"> 2423</span>&#160;<span class="comment"> *                 options that were not found. May be NULL.</span></div><div class="line"><a name="l02424"></a><span class="lineno"> 2424</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02425"></a><span class="lineno"> 2425</span>&#160;<span class="comment"> * @return AVSTREAM_INIT_IN_WRITE_HEADER on success if the codec had not already been fully initialized in avformat_init,</span></div><div class="line"><a name="l02426"></a><span class="lineno"> 2426</span>&#160;<span class="comment"> *         AVSTREAM_INIT_IN_INIT_OUTPUT  on success if the codec had already been fully initialized in avformat_init,</span></div><div class="line"><a name="l02427"></a><span class="lineno"> 2427</span>&#160;<span class="comment"> *         negative AVERROR on failure.</span></div><div class="line"><a name="l02428"></a><span class="lineno"> 2428</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02429"></a><span class="lineno"> 2429</span>&#160;<span class="comment"> * @see av_opt_find, av_dict_set, avio_open, av_oformat_next, avformat_init_output.</span></div><div class="line"><a name="l02430"></a><span class="lineno"> 2430</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02431"></a><span class="lineno"> 2431</span>&#160;<a class="code" href="attributes_8h.html#a93f17e0f0b53a66e7b5eceb3dff2918f">av_warn_unused_result</a></div><div class="line"><a name="l02432"></a><span class="lineno"> 2432</span>&#160;<span class="keywordtype">int</span> <a class="code" href="group__lavf__encoding.html#ga18b7b10bb5b94c4842de18166bc677cb">avformat_write_header</a>(<a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s, <a class="code" href="group__lavu__dict.html#ga1d7cc0833bee918994a600556410315f">AVDictionary</a> **options);</div><div class="line"><a name="l02433"></a><span class="lineno"> 2433</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02434"></a><span class="lineno"> 2434</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02435"></a><span class="lineno"> 2435</span>&#160;<span class="comment"> * Allocate the stream private data and initialize the codec, but do not write the header.</span></div><div class="line"><a name="l02436"></a><span class="lineno"> 2436</span>&#160;<span class="comment"> * May optionally be used before avformat_write_header to initialize stream parameters</span></div><div class="line"><a name="l02437"></a><span class="lineno"> 2437</span>&#160;<span class="comment"> * before actually writing the header.</span></div><div class="line"><a name="l02438"></a><span class="lineno"> 2438</span>&#160;<span class="comment"> * If using this function, do not pass the same options to avformat_write_header.</span></div><div class="line"><a name="l02439"></a><span class="lineno"> 2439</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02440"></a><span class="lineno"> 2440</span>&#160;<span class="comment"> * @param s Media file handle, must be allocated with avformat_alloc_context().</span></div><div class="line"><a name="l02441"></a><span class="lineno"> 2441</span>&#160;<span class="comment"> *          Its oformat field must be set to the desired output format;</span></div><div class="line"><a name="l02442"></a><span class="lineno"> 2442</span>&#160;<span class="comment"> *          Its pb field must be set to an already opened AVIOContext.</span></div><div class="line"><a name="l02443"></a><span class="lineno"> 2443</span>&#160;<span class="comment"> * @param options  An AVDictionary filled with AVFormatContext and muxer-private options.</span></div><div class="line"><a name="l02444"></a><span class="lineno"> 2444</span>&#160;<span class="comment"> *                 On return this parameter will be destroyed and replaced with a dict containing</span></div><div class="line"><a name="l02445"></a><span class="lineno"> 2445</span>&#160;<span class="comment"> *                 options that were not found. May be NULL.</span></div><div class="line"><a name="l02446"></a><span class="lineno"> 2446</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02447"></a><span class="lineno"> 2447</span>&#160;<span class="comment"> * @return AVSTREAM_INIT_IN_WRITE_HEADER on success if the codec requires avformat_write_header to fully initialize,</span></div><div class="line"><a name="l02448"></a><span class="lineno"> 2448</span>&#160;<span class="comment"> *         AVSTREAM_INIT_IN_INIT_OUTPUT  on success if the codec has been fully initialized,</span></div><div class="line"><a name="l02449"></a><span class="lineno"> 2449</span>&#160;<span class="comment"> *         negative AVERROR on failure.</span></div><div class="line"><a name="l02450"></a><span class="lineno"> 2450</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02451"></a><span class="lineno"> 2451</span>&#160;<span class="comment"> * @see av_opt_find, av_dict_set, avio_open, av_oformat_next, avformat_write_header.</span></div><div class="line"><a name="l02452"></a><span class="lineno"> 2452</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02453"></a><span class="lineno"> 2453</span>&#160;<a class="code" href="attributes_8h.html#a93f17e0f0b53a66e7b5eceb3dff2918f">av_warn_unused_result</a></div><div class="line"><a name="l02454"></a><span class="lineno"> 2454</span>&#160;<span class="keywordtype">int</span> <a class="code" href="group__lavf__encoding.html#ga169cfa28508e22e138c5b99be8517ea4">avformat_init_output</a>(<a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s, <a class="code" href="group__lavu__dict.html#ga1d7cc0833bee918994a600556410315f">AVDictionary</a> **options);</div><div class="line"><a name="l02455"></a><span class="lineno"> 2455</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02456"></a><span class="lineno"> 2456</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02457"></a><span class="lineno"> 2457</span>&#160;<span class="comment"> * Write a packet to an output media file.</span></div><div class="line"><a name="l02458"></a><span class="lineno"> 2458</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02459"></a><span class="lineno"> 2459</span>&#160;<span class="comment"> * This function passes the packet directly to the muxer, without any buffering</span></div><div class="line"><a name="l02460"></a><span class="lineno"> 2460</span>&#160;<span class="comment"> * or reordering. The caller is responsible for correctly interleaving the</span></div><div class="line"><a name="l02461"></a><span class="lineno"> 2461</span>&#160;<span class="comment"> * packets if the format requires it. Callers that want libavformat to handle</span></div><div class="line"><a name="l02462"></a><span class="lineno"> 2462</span>&#160;<span class="comment"> * the interleaving should call av_interleaved_write_frame() instead of this</span></div><div class="line"><a name="l02463"></a><span class="lineno"> 2463</span>&#160;<span class="comment"> * function.</span></div><div class="line"><a name="l02464"></a><span class="lineno"> 2464</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02465"></a><span class="lineno"> 2465</span>&#160;<span class="comment"> * @param s media file handle</span></div><div class="line"><a name="l02466"></a><span class="lineno"> 2466</span>&#160;<span class="comment"> * @param pkt The packet containing the data to be written. Note that unlike</span></div><div class="line"><a name="l02467"></a><span class="lineno"> 2467</span>&#160;<span class="comment"> *            av_interleaved_write_frame(), this function does not take</span></div><div class="line"><a name="l02468"></a><span class="lineno"> 2468</span>&#160;<span class="comment"> *            ownership of the packet passed to it (though some muxers may make</span></div><div class="line"><a name="l02469"></a><span class="lineno"> 2469</span>&#160;<span class="comment"> *            an internal reference to the input packet).</span></div><div class="line"><a name="l02470"></a><span class="lineno"> 2470</span>&#160;<span class="comment"> *            &lt;br&gt;</span></div><div class="line"><a name="l02471"></a><span class="lineno"> 2471</span>&#160;<span class="comment"> *            This parameter can be NULL (at any time, not just at the end), in</span></div><div class="line"><a name="l02472"></a><span class="lineno"> 2472</span>&#160;<span class="comment"> *            order to immediately flush data buffered within the muxer, for</span></div><div class="line"><a name="l02473"></a><span class="lineno"> 2473</span>&#160;<span class="comment"> *            muxers that buffer up data internally before writing it to the</span></div><div class="line"><a name="l02474"></a><span class="lineno"> 2474</span>&#160;<span class="comment"> *            output.</span></div><div class="line"><a name="l02475"></a><span class="lineno"> 2475</span>&#160;<span class="comment"> *            &lt;br&gt;</span></div><div class="line"><a name="l02476"></a><span class="lineno"> 2476</span>&#160;<span class="comment"> *            Packet&#39;s @ref AVPacket.stream_index &quot;stream_index&quot; field must be</span></div><div class="line"><a name="l02477"></a><span class="lineno"> 2477</span>&#160;<span class="comment"> *            set to the index of the corresponding stream in @ref</span></div><div class="line"><a name="l02478"></a><span class="lineno"> 2478</span>&#160;<span class="comment"> *            AVFormatContext.streams &quot;s-&gt;streams&quot;.</span></div><div class="line"><a name="l02479"></a><span class="lineno"> 2479</span>&#160;<span class="comment"> *            &lt;br&gt;</span></div><div class="line"><a name="l02480"></a><span class="lineno"> 2480</span>&#160;<span class="comment"> *            The timestamps (@ref AVPacket.pts &quot;pts&quot;, @ref AVPacket.dts &quot;dts&quot;)</span></div><div class="line"><a name="l02481"></a><span class="lineno"> 2481</span>&#160;<span class="comment"> *            must be set to correct values in the stream&#39;s timebase (unless the</span></div><div class="line"><a name="l02482"></a><span class="lineno"> 2482</span>&#160;<span class="comment"> *            output format is flagged with the AVFMT_NOTIMESTAMPS flag, then</span></div><div class="line"><a name="l02483"></a><span class="lineno"> 2483</span>&#160;<span class="comment"> *            they can be set to AV_NOPTS_VALUE).</span></div><div class="line"><a name="l02484"></a><span class="lineno"> 2484</span>&#160;<span class="comment"> *            The dts for subsequent packets passed to this function must be strictly</span></div><div class="line"><a name="l02485"></a><span class="lineno"> 2485</span>&#160;<span class="comment"> *            increasing when compared in their respective timebases (unless the</span></div><div class="line"><a name="l02486"></a><span class="lineno"> 2486</span>&#160;<span class="comment"> *            output format is flagged with the AVFMT_TS_NONSTRICT, then they</span></div><div class="line"><a name="l02487"></a><span class="lineno"> 2487</span>&#160;<span class="comment"> *            merely have to be nondecreasing).  @ref AVPacket.duration</span></div><div class="line"><a name="l02488"></a><span class="lineno"> 2488</span>&#160;<span class="comment"> *            &quot;duration&quot;) should also be set if known.</span></div><div class="line"><a name="l02489"></a><span class="lineno"> 2489</span>&#160;<span class="comment"> * @return &lt; 0 on error, = 0 if OK, 1 if flushed and there is no more data to flush</span></div><div class="line"><a name="l02490"></a><span class="lineno"> 2490</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02491"></a><span class="lineno"> 2491</span>&#160;<span class="comment"> * @see av_interleaved_write_frame()</span></div><div class="line"><a name="l02492"></a><span class="lineno"> 2492</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02493"></a><span class="lineno"> 2493</span>&#160;<span class="keywordtype">int</span> <a class="code" href="group__lavf__encoding.html#gaa85cc1774f18f306cd20a40fc50d0b36">av_write_frame</a>(<a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s, <a class="code" href="structAVPacket.html">AVPacket</a> *<a class="code" href="demuxing__decoding_8c.html#a3d4c6562f0b27cf0cacbbea5c038c090">pkt</a>);</div><div class="line"><a name="l02494"></a><span class="lineno"> 2494</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02495"></a><span class="lineno"> 2495</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02496"></a><span class="lineno"> 2496</span>&#160;<span class="comment"> * Write a packet to an output media file ensuring correct interleaving.</span></div><div class="line"><a name="l02497"></a><span class="lineno"> 2497</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02498"></a><span class="lineno"> 2498</span>&#160;<span class="comment"> * This function will buffer the packets internally as needed to make sure the</span></div><div class="line"><a name="l02499"></a><span class="lineno"> 2499</span>&#160;<span class="comment"> * packets in the output file are properly interleaved in the order of</span></div><div class="line"><a name="l02500"></a><span class="lineno"> 2500</span>&#160;<span class="comment"> * increasing dts. Callers doing their own interleaving should call</span></div><div class="line"><a name="l02501"></a><span class="lineno"> 2501</span>&#160;<span class="comment"> * av_write_frame() instead of this function.</span></div><div class="line"><a name="l02502"></a><span class="lineno"> 2502</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02503"></a><span class="lineno"> 2503</span>&#160;<span class="comment"> * Using this function instead of av_write_frame() can give muxers advance</span></div><div class="line"><a name="l02504"></a><span class="lineno"> 2504</span>&#160;<span class="comment"> * knowledge of future packets, improving e.g. the behaviour of the mp4</span></div><div class="line"><a name="l02505"></a><span class="lineno"> 2505</span>&#160;<span class="comment"> * muxer for VFR content in fragmenting mode.</span></div><div class="line"><a name="l02506"></a><span class="lineno"> 2506</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02507"></a><span class="lineno"> 2507</span>&#160;<span class="comment"> * @param s media file handle</span></div><div class="line"><a name="l02508"></a><span class="lineno"> 2508</span>&#160;<span class="comment"> * @param pkt The packet containing the data to be written.</span></div><div class="line"><a name="l02509"></a><span class="lineno"> 2509</span>&#160;<span class="comment"> *            &lt;br&gt;</span></div><div class="line"><a name="l02510"></a><span class="lineno"> 2510</span>&#160;<span class="comment"> *            If the packet is reference-counted, this function will take</span></div><div class="line"><a name="l02511"></a><span class="lineno"> 2511</span>&#160;<span class="comment"> *            ownership of this reference and unreference it later when it sees</span></div><div class="line"><a name="l02512"></a><span class="lineno"> 2512</span>&#160;<span class="comment"> *            fit.</span></div><div class="line"><a name="l02513"></a><span class="lineno"> 2513</span>&#160;<span class="comment"> *            The caller must not access the data through this reference after</span></div><div class="line"><a name="l02514"></a><span class="lineno"> 2514</span>&#160;<span class="comment"> *            this function returns. If the packet is not reference-counted,</span></div><div class="line"><a name="l02515"></a><span class="lineno"> 2515</span>&#160;<span class="comment"> *            libavformat will make a copy.</span></div><div class="line"><a name="l02516"></a><span class="lineno"> 2516</span>&#160;<span class="comment"> *            &lt;br&gt;</span></div><div class="line"><a name="l02517"></a><span class="lineno"> 2517</span>&#160;<span class="comment"> *            This parameter can be NULL (at any time, not just at the end), to</span></div><div class="line"><a name="l02518"></a><span class="lineno"> 2518</span>&#160;<span class="comment"> *            flush the interleaving queues.</span></div><div class="line"><a name="l02519"></a><span class="lineno"> 2519</span>&#160;<span class="comment"> *            &lt;br&gt;</span></div><div class="line"><a name="l02520"></a><span class="lineno"> 2520</span>&#160;<span class="comment"> *            Packet&#39;s @ref AVPacket.stream_index &quot;stream_index&quot; field must be</span></div><div class="line"><a name="l02521"></a><span class="lineno"> 2521</span>&#160;<span class="comment"> *            set to the index of the corresponding stream in @ref</span></div><div class="line"><a name="l02522"></a><span class="lineno"> 2522</span>&#160;<span class="comment"> *            AVFormatContext.streams &quot;s-&gt;streams&quot;.</span></div><div class="line"><a name="l02523"></a><span class="lineno"> 2523</span>&#160;<span class="comment"> *            &lt;br&gt;</span></div><div class="line"><a name="l02524"></a><span class="lineno"> 2524</span>&#160;<span class="comment"> *            The timestamps (@ref AVPacket.pts &quot;pts&quot;, @ref AVPacket.dts &quot;dts&quot;)</span></div><div class="line"><a name="l02525"></a><span class="lineno"> 2525</span>&#160;<span class="comment"> *            must be set to correct values in the stream&#39;s timebase (unless the</span></div><div class="line"><a name="l02526"></a><span class="lineno"> 2526</span>&#160;<span class="comment"> *            output format is flagged with the AVFMT_NOTIMESTAMPS flag, then</span></div><div class="line"><a name="l02527"></a><span class="lineno"> 2527</span>&#160;<span class="comment"> *            they can be set to AV_NOPTS_VALUE).</span></div><div class="line"><a name="l02528"></a><span class="lineno"> 2528</span>&#160;<span class="comment"> *            The dts for subsequent packets in one stream must be strictly</span></div><div class="line"><a name="l02529"></a><span class="lineno"> 2529</span>&#160;<span class="comment"> *            increasing (unless the output format is flagged with the</span></div><div class="line"><a name="l02530"></a><span class="lineno"> 2530</span>&#160;<span class="comment"> *            AVFMT_TS_NONSTRICT, then they merely have to be nondecreasing).</span></div><div class="line"><a name="l02531"></a><span class="lineno"> 2531</span>&#160;<span class="comment"> *            @ref AVPacket.duration &quot;duration&quot;) should also be set if known.</span></div><div class="line"><a name="l02532"></a><span class="lineno"> 2532</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02533"></a><span class="lineno"> 2533</span>&#160;<span class="comment"> * @return 0 on success, a negative AVERROR on error. Libavformat will always</span></div><div class="line"><a name="l02534"></a><span class="lineno"> 2534</span>&#160;<span class="comment"> *         take care of freeing the packet, even if this function fails.</span></div><div class="line"><a name="l02535"></a><span class="lineno"> 2535</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02536"></a><span class="lineno"> 2536</span>&#160;<span class="comment"> * @see av_write_frame(), AVFormatContext.max_interleave_delta</span></div><div class="line"><a name="l02537"></a><span class="lineno"> 2537</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02538"></a><span class="lineno"> 2538</span>&#160;<span class="keywordtype">int</span> <a class="code" href="group__lavf__encoding.html#ga37352ed2c63493c38219d935e71db6c1">av_interleaved_write_frame</a>(<a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s, <a class="code" href="structAVPacket.html">AVPacket</a> *<a class="code" href="demuxing__decoding_8c.html#a3d4c6562f0b27cf0cacbbea5c038c090">pkt</a>);</div><div class="line"><a name="l02539"></a><span class="lineno"> 2539</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02540"></a><span class="lineno"> 2540</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02541"></a><span class="lineno"> 2541</span>&#160;<span class="comment"> * Write an uncoded frame to an output media file.</span></div><div class="line"><a name="l02542"></a><span class="lineno"> 2542</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02543"></a><span class="lineno"> 2543</span>&#160;<span class="comment"> * The frame must be correctly interleaved according to the container</span></div><div class="line"><a name="l02544"></a><span class="lineno"> 2544</span>&#160;<span class="comment"> * specification; if not, then av_interleaved_write_frame() must be used.</span></div><div class="line"><a name="l02545"></a><span class="lineno"> 2545</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02546"></a><span class="lineno"> 2546</span>&#160;<span class="comment"> * See av_interleaved_write_frame() for details.</span></div><div class="line"><a name="l02547"></a><span class="lineno"> 2547</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02548"></a><span class="lineno"> 2548</span>&#160;<span class="keywordtype">int</span> <a class="code" href="group__lavf__encoding.html#gaab766dccdff1bf323a2fc604e723b441">av_write_uncoded_frame</a>(<a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s, <span class="keywordtype">int</span> stream_index,</div><div class="line"><a name="l02549"></a><span class="lineno"> 2549</span>&#160;                           <a class="code" href="structAVFrame.html">AVFrame</a> *<a class="code" href="demuxing__decoding_8c.html#ad7d33d579a8d4241a5e643e39287a209">frame</a>);</div><div class="line"><a name="l02550"></a><span class="lineno"> 2550</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02551"></a><span class="lineno"> 2551</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02552"></a><span class="lineno"> 2552</span>&#160;<span class="comment"> * Write an uncoded frame to an output media file.</span></div><div class="line"><a name="l02553"></a><span class="lineno"> 2553</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02554"></a><span class="lineno"> 2554</span>&#160;<span class="comment"> * If the muxer supports it, this function makes it possible to write an AVFrame</span></div><div class="line"><a name="l02555"></a><span class="lineno"> 2555</span>&#160;<span class="comment"> * structure directly, without encoding it into a packet.</span></div><div class="line"><a name="l02556"></a><span class="lineno"> 2556</span>&#160;<span class="comment"> * It is mostly useful for devices and similar special muxers that use raw</span></div><div class="line"><a name="l02557"></a><span class="lineno"> 2557</span>&#160;<span class="comment"> * video or PCM data and will not serialize it into a byte stream.</span></div><div class="line"><a name="l02558"></a><span class="lineno"> 2558</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02559"></a><span class="lineno"> 2559</span>&#160;<span class="comment"> * To test whether it is possible to use it with a given muxer and stream,</span></div><div class="line"><a name="l02560"></a><span class="lineno"> 2560</span>&#160;<span class="comment"> * use av_write_uncoded_frame_query().</span></div><div class="line"><a name="l02561"></a><span class="lineno"> 2561</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02562"></a><span class="lineno"> 2562</span>&#160;<span class="comment"> * The caller gives up ownership of the frame and must not access it</span></div><div class="line"><a name="l02563"></a><span class="lineno"> 2563</span>&#160;<span class="comment"> * afterwards.</span></div><div class="line"><a name="l02564"></a><span class="lineno"> 2564</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02565"></a><span class="lineno"> 2565</span>&#160;<span class="comment"> * @return  &gt;=0 for success, a negative code on error</span></div><div class="line"><a name="l02566"></a><span class="lineno"> 2566</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02567"></a><span class="lineno"> 2567</span>&#160;<span class="keywordtype">int</span> <a class="code" href="group__lavf__encoding.html#gafe9916c601bba6827d6f9271a61260e4">av_interleaved_write_uncoded_frame</a>(<a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s, <span class="keywordtype">int</span> stream_index,</div><div class="line"><a name="l02568"></a><span class="lineno"> 2568</span>&#160;                                       <a class="code" href="structAVFrame.html">AVFrame</a> *<a class="code" href="demuxing__decoding_8c.html#ad7d33d579a8d4241a5e643e39287a209">frame</a>);</div><div class="line"><a name="l02569"></a><span class="lineno"> 2569</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02570"></a><span class="lineno"> 2570</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02571"></a><span class="lineno"> 2571</span>&#160;<span class="comment"> * Test whether a muxer supports uncoded frame.</span></div><div class="line"><a name="l02572"></a><span class="lineno"> 2572</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02573"></a><span class="lineno"> 2573</span>&#160;<span class="comment"> * @return  &gt;=0 if an uncoded frame can be written to that muxer and stream,</span></div><div class="line"><a name="l02574"></a><span class="lineno"> 2574</span>&#160;<span class="comment"> *          &lt;0 if not</span></div><div class="line"><a name="l02575"></a><span class="lineno"> 2575</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02576"></a><span class="lineno"> 2576</span>&#160;<span class="keywordtype">int</span> <a class="code" href="group__lavf__encoding.html#ga5f6bebdc8c234a5ad9740de89acb15e6">av_write_uncoded_frame_query</a>(<a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s, <span class="keywordtype">int</span> stream_index);</div><div class="line"><a name="l02577"></a><span class="lineno"> 2577</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02578"></a><span class="lineno"> 2578</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02579"></a><span class="lineno"> 2579</span>&#160;<span class="comment"> * Write the stream trailer to an output media file and free the</span></div><div class="line"><a name="l02580"></a><span class="lineno"> 2580</span>&#160;<span class="comment"> * file private data.</span></div><div class="line"><a name="l02581"></a><span class="lineno"> 2581</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02582"></a><span class="lineno"> 2582</span>&#160;<span class="comment"> * May only be called after a successful call to avformat_write_header.</span></div><div class="line"><a name="l02583"></a><span class="lineno"> 2583</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02584"></a><span class="lineno"> 2584</span>&#160;<span class="comment"> * @param s media file handle</span></div><div class="line"><a name="l02585"></a><span class="lineno"> 2585</span>&#160;<span class="comment"> * @return 0 if OK, AVERROR_xxx on error</span></div><div class="line"><a name="l02586"></a><span class="lineno"> 2586</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02587"></a><span class="lineno"> 2587</span>&#160;<span class="keywordtype">int</span> <a class="code" href="group__lavf__encoding.html#ga7f14007e7dc8f481f054b21614dfec13">av_write_trailer</a>(<a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s);</div><div class="line"><a name="l02588"></a><span class="lineno"> 2588</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02589"></a><span class="lineno"> 2589</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02590"></a><span class="lineno"> 2590</span>&#160;<span class="comment"> * Return the output format in the list of registered output formats</span></div><div class="line"><a name="l02591"></a><span class="lineno"> 2591</span>&#160;<span class="comment"> * which best matches the provided parameters, or return NULL if</span></div><div class="line"><a name="l02592"></a><span class="lineno"> 2592</span>&#160;<span class="comment"> * there is no match.</span></div><div class="line"><a name="l02593"></a><span class="lineno"> 2593</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02594"></a><span class="lineno"> 2594</span>&#160;<span class="comment"> * @param short_name if non-NULL checks if short_name matches with the</span></div><div class="line"><a name="l02595"></a><span class="lineno"> 2595</span>&#160;<span class="comment"> * names of the registered formats</span></div><div class="line"><a name="l02596"></a><span class="lineno"> 2596</span>&#160;<span class="comment"> * @param filename if non-NULL checks if filename terminates with the</span></div><div class="line"><a name="l02597"></a><span class="lineno"> 2597</span>&#160;<span class="comment"> * extensions of the registered formats</span></div><div class="line"><a name="l02598"></a><span class="lineno"> 2598</span>&#160;<span class="comment"> * @param mime_type if non-NULL checks if mime_type matches with the</span></div><div class="line"><a name="l02599"></a><span class="lineno"> 2599</span>&#160;<span class="comment"> * MIME type of the registered formats</span></div><div class="line"><a name="l02600"></a><span class="lineno"> 2600</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02601"></a><span class="lineno"> 2601</span>&#160;<a class="code" href="structAVOutputFormat.html">AVOutputFormat</a> *<a class="code" href="group__lavf__encoding.html#ga8795680bd7489e96eeb5aef5e615cacc">av_guess_format</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *short_name,</div><div class="line"><a name="l02602"></a><span class="lineno"> 2602</span>&#160;                                <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structAVProbeData.html#a0e8504127aff8af25cc9f3c6400b9651">filename</a>,</div><div class="line"><a name="l02603"></a><span class="lineno"> 2603</span>&#160;                                <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structAVProbeData.html#a20533bdafa6230d2ef8392cb7cb38382">mime_type</a>);</div><div class="line"><a name="l02604"></a><span class="lineno"> 2604</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02605"></a><span class="lineno"> 2605</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02606"></a><span class="lineno"> 2606</span>&#160;<span class="comment"> * Guess the codec ID based upon muxer and filename.</span></div><div class="line"><a name="l02607"></a><span class="lineno"> 2607</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02608"></a><span class="lineno"> 2608</span>&#160;<span class="keyword">enum</span> <a class="code" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a> <a class="code" href="group__lavf__encoding.html#gae8a1efab53a348857f209ea51037da4c">av_guess_codec</a>(<a class="code" href="structAVOutputFormat.html">AVOutputFormat</a> *fmt, <span class="keyword">const</span> <span class="keywordtype">char</span> *short_name,</div><div class="line"><a name="l02609"></a><span class="lineno"> 2609</span>&#160;                            <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structAVProbeData.html#a0e8504127aff8af25cc9f3c6400b9651">filename</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structAVProbeData.html#a20533bdafa6230d2ef8392cb7cb38382">mime_type</a>,</div><div class="line"><a name="l02610"></a><span class="lineno"> 2610</span>&#160;                            <span class="keyword">enum</span> <a class="code" href="group__lavu__misc.html#ga9a84bba4713dfced21a1a56163be1f48">AVMediaType</a> type);</div><div class="line"><a name="l02611"></a><span class="lineno"> 2611</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02612"></a><span class="lineno"> 2612</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02613"></a><span class="lineno"> 2613</span>&#160;<span class="comment"> * Get timing information for the data currently output.</span></div><div class="line"><a name="l02614"></a><span class="lineno"> 2614</span>&#160;<span class="comment"> * The exact meaning of &quot;currently output&quot; depends on the format.</span></div><div class="line"><a name="l02615"></a><span class="lineno"> 2615</span>&#160;<span class="comment"> * It is mostly relevant for devices that have an internal buffer and/or</span></div><div class="line"><a name="l02616"></a><span class="lineno"> 2616</span>&#160;<span class="comment"> * work in real time.</span></div><div class="line"><a name="l02617"></a><span class="lineno"> 2617</span>&#160;<span class="comment"> * @param s          media file handle</span></div><div class="line"><a name="l02618"></a><span class="lineno"> 2618</span>&#160;<span class="comment"> * @param stream     stream in the media file</span></div><div class="line"><a name="l02619"></a><span class="lineno"> 2619</span>&#160;<span class="comment"> * @param[out] dts   DTS of the last packet output for the stream, in stream</span></div><div class="line"><a name="l02620"></a><span class="lineno"> 2620</span>&#160;<span class="comment"> *                   time_base units</span></div><div class="line"><a name="l02621"></a><span class="lineno"> 2621</span>&#160;<span class="comment"> * @param[out] wall  absolute time when that packet whas output,</span></div><div class="line"><a name="l02622"></a><span class="lineno"> 2622</span>&#160;<span class="comment"> *                   in microsecond</span></div><div class="line"><a name="l02623"></a><span class="lineno"> 2623</span>&#160;<span class="comment"> * @return  0 if OK, AVERROR(ENOSYS) if the format does not support it</span></div><div class="line"><a name="l02624"></a><span class="lineno"> 2624</span>&#160;<span class="comment"> * Note: some formats or devices may not allow to measure dts and wall</span></div><div class="line"><a name="l02625"></a><span class="lineno"> 2625</span>&#160;<span class="comment"> * atomically.</span></div><div class="line"><a name="l02626"></a><span class="lineno"> 2626</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02627"></a><span class="lineno"> 2627</span>&#160;<span class="keywordtype">int</span> <a class="code" href="group__lavf__encoding.html#ga661ee0b2f3dbcaaef5d68f2f5d75e2d4">av_get_output_timestamp</a>(<span class="keyword">struct</span> <a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s, <span class="keywordtype">int</span> stream,</div><div class="line"><a name="l02628"></a><span class="lineno"> 2628</span>&#160;                            int64_t *dts, int64_t *wall);</div><div class="line"><a name="l02629"></a><span class="lineno"> 2629</span>&#160;</div><div class="line"><a name="l02630"></a><span class="lineno"> 2630</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02631"></a><span class="lineno"> 2631</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02632"></a><span class="lineno"> 2632</span>&#160;<span class="comment"> * @}</span></div><div class="line"><a name="l02633"></a><span class="lineno"> 2633</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02634"></a><span class="lineno"> 2634</span>&#160;</div><div class="line"><a name="l02635"></a><span class="lineno"> 2635</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02636"></a><span class="lineno"> 2636</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02637"></a><span class="lineno"> 2637</span>&#160;<span class="comment"> * @defgroup lavf_misc Utility functions</span></div><div class="line"><a name="l02638"></a><span class="lineno"> 2638</span>&#160;<span class="comment"> * @ingroup libavf</span></div><div class="line"><a name="l02639"></a><span class="lineno"> 2639</span>&#160;<span class="comment"> * @{</span></div><div class="line"><a name="l02640"></a><span class="lineno"> 2640</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02641"></a><span class="lineno"> 2641</span>&#160;<span class="comment"> * Miscellaneous utility functions related to both muxing and demuxing</span></div><div class="line"><a name="l02642"></a><span class="lineno"> 2642</span>&#160;<span class="comment"> * (or neither).</span></div><div class="line"><a name="l02643"></a><span class="lineno"> 2643</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02644"></a><span class="lineno"> 2644</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02645"></a><span class="lineno"> 2645</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02646"></a><span class="lineno"> 2646</span>&#160;<span class="comment"> * Send a nice hexadecimal dump of a buffer to the specified file stream.</span></div><div class="line"><a name="l02647"></a><span class="lineno"> 2647</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02648"></a><span class="lineno"> 2648</span>&#160;<span class="comment"> * @param f The file stream pointer where the dump should be sent to.</span></div><div class="line"><a name="l02649"></a><span class="lineno"> 2649</span>&#160;<span class="comment"> * @param buf buffer</span></div><div class="line"><a name="l02650"></a><span class="lineno"> 2650</span>&#160;<span class="comment"> * @param size buffer size</span></div><div class="line"><a name="l02651"></a><span class="lineno"> 2651</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02652"></a><span class="lineno"> 2652</span>&#160;<span class="comment"> * @see av_hex_dump_log, av_pkt_dump2, av_pkt_dump_log2</span></div><div class="line"><a name="l02653"></a><span class="lineno"> 2653</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02654"></a><span class="lineno"> 2654</span>&#160;<span class="keywordtype">void</span> <a class="code" href="group__lavf__misc.html#gab533a6d5d830ab90573dd035002c5bca">av_hex_dump</a>(FILE *f, <span class="keyword">const</span> uint8_t *<a class="code" href="structAVProbeData.html#a814cca49dda3f578ebb32d4b2f74368a">buf</a>, <span class="keywordtype">int</span> size);</div><div class="line"><a name="l02655"></a><span class="lineno"> 2655</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02656"></a><span class="lineno"> 2656</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02657"></a><span class="lineno"> 2657</span>&#160;<span class="comment"> * Send a nice hexadecimal dump of a buffer to the log.</span></div><div class="line"><a name="l02658"></a><span class="lineno"> 2658</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02659"></a><span class="lineno"> 2659</span>&#160;<span class="comment"> * @param avcl A pointer to an arbitrary struct of which the first field is a</span></div><div class="line"><a name="l02660"></a><span class="lineno"> 2660</span>&#160;<span class="comment"> * pointer to an AVClass struct.</span></div><div class="line"><a name="l02661"></a><span class="lineno"> 2661</span>&#160;<span class="comment"> * @param level The importance level of the message, lower values signifying</span></div><div class="line"><a name="l02662"></a><span class="lineno"> 2662</span>&#160;<span class="comment"> * higher importance.</span></div><div class="line"><a name="l02663"></a><span class="lineno"> 2663</span>&#160;<span class="comment"> * @param buf buffer</span></div><div class="line"><a name="l02664"></a><span class="lineno"> 2664</span>&#160;<span class="comment"> * @param size buffer size</span></div><div class="line"><a name="l02665"></a><span class="lineno"> 2665</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02666"></a><span class="lineno"> 2666</span>&#160;<span class="comment"> * @see av_hex_dump, av_pkt_dump2, av_pkt_dump_log2</span></div><div class="line"><a name="l02667"></a><span class="lineno"> 2667</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02668"></a><span class="lineno"> 2668</span>&#160;<span class="keywordtype">void</span> <a class="code" href="group__lavf__misc.html#ga56f93dbd118ff5fe833a2e39b685974c">av_hex_dump_log</a>(<span class="keywordtype">void</span> *avcl, <span class="keywordtype">int</span> level, <span class="keyword">const</span> uint8_t *<a class="code" href="structAVProbeData.html#a814cca49dda3f578ebb32d4b2f74368a">buf</a>, <span class="keywordtype">int</span> size);</div><div class="line"><a name="l02669"></a><span class="lineno"> 2669</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02670"></a><span class="lineno"> 2670</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02671"></a><span class="lineno"> 2671</span>&#160;<span class="comment"> * Send a nice dump of a packet to the specified file stream.</span></div><div class="line"><a name="l02672"></a><span class="lineno"> 2672</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02673"></a><span class="lineno"> 2673</span>&#160;<span class="comment"> * @param f The file stream pointer where the dump should be sent to.</span></div><div class="line"><a name="l02674"></a><span class="lineno"> 2674</span>&#160;<span class="comment"> * @param pkt packet to dump</span></div><div class="line"><a name="l02675"></a><span class="lineno"> 2675</span>&#160;<span class="comment"> * @param dump_payload True if the payload must be displayed, too.</span></div><div class="line"><a name="l02676"></a><span class="lineno"> 2676</span>&#160;<span class="comment"> * @param st AVStream that the packet belongs to</span></div><div class="line"><a name="l02677"></a><span class="lineno"> 2677</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02678"></a><span class="lineno"> 2678</span>&#160;<span class="keywordtype">void</span> <a class="code" href="group__lavf__misc.html#ga46720b0bb28ca455246805be8969ff9e">av_pkt_dump2</a>(FILE *f, <span class="keyword">const</span> <a class="code" href="structAVPacket.html">AVPacket</a> *<a class="code" href="demuxing__decoding_8c.html#a3d4c6562f0b27cf0cacbbea5c038c090">pkt</a>, <span class="keywordtype">int</span> dump_payload, <span class="keyword">const</span> <a class="code" href="structAVStream.html">AVStream</a> *st);</div><div class="line"><a name="l02679"></a><span class="lineno"> 2679</span>&#160;</div><div class="line"><a name="l02680"></a><span class="lineno"> 2680</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02681"></a><span class="lineno"> 2681</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02682"></a><span class="lineno"> 2682</span>&#160;<span class="comment"> * Send a nice dump of a packet to the log.</span></div><div class="line"><a name="l02683"></a><span class="lineno"> 2683</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02684"></a><span class="lineno"> 2684</span>&#160;<span class="comment"> * @param avcl A pointer to an arbitrary struct of which the first field is a</span></div><div class="line"><a name="l02685"></a><span class="lineno"> 2685</span>&#160;<span class="comment"> * pointer to an AVClass struct.</span></div><div class="line"><a name="l02686"></a><span class="lineno"> 2686</span>&#160;<span class="comment"> * @param level The importance level of the message, lower values signifying</span></div><div class="line"><a name="l02687"></a><span class="lineno"> 2687</span>&#160;<span class="comment"> * higher importance.</span></div><div class="line"><a name="l02688"></a><span class="lineno"> 2688</span>&#160;<span class="comment"> * @param pkt packet to dump</span></div><div class="line"><a name="l02689"></a><span class="lineno"> 2689</span>&#160;<span class="comment"> * @param dump_payload True if the payload must be displayed, too.</span></div><div class="line"><a name="l02690"></a><span class="lineno"> 2690</span>&#160;<span class="comment"> * @param st AVStream that the packet belongs to</span></div><div class="line"><a name="l02691"></a><span class="lineno"> 2691</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02692"></a><span class="lineno"> 2692</span>&#160;<span class="keywordtype">void</span> <a class="code" href="group__lavf__misc.html#gaab9fad988c28cc1c4dcbba24a36b6113">av_pkt_dump_log2</a>(<span class="keywordtype">void</span> *avcl, <span class="keywordtype">int</span> level, <span class="keyword">const</span> <a class="code" href="structAVPacket.html">AVPacket</a> *<a class="code" href="demuxing__decoding_8c.html#a3d4c6562f0b27cf0cacbbea5c038c090">pkt</a>, <span class="keywordtype">int</span> dump_payload,</div><div class="line"><a name="l02693"></a><span class="lineno"> 2693</span>&#160;                      <span class="keyword">const</span> <a class="code" href="structAVStream.html">AVStream</a> *st);</div><div class="line"><a name="l02694"></a><span class="lineno"> 2694</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02695"></a><span class="lineno"> 2695</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02696"></a><span class="lineno"> 2696</span>&#160;<span class="comment"> * Get the AVCodecID for the given codec tag tag.</span></div><div class="line"><a name="l02697"></a><span class="lineno"> 2697</span>&#160;<span class="comment"> * If no codec id is found returns AV_CODEC_ID_NONE.</span></div><div class="line"><a name="l02698"></a><span class="lineno"> 2698</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02699"></a><span class="lineno"> 2699</span>&#160;<span class="comment"> * @param tags list of supported codec_id-codec_tag pairs, as stored</span></div><div class="line"><a name="l02700"></a><span class="lineno"> 2700</span>&#160;<span class="comment"> * in AVInputFormat.codec_tag and AVOutputFormat.codec_tag</span></div><div class="line"><a name="l02701"></a><span class="lineno"> 2701</span>&#160;<span class="comment"> * @param tag  codec tag to match to a codec ID</span></div><div class="line"><a name="l02702"></a><span class="lineno"> 2702</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02703"></a><span class="lineno"> 2703</span>&#160;<span class="keyword">enum</span> <a class="code" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a> <a class="code" href="group__lavf__misc.html#ga27b89fa8286af6efb5a69e8db4033b09">av_codec_get_id</a>(<span class="keyword">const</span> <span class="keyword">struct</span> AVCodecTag * <span class="keyword">const</span> *tags, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tag);</div><div class="line"><a name="l02704"></a><span class="lineno"> 2704</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02705"></a><span class="lineno"> 2705</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02706"></a><span class="lineno"> 2706</span>&#160;<span class="comment"> * Get the codec tag for the given codec id id.</span></div><div class="line"><a name="l02707"></a><span class="lineno"> 2707</span>&#160;<span class="comment"> * If no codec tag is found returns 0.</span></div><div class="line"><a name="l02708"></a><span class="lineno"> 2708</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02709"></a><span class="lineno"> 2709</span>&#160;<span class="comment"> * @param tags list of supported codec_id-codec_tag pairs, as stored</span></div><div class="line"><a name="l02710"></a><span class="lineno"> 2710</span>&#160;<span class="comment"> * in AVInputFormat.codec_tag and AVOutputFormat.codec_tag</span></div><div class="line"><a name="l02711"></a><span class="lineno"> 2711</span>&#160;<span class="comment"> * @param id   codec ID to match to a codec tag</span></div><div class="line"><a name="l02712"></a><span class="lineno"> 2712</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02713"></a><span class="lineno"> 2713</span>&#160;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="group__lavf__misc.html#ga126917b7ce8b4f05505098b72f4997de">av_codec_get_tag</a>(<span class="keyword">const</span> <span class="keyword">struct</span> AVCodecTag * <span class="keyword">const</span> *tags, <span class="keyword">enum</span> <a class="code" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a> <span class="keywordtype">id</span>);</div><div class="line"><a name="l02714"></a><span class="lineno"> 2714</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02715"></a><span class="lineno"> 2715</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02716"></a><span class="lineno"> 2716</span>&#160;<span class="comment"> * Get the codec tag for the given codec id.</span></div><div class="line"><a name="l02717"></a><span class="lineno"> 2717</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02718"></a><span class="lineno"> 2718</span>&#160;<span class="comment"> * @param tags list of supported codec_id - codec_tag pairs, as stored</span></div><div class="line"><a name="l02719"></a><span class="lineno"> 2719</span>&#160;<span class="comment"> * in AVInputFormat.codec_tag and AVOutputFormat.codec_tag</span></div><div class="line"><a name="l02720"></a><span class="lineno"> 2720</span>&#160;<span class="comment"> * @param id codec id that should be searched for in the list</span></div><div class="line"><a name="l02721"></a><span class="lineno"> 2721</span>&#160;<span class="comment"> * @param tag A pointer to the found tag</span></div><div class="line"><a name="l02722"></a><span class="lineno"> 2722</span>&#160;<span class="comment"> * @return 0 if id was not found in tags, &gt; 0 if it was found</span></div><div class="line"><a name="l02723"></a><span class="lineno"> 2723</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02724"></a><span class="lineno"> 2724</span>&#160;<span class="keywordtype">int</span> <a class="code" href="group__lavf__misc.html#gabe1a7b6824078229c69b75c71053c035">av_codec_get_tag2</a>(<span class="keyword">const</span> <span class="keyword">struct</span> AVCodecTag * <span class="keyword">const</span> *tags, <span class="keyword">enum</span> <a class="code" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a> <span class="keywordtype">id</span>,</div><div class="line"><a name="l02725"></a><span class="lineno"> 2725</span>&#160;                      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *tag);</div><div class="line"><a name="l02726"></a><span class="lineno"> 2726</span>&#160;</div><div class="line"><a name="l02727"></a><span class="lineno"> 2727</span>&#160;<span class="keywordtype">int</span> <a class="code" href="group__lavf__misc.html#gaad9737492bb66aeeec37b7c7d8d90f2a">av_find_default_stream_index</a>(<a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s);</div><div class="line"><a name="l02728"></a><span class="lineno"> 2728</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02729"></a><span class="lineno"> 2729</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02730"></a><span class="lineno"> 2730</span>&#160;<span class="comment"> * Get the index for a specific timestamp.</span></div><div class="line"><a name="l02731"></a><span class="lineno"> 2731</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02732"></a><span class="lineno"> 2732</span>&#160;<span class="comment"> * @param st        stream that the timestamp belongs to</span></div><div class="line"><a name="l02733"></a><span class="lineno"> 2733</span>&#160;<span class="comment"> * @param timestamp timestamp to retrieve the index for</span></div><div class="line"><a name="l02734"></a><span class="lineno"> 2734</span>&#160;<span class="comment"> * @param flags if AVSEEK_FLAG_BACKWARD then the returned index will correspond</span></div><div class="line"><a name="l02735"></a><span class="lineno"> 2735</span>&#160;<span class="comment"> *                 to the timestamp which is &lt;= the requested one, if backward</span></div><div class="line"><a name="l02736"></a><span class="lineno"> 2736</span>&#160;<span class="comment"> *                 is 0, then it will be &gt;=</span></div><div class="line"><a name="l02737"></a><span class="lineno"> 2737</span>&#160;<span class="comment"> *              if AVSEEK_FLAG_ANY seek to any frame, only keyframes otherwise</span></div><div class="line"><a name="l02738"></a><span class="lineno"> 2738</span>&#160;<span class="comment"> * @return &lt; 0 if no such timestamp could be found</span></div><div class="line"><a name="l02739"></a><span class="lineno"> 2739</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02740"></a><span class="lineno"> 2740</span>&#160;<span class="keywordtype">int</span> <a class="code" href="group__lavf__misc.html#gac4cabc0d681c34b2e2c6a87a55877f0d">av_index_search_timestamp</a>(<a class="code" href="structAVStream.html">AVStream</a> *st, int64_t timestamp, <span class="keywordtype">int</span> flags);</div><div class="line"><a name="l02741"></a><span class="lineno"> 2741</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02742"></a><span class="lineno"> 2742</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02743"></a><span class="lineno"> 2743</span>&#160;<span class="comment"> * Add an index entry into a sorted list. Update the entry if the list</span></div><div class="line"><a name="l02744"></a><span class="lineno"> 2744</span>&#160;<span class="comment"> * already contains it.</span></div><div class="line"><a name="l02745"></a><span class="lineno"> 2745</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02746"></a><span class="lineno"> 2746</span>&#160;<span class="comment"> * @param timestamp timestamp in the time base of the given stream</span></div><div class="line"><a name="l02747"></a><span class="lineno"> 2747</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02748"></a><span class="lineno"> 2748</span>&#160;<span class="keywordtype">int</span> <a class="code" href="group__lavf__misc.html#ga3ed7441cb4af0bdd65a4cf51bf35088e">av_add_index_entry</a>(<a class="code" href="structAVStream.html">AVStream</a> *st, int64_t pos, int64_t timestamp,</div><div class="line"><a name="l02749"></a><span class="lineno"> 2749</span>&#160;                       <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> distance, <span class="keywordtype">int</span> flags);</div><div class="line"><a name="l02750"></a><span class="lineno"> 2750</span>&#160;</div><div class="line"><a name="l02751"></a><span class="lineno"> 2751</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02752"></a><span class="lineno"> 2752</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02753"></a><span class="lineno"> 2753</span>&#160;<span class="comment"> * Split a URL string into components.</span></div><div class="line"><a name="l02754"></a><span class="lineno"> 2754</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02755"></a><span class="lineno"> 2755</span>&#160;<span class="comment"> * The pointers to buffers for storing individual components may be null,</span></div><div class="line"><a name="l02756"></a><span class="lineno"> 2756</span>&#160;<span class="comment"> * in order to ignore that component. Buffers for components not found are</span></div><div class="line"><a name="l02757"></a><span class="lineno"> 2757</span>&#160;<span class="comment"> * set to empty strings. If the port is not found, it is set to a negative</span></div><div class="line"><a name="l02758"></a><span class="lineno"> 2758</span>&#160;<span class="comment"> * value.</span></div><div class="line"><a name="l02759"></a><span class="lineno"> 2759</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02760"></a><span class="lineno"> 2760</span>&#160;<span class="comment"> * @param proto the buffer for the protocol</span></div><div class="line"><a name="l02761"></a><span class="lineno"> 2761</span>&#160;<span class="comment"> * @param proto_size the size of the proto buffer</span></div><div class="line"><a name="l02762"></a><span class="lineno"> 2762</span>&#160;<span class="comment"> * @param authorization the buffer for the authorization</span></div><div class="line"><a name="l02763"></a><span class="lineno"> 2763</span>&#160;<span class="comment"> * @param authorization_size the size of the authorization buffer</span></div><div class="line"><a name="l02764"></a><span class="lineno"> 2764</span>&#160;<span class="comment"> * @param hostname the buffer for the host name</span></div><div class="line"><a name="l02765"></a><span class="lineno"> 2765</span>&#160;<span class="comment"> * @param hostname_size the size of the hostname buffer</span></div><div class="line"><a name="l02766"></a><span class="lineno"> 2766</span>&#160;<span class="comment"> * @param port_ptr a pointer to store the port number in</span></div><div class="line"><a name="l02767"></a><span class="lineno"> 2767</span>&#160;<span class="comment"> * @param path the buffer for the path</span></div><div class="line"><a name="l02768"></a><span class="lineno"> 2768</span>&#160;<span class="comment"> * @param path_size the size of the path buffer</span></div><div class="line"><a name="l02769"></a><span class="lineno"> 2769</span>&#160;<span class="comment"> * @param url the URL to split</span></div><div class="line"><a name="l02770"></a><span class="lineno"> 2770</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02771"></a><span class="lineno"> 2771</span>&#160;<span class="keywordtype">void</span> <a class="code" href="group__lavf__misc.html#ga63a0579d6c2aa72470ac742bbbc1205d">av_url_split</a>(<span class="keywordtype">char</span> *proto,         <span class="keywordtype">int</span> proto_size,</div><div class="line"><a name="l02772"></a><span class="lineno"> 2772</span>&#160;                  <span class="keywordtype">char</span> *authorization, <span class="keywordtype">int</span> authorization_size,</div><div class="line"><a name="l02773"></a><span class="lineno"> 2773</span>&#160;                  <span class="keywordtype">char</span> *hostname,      <span class="keywordtype">int</span> hostname_size,</div><div class="line"><a name="l02774"></a><span class="lineno"> 2774</span>&#160;                  <span class="keywordtype">int</span> *port_ptr,</div><div class="line"><a name="l02775"></a><span class="lineno"> 2775</span>&#160;                  <span class="keywordtype">char</span> *path,          <span class="keywordtype">int</span> path_size,</div><div class="line"><a name="l02776"></a><span class="lineno"> 2776</span>&#160;                  <span class="keyword">const</span> <span class="keywordtype">char</span> *url);</div><div class="line"><a name="l02777"></a><span class="lineno"> 2777</span>&#160;</div><div class="line"><a name="l02778"></a><span class="lineno"> 2778</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02779"></a><span class="lineno"> 2779</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02780"></a><span class="lineno"> 2780</span>&#160;<span class="comment"> * Print detailed information about the input or output format, such as</span></div><div class="line"><a name="l02781"></a><span class="lineno"> 2781</span>&#160;<span class="comment"> * duration, bitrate, streams, container, programs, metadata, side data,</span></div><div class="line"><a name="l02782"></a><span class="lineno"> 2782</span>&#160;<span class="comment"> * codec and time base.</span></div><div class="line"><a name="l02783"></a><span class="lineno"> 2783</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02784"></a><span class="lineno"> 2784</span>&#160;<span class="comment"> * @param ic        the context to analyze</span></div><div class="line"><a name="l02785"></a><span class="lineno"> 2785</span>&#160;<span class="comment"> * @param index     index of the stream to dump information about</span></div><div class="line"><a name="l02786"></a><span class="lineno"> 2786</span>&#160;<span class="comment"> * @param url       the URL to print, such as source or destination file</span></div><div class="line"><a name="l02787"></a><span class="lineno"> 2787</span>&#160;<span class="comment"> * @param is_output Select whether the specified context is an input(0) or output(1)</span></div><div class="line"><a name="l02788"></a><span class="lineno"> 2788</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02789"></a><span class="lineno"> 2789</span>&#160;<span class="keywordtype">void</span> <a class="code" href="group__lavf__misc.html#gae2645941f2dc779c307eb6314fd39f10">av_dump_format</a>(<a class="code" href="structAVFormatContext.html">AVFormatContext</a> *ic,</div><div class="line"><a name="l02790"></a><span class="lineno"> 2790</span>&#160;                    <span class="keywordtype">int</span> index,</div><div class="line"><a name="l02791"></a><span class="lineno"> 2791</span>&#160;                    <span class="keyword">const</span> <span class="keywordtype">char</span> *url,</div><div class="line"><a name="l02792"></a><span class="lineno"> 2792</span>&#160;                    <span class="keywordtype">int</span> is_output);</div><div class="line"><a name="l02793"></a><span class="lineno"> 2793</span>&#160;</div><div class="line"><a name="l02794"></a><span class="lineno"> 2794</span>&#160;</div><div class="line"><a name="l02795"></a><span class="lineno"> 2795</span>&#160;<span class="preprocessor">#define AV_FRAME_FILENAME_FLAGS_MULTIPLE 1 </span><span class="comment">///&lt; Allow multiple %d</span></div><div class="line"><a name="l02796"></a><span class="lineno"> 2796</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02797"></a><span class="lineno"> 2797</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02798"></a><span class="lineno"> 2798</span>&#160;<span class="comment"> * Return in &#39;buf&#39; the path with &#39;%d&#39; replaced by a number.</span></div><div class="line"><a name="l02799"></a><span class="lineno"> 2799</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02800"></a><span class="lineno"> 2800</span>&#160;<span class="comment"> * Also handles the &#39;%0nd&#39; format where &#39;n&#39; is the total number</span></div><div class="line"><a name="l02801"></a><span class="lineno"> 2801</span>&#160;<span class="comment"> * of digits and &#39;%%&#39;.</span></div><div class="line"><a name="l02802"></a><span class="lineno"> 2802</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02803"></a><span class="lineno"> 2803</span>&#160;<span class="comment"> * @param buf destination buffer</span></div><div class="line"><a name="l02804"></a><span class="lineno"> 2804</span>&#160;<span class="comment"> * @param buf_size destination buffer size</span></div><div class="line"><a name="l02805"></a><span class="lineno"><a class="line" href="group__lavf__misc.html#gaa0fc59624ec1fe0dc583743678b96fb6"> 2805</a></span>&#160;<span class="comment"> * @param path numbered sequence string</span></div><div class="line"><a name="l02806"></a><span class="lineno"> 2806</span>&#160;<span class="comment"> * @param number frame number</span></div><div class="line"><a name="l02807"></a><span class="lineno"> 2807</span>&#160;<span class="comment"> * @param flags AV_FRAME_FILENAME_FLAGS_*</span></div><div class="line"><a name="l02808"></a><span class="lineno"> 2808</span>&#160;<span class="comment"> * @return 0 if OK, -1 on format error</span></div><div class="line"><a name="l02809"></a><span class="lineno"> 2809</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02810"></a><span class="lineno"> 2810</span>&#160;<span class="keywordtype">int</span> <a class="code" href="group__lavf__misc.html#ga05f17637161cd79506f67b20ea8149c9">av_get_frame_filename2</a>(<span class="keywordtype">char</span> *<a class="code" href="structAVProbeData.html#a814cca49dda3f578ebb32d4b2f74368a">buf</a>, <span class="keywordtype">int</span> <a class="code" href="structAVProbeData.html#a30309e4de25c1a411c635eab767e1e53">buf_size</a>,</div><div class="line"><a name="l02811"></a><span class="lineno"> 2811</span>&#160;                          <span class="keyword">const</span> <span class="keywordtype">char</span> *path, <span class="keywordtype">int</span> number, <span class="keywordtype">int</span> flags);</div><div class="line"><a name="l02812"></a><span class="lineno"> 2812</span>&#160;</div><div class="line"><a name="l02813"></a><span class="lineno"> 2813</span>&#160;<span class="keywordtype">int</span> <a class="code" href="group__lavf__misc.html#ga90e027a5d9006148413a1387c506cd40">av_get_frame_filename</a>(<span class="keywordtype">char</span> *<a class="code" href="structAVProbeData.html#a814cca49dda3f578ebb32d4b2f74368a">buf</a>, <span class="keywordtype">int</span> <a class="code" href="structAVProbeData.html#a30309e4de25c1a411c635eab767e1e53">buf_size</a>,</div><div class="line"><a name="l02814"></a><span class="lineno"> 2814</span>&#160;                          <span class="keyword">const</span> <span class="keywordtype">char</span> *path, <span class="keywordtype">int</span> number);</div><div class="line"><a name="l02815"></a><span class="lineno"> 2815</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02816"></a><span class="lineno"> 2816</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02817"></a><span class="lineno"> 2817</span>&#160;<span class="comment"> * Check whether filename actually is a numbered sequence generator.</span></div><div class="line"><a name="l02818"></a><span class="lineno"> 2818</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02819"></a><span class="lineno"> 2819</span>&#160;<span class="comment"> * @param filename possible numbered sequence string</span></div><div class="line"><a name="l02820"></a><span class="lineno"> 2820</span>&#160;<span class="comment"> * @return 1 if a valid numbered sequence string, 0 otherwise</span></div><div class="line"><a name="l02821"></a><span class="lineno"> 2821</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02822"></a><span class="lineno"> 2822</span>&#160;<span class="keywordtype">int</span> <a class="code" href="group__lavf__misc.html#gac20eb319c6c46f581b5d08f5c25e763e">av_filename_number_test</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structAVProbeData.html#a0e8504127aff8af25cc9f3c6400b9651">filename</a>);</div><div class="line"><a name="l02823"></a><span class="lineno"> 2823</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02824"></a><span class="lineno"> 2824</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02825"></a><span class="lineno"> 2825</span>&#160;<span class="comment"> * Generate an SDP for an RTP session.</span></div><div class="line"><a name="l02826"></a><span class="lineno"> 2826</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02827"></a><span class="lineno"> 2827</span>&#160;<span class="comment"> * Note, this overwrites the id values of AVStreams in the muxer contexts</span></div><div class="line"><a name="l02828"></a><span class="lineno"> 2828</span>&#160;<span class="comment"> * for getting unique dynamic payload types.</span></div><div class="line"><a name="l02829"></a><span class="lineno"> 2829</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02830"></a><span class="lineno"> 2830</span>&#160;<span class="comment"> * @param ac array of AVFormatContexts describing the RTP streams. If the</span></div><div class="line"><a name="l02831"></a><span class="lineno"> 2831</span>&#160;<span class="comment"> *           array is composed by only one context, such context can contain</span></div><div class="line"><a name="l02832"></a><span class="lineno"> 2832</span>&#160;<span class="comment"> *           multiple AVStreams (one AVStream per RTP stream). Otherwise,</span></div><div class="line"><a name="l02833"></a><span class="lineno"> 2833</span>&#160;<span class="comment"> *           all the contexts in the array (an AVCodecContext per RTP stream)</span></div><div class="line"><a name="l02834"></a><span class="lineno"> 2834</span>&#160;<span class="comment"> *           must contain only one AVStream.</span></div><div class="line"><a name="l02835"></a><span class="lineno"> 2835</span>&#160;<span class="comment"> * @param n_files number of AVCodecContexts contained in ac</span></div><div class="line"><a name="l02836"></a><span class="lineno"> 2836</span>&#160;<span class="comment"> * @param buf buffer where the SDP will be stored (must be allocated by</span></div><div class="line"><a name="l02837"></a><span class="lineno"> 2837</span>&#160;<span class="comment"> *            the caller)</span></div><div class="line"><a name="l02838"></a><span class="lineno"> 2838</span>&#160;<span class="comment"> * @param size the size of the buffer</span></div><div class="line"><a name="l02839"></a><span class="lineno"> 2839</span>&#160;<span class="comment"> * @return 0 if OK, AVERROR_xxx on error</span></div><div class="line"><a name="l02840"></a><span class="lineno"> 2840</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02841"></a><span class="lineno"> 2841</span>&#160;<span class="keywordtype">int</span> <a class="code" href="group__lavf__misc.html#gaa2a7353a6bb0c8726797abd56b176af0">av_sdp_create</a>(<a class="code" href="structAVFormatContext.html">AVFormatContext</a> *ac[], <span class="keywordtype">int</span> n_files, <span class="keywordtype">char</span> *<a class="code" href="structAVProbeData.html#a814cca49dda3f578ebb32d4b2f74368a">buf</a>, <span class="keywordtype">int</span> size);</div><div class="line"><a name="l02842"></a><span class="lineno"> 2842</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02843"></a><span class="lineno"> 2843</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02844"></a><span class="lineno"> 2844</span>&#160;<span class="comment"> * Return a positive value if the given filename has one of the given</span></div><div class="line"><a name="l02845"></a><span class="lineno"> 2845</span>&#160;<span class="comment"> * extensions, 0 otherwise.</span></div><div class="line"><a name="l02846"></a><span class="lineno"> 2846</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02847"></a><span class="lineno"> 2847</span>&#160;<span class="comment"> * @param filename   file name to check against the given extensions</span></div><div class="line"><a name="l02848"></a><span class="lineno"> 2848</span>&#160;<span class="comment"> * @param extensions a comma-separated list of filename extensions</span></div><div class="line"><a name="l02849"></a><span class="lineno"> 2849</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02850"></a><span class="lineno"> 2850</span>&#160;<span class="keywordtype">int</span> <a class="code" href="group__lavf__misc.html#ga8247f49e5642dd3bd20ce6ba5a7f6466">av_match_ext</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structAVProbeData.html#a0e8504127aff8af25cc9f3c6400b9651">filename</a>, <span class="keyword">const</span> <span class="keywordtype">char</span> *extensions);</div><div class="line"><a name="l02851"></a><span class="lineno"> 2851</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02852"></a><span class="lineno"> 2852</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02853"></a><span class="lineno"> 2853</span>&#160;<span class="comment"> * Test if the given container can store a codec.</span></div><div class="line"><a name="l02854"></a><span class="lineno"> 2854</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02855"></a><span class="lineno"> 2855</span>&#160;<span class="comment"> * @param ofmt           container to check for compatibility</span></div><div class="line"><a name="l02856"></a><span class="lineno"> 2856</span>&#160;<span class="comment"> * @param codec_id       codec to potentially store in container</span></div><div class="line"><a name="l02857"></a><span class="lineno"> 2857</span>&#160;<span class="comment"> * @param std_compliance standards compliance level, one of FF_COMPLIANCE_*</span></div><div class="line"><a name="l02858"></a><span class="lineno"> 2858</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02859"></a><span class="lineno"> 2859</span>&#160;<span class="comment"> * @return 1 if codec with ID codec_id can be stored in ofmt, 0 if it cannot.</span></div><div class="line"><a name="l02860"></a><span class="lineno"> 2860</span>&#160;<span class="comment"> *         A negative number if this information is not available.</span></div><div class="line"><a name="l02861"></a><span class="lineno"> 2861</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02862"></a><span class="lineno"> 2862</span>&#160;<span class="keywordtype">int</span> <a class="code" href="group__lavf__misc.html#gaa90b4c72d1bbb298e11096d3a09ec7db">avformat_query_codec</a>(<span class="keyword">const</span> <a class="code" href="structAVOutputFormat.html">AVOutputFormat</a> *ofmt, <span class="keyword">enum</span> <a class="code" href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a> codec_id,</div><div class="line"><a name="l02863"></a><span class="lineno"> 2863</span>&#160;                         <span class="keywordtype">int</span> std_compliance);</div><div class="line"><a name="l02864"></a><span class="lineno"> 2864</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02865"></a><span class="lineno"> 2865</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02866"></a><span class="lineno"> 2866</span>&#160;<span class="comment"> * @defgroup riff_fourcc RIFF FourCCs</span></div><div class="line"><a name="l02867"></a><span class="lineno"> 2867</span>&#160;<span class="comment"> * @{</span></div><div class="line"><a name="l02868"></a><span class="lineno"> 2868</span>&#160;<span class="comment"> * Get the tables mapping RIFF FourCCs to libavcodec AVCodecIDs. The tables are</span></div><div class="line"><a name="l02869"></a><span class="lineno"> 2869</span>&#160;<span class="comment"> * meant to be passed to av_codec_get_id()/av_codec_get_tag() as in the</span></div><div class="line"><a name="l02870"></a><span class="lineno"> 2870</span>&#160;<span class="comment"> * following code:</span></div><div class="line"><a name="l02871"></a><span class="lineno"> 2871</span>&#160;<span class="comment"> * @code</span></div><div class="line"><a name="l02872"></a><span class="lineno"> 2872</span>&#160;<span class="comment"> * uint32_t tag = MKTAG(&#39;H&#39;, &#39;2&#39;, &#39;6&#39;, &#39;4&#39;);</span></div><div class="line"><a name="l02873"></a><span class="lineno"> 2873</span>&#160;<span class="comment"> * const struct AVCodecTag *table[] = { avformat_get_riff_video_tags(), 0 };</span></div><div class="line"><a name="l02874"></a><span class="lineno"> 2874</span>&#160;<span class="comment"> * enum AVCodecID id = av_codec_get_id(table, tag);</span></div><div class="line"><a name="l02875"></a><span class="lineno"> 2875</span>&#160;<span class="comment"> * @endcode</span></div><div class="line"><a name="l02876"></a><span class="lineno"> 2876</span>&#160;<span class="comment"> */</span><span class="comment"></span></div><div class="line"><a name="l02877"></a><span class="lineno"> 2877</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02878"></a><span class="lineno"> 2878</span>&#160;<span class="comment"> * @return the table mapping RIFF FourCCs for video to libavcodec AVCodecID.</span></div><div class="line"><a name="l02879"></a><span class="lineno"> 2879</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02880"></a><span class="lineno"> 2880</span>&#160;<span class="keyword">const</span> <span class="keyword">struct </span>AVCodecTag *<a class="code" href="group__riff__fourcc.html#ga036cfb1a22e899179f932df0cfc6c415">avformat_get_riff_video_tags</a>(<span class="keywordtype">void</span>);<span class="comment"></span></div><div class="line"><a name="l02881"></a><span class="lineno"> 2881</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02882"></a><span class="lineno"> 2882</span>&#160;<span class="comment"> * @return the table mapping RIFF FourCCs for audio to AVCodecID.</span></div><div class="line"><a name="l02883"></a><span class="lineno"> 2883</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02884"></a><span class="lineno"> 2884</span>&#160;<span class="keyword">const</span> <span class="keyword">struct </span>AVCodecTag *<a class="code" href="group__riff__fourcc.html#ga8b9668cfd684804ebe7ab14b05aa3ba0">avformat_get_riff_audio_tags</a>(<span class="keywordtype">void</span>);<span class="comment"></span></div><div class="line"><a name="l02885"></a><span class="lineno"> 2885</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02886"></a><span class="lineno"> 2886</span>&#160;<span class="comment"> * @return the table mapping MOV FourCCs for video to libavcodec AVCodecID.</span></div><div class="line"><a name="l02887"></a><span class="lineno"> 2887</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02888"></a><span class="lineno"> 2888</span>&#160;<span class="keyword">const</span> <span class="keyword">struct </span>AVCodecTag *<a class="code" href="group__riff__fourcc.html#ga36261b12dba43e0cba5a753ecb3d0e54">avformat_get_mov_video_tags</a>(<span class="keywordtype">void</span>);<span class="comment"></span></div><div class="line"><a name="l02889"></a><span class="lineno"> 2889</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02890"></a><span class="lineno"> 2890</span>&#160;<span class="comment"> * @return the table mapping MOV FourCCs for audio to AVCodecID.</span></div><div class="line"><a name="l02891"></a><span class="lineno"> 2891</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02892"></a><span class="lineno"> 2892</span>&#160;<span class="keyword">const</span> <span class="keyword">struct </span>AVCodecTag *<a class="code" href="group__riff__fourcc.html#gac389e7f9cd19570bd599a61fd1884a4a">avformat_get_mov_audio_tags</a>(<span class="keywordtype">void</span>);</div><div class="line"><a name="l02893"></a><span class="lineno"> 2893</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02894"></a><span class="lineno"> 2894</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02895"></a><span class="lineno"> 2895</span>&#160;<span class="comment"> * @}</span></div><div class="line"><a name="l02896"></a><span class="lineno"> 2896</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02897"></a><span class="lineno"> 2897</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02898"></a><span class="lineno"> 2898</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02899"></a><span class="lineno"> 2899</span>&#160;<span class="comment"> * Guess the sample aspect ratio of a frame, based on both the stream and the</span></div><div class="line"><a name="l02900"></a><span class="lineno"> 2900</span>&#160;<span class="comment"> * frame aspect ratio.</span></div><div class="line"><a name="l02901"></a><span class="lineno"> 2901</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02902"></a><span class="lineno"> 2902</span>&#160;<span class="comment"> * Since the frame aspect ratio is set by the codec but the stream aspect ratio</span></div><div class="line"><a name="l02903"></a><span class="lineno"> 2903</span>&#160;<span class="comment"> * is set by the demuxer, these two may not be equal. This function tries to</span></div><div class="line"><a name="l02904"></a><span class="lineno"> 2904</span>&#160;<span class="comment"> * return the value that you should use if you would like to display the frame.</span></div><div class="line"><a name="l02905"></a><span class="lineno"> 2905</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02906"></a><span class="lineno"> 2906</span>&#160;<span class="comment"> * Basic logic is to use the stream aspect ratio if it is set to something sane</span></div><div class="line"><a name="l02907"></a><span class="lineno"> 2907</span>&#160;<span class="comment"> * otherwise use the frame aspect ratio. This way a container setting, which is</span></div><div class="line"><a name="l02908"></a><span class="lineno"> 2908</span>&#160;<span class="comment"> * usually easy to modify can override the coded value in the frames.</span></div><div class="line"><a name="l02909"></a><span class="lineno"> 2909</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02910"></a><span class="lineno"> 2910</span>&#160;<span class="comment"> * @param format the format context which the stream is part of</span></div><div class="line"><a name="l02911"></a><span class="lineno"> 2911</span>&#160;<span class="comment"> * @param stream the stream which the frame is part of</span></div><div class="line"><a name="l02912"></a><span class="lineno"> 2912</span>&#160;<span class="comment"> * @param frame the frame with the aspect ratio to be determined</span></div><div class="line"><a name="l02913"></a><span class="lineno"> 2913</span>&#160;<span class="comment"> * @return the guessed (valid) sample_aspect_ratio, 0/1 if no idea</span></div><div class="line"><a name="l02914"></a><span class="lineno"> 2914</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02915"></a><span class="lineno"> 2915</span>&#160;<a class="code" href="structAVRational.html">AVRational</a> <a class="code" href="group__lavf__misc.html#ga0f62da0e809045bb21166013c404ce43">av_guess_sample_aspect_ratio</a>(<a class="code" href="structAVFormatContext.html">AVFormatContext</a> *format, <a class="code" href="structAVStream.html">AVStream</a> *stream, <a class="code" href="structAVFrame.html">AVFrame</a> *<a class="code" href="demuxing__decoding_8c.html#ad7d33d579a8d4241a5e643e39287a209">frame</a>);</div><div class="line"><a name="l02916"></a><span class="lineno"> 2916</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02917"></a><span class="lineno"> 2917</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02918"></a><span class="lineno"> 2918</span>&#160;<span class="comment"> * Guess the frame rate, based on both the container and codec information.</span></div><div class="line"><a name="l02919"></a><span class="lineno"> 2919</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02920"></a><span class="lineno"> 2920</span>&#160;<span class="comment"> * @param ctx the format context which the stream is part of</span></div><div class="line"><a name="l02921"></a><span class="lineno"> 2921</span>&#160;<span class="comment"> * @param stream the stream which the frame is part of</span></div><div class="line"><a name="l02922"></a><span class="lineno"> 2922</span>&#160;<span class="comment"> * @param frame the frame for which the frame rate should be determined, may be NULL</span></div><div class="line"><a name="l02923"></a><span class="lineno"> 2923</span>&#160;<span class="comment"> * @return the guessed (valid) frame rate, 0/1 if no idea</span></div><div class="line"><a name="l02924"></a><span class="lineno"> 2924</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02925"></a><span class="lineno"> 2925</span>&#160;<a class="code" href="structAVRational.html">AVRational</a> <a class="code" href="group__lavf__misc.html#ga12c049178414cc221dfafd4e7f836dea">av_guess_frame_rate</a>(<a class="code" href="structAVFormatContext.html">AVFormatContext</a> *ctx, <a class="code" href="structAVStream.html">AVStream</a> *stream, <a class="code" href="structAVFrame.html">AVFrame</a> *<a class="code" href="demuxing__decoding_8c.html#ad7d33d579a8d4241a5e643e39287a209">frame</a>);</div><div class="line"><a name="l02926"></a><span class="lineno"> 2926</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02927"></a><span class="lineno"> 2927</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02928"></a><span class="lineno"> 2928</span>&#160;<span class="comment"> * Check if the stream st contained in s is matched by the stream specifier</span></div><div class="line"><a name="l02929"></a><span class="lineno"> 2929</span>&#160;<span class="comment"> * spec.</span></div><div class="line"><a name="l02930"></a><span class="lineno"> 2930</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02931"></a><span class="lineno"> 2931</span>&#160;<span class="comment"> * See the &quot;stream specifiers&quot; chapter in the documentation for the syntax</span></div><div class="line"><a name="l02932"></a><span class="lineno"> 2932</span>&#160;<span class="comment"> * of spec.</span></div><div class="line"><a name="l02933"></a><span class="lineno"> 2933</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02934"></a><span class="lineno"> 2934</span>&#160;<span class="comment"> * @return  &gt;0 if st is matched by spec;</span></div><div class="line"><a name="l02935"></a><span class="lineno"> 2935</span>&#160;<span class="comment"> *          0  if st is not matched by spec;</span></div><div class="line"><a name="l02936"></a><span class="lineno"> 2936</span>&#160;<span class="comment"> *          AVERROR code if spec is invalid</span></div><div class="line"><a name="l02937"></a><span class="lineno"> 2937</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02938"></a><span class="lineno"> 2938</span>&#160;<span class="comment"> * @note  A stream specifier can match several streams in the format.</span></div><div class="line"><a name="l02939"></a><span class="lineno"> 2939</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02940"></a><span class="lineno"> 2940</span>&#160;<span class="keywordtype">int</span> <a class="code" href="group__lavf__misc.html#ga7e45597834e9ef3098ddb74bc5e1550c">avformat_match_stream_specifier</a>(<a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s, <a class="code" href="structAVStream.html">AVStream</a> *st,</div><div class="line"><a name="l02941"></a><span class="lineno"> 2941</span>&#160;                                    <span class="keyword">const</span> <span class="keywordtype">char</span> *spec);</div><div class="line"><a name="l02942"></a><span class="lineno"> 2942</span>&#160;</div><div class="line"><a name="l02943"></a><span class="lineno"> 2943</span>&#160;<span class="keywordtype">int</span> <a class="code" href="group__lavf__misc.html#ga501ff1b3aa357c09da90c0effb356e45">avformat_queue_attached_pictures</a>(<a class="code" href="structAVFormatContext.html">AVFormatContext</a> *s);</div><div class="line"><a name="l02944"></a><span class="lineno"> 2944</span>&#160;</div><div class="line"><a name="l02945"></a><span class="lineno"> 2945</span>&#160;<span class="preprocessor">#if FF_API_OLD_BSF</span></div><div class="line"><a name="l02946"></a><span class="lineno"> 2946</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02947"></a><span class="lineno"> 2947</span>&#160;<span class="comment"> * Apply a list of bitstream filters to a packet.</span></div><div class="line"><a name="l02948"></a><span class="lineno"> 2948</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02949"></a><span class="lineno"> 2949</span>&#160;<span class="comment"> * @param codec AVCodecContext, usually from an AVStream</span></div><div class="line"><a name="l02950"></a><span class="lineno"> 2950</span>&#160;<span class="comment"> * @param pkt the packet to apply filters to. If, on success, the returned</span></div><div class="line"><a name="l02951"></a><span class="lineno"> 2951</span>&#160;<span class="comment"> *        packet has size == 0 and side_data_elems == 0, it indicates that</span></div><div class="line"><a name="l02952"></a><span class="lineno"> 2952</span>&#160;<span class="comment"> *        the packet should be dropped</span></div><div class="line"><a name="l02953"></a><span class="lineno"> 2953</span>&#160;<span class="comment"> * @param bsfc a NULL-terminated list of filters to apply</span></div><div class="line"><a name="l02954"></a><span class="lineno"> 2954</span>&#160;<span class="comment"> * @return  &gt;=0 on success;</span></div><div class="line"><a name="l02955"></a><span class="lineno"> 2955</span>&#160;<span class="comment"> *          AVERROR code on failure</span></div><div class="line"><a name="l02956"></a><span class="lineno"> 2956</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02957"></a><span class="lineno"> 2957</span>&#160;<a class="code" href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a></div><div class="line"><a name="l02958"></a><span class="lineno"> 2958</span>&#160;<span class="keywordtype">int</span> av_apply_bitstream_filters(<a class="code" href="structAVCodecContext.html">AVCodecContext</a> *codec, <a class="code" href="structAVPacket.html">AVPacket</a> *<a class="code" href="demuxing__decoding_8c.html#a3d4c6562f0b27cf0cacbbea5c038c090">pkt</a>,</div><div class="line"><a name="l02959"></a><span class="lineno"> 2959</span>&#160;                               <a class="code" href="structAVBitStreamFilterContext.html">AVBitStreamFilterContext</a> *bsfc);</div><div class="line"><a name="l02960"></a><span class="lineno"> 2960</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l02961"></a><span class="lineno"> 2961</span>&#160;</div><div class="line"><a name="l02962"></a><span class="lineno"> 2962</span>&#160;<span class="keyword">enum</span> <a class="code" href="group__lavf__misc.html#ga67f84bb8799c8da41194f046f4b970c4">AVTimebaseSource</a> {</div><div class="line"><a name="l02963"></a><span class="lineno"> 2963</span>&#160;    <a class="code" href="group__lavf__misc.html#gga67f84bb8799c8da41194f046f4b970c4a925300170a86b606dbe4b2b2a18ad12a">AVFMT_TBCF_AUTO</a> = -1,</div><div class="line"><a name="l02964"></a><span class="lineno"> 2964</span>&#160;    <a class="code" href="group__lavf__misc.html#gga67f84bb8799c8da41194f046f4b970c4ae6bd8e936313feda91adedd2501ca90b">AVFMT_TBCF_DECODER</a>,</div><div class="line"><a name="l02965"></a><span class="lineno"> 2965</span>&#160;    <a class="code" href="group__lavf__misc.html#gga67f84bb8799c8da41194f046f4b970c4a4b894ad271e07df75e1b8121455ea4ee">AVFMT_TBCF_DEMUXER</a>,</div><div class="line"><a name="l02966"></a><span class="lineno"> 2966</span>&#160;<span class="preprocessor">#if FF_API_R_FRAME_RATE</span></div><div class="line"><a name="l02967"></a><span class="lineno"> 2967</span>&#160;    AVFMT_TBCF_R_FRAMERATE,</div><div class="line"><a name="l02968"></a><span class="lineno"> 2968</span>&#160;<span class="preprocessor">#endif</span></div><div class="line"><a name="l02969"></a><span class="lineno"> 2969</span>&#160;};</div><div class="line"><a name="l02970"></a><span class="lineno"> 2970</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02971"></a><span class="lineno"> 2971</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02972"></a><span class="lineno"><a class="line" href="group__lavf__misc.html#ga67f84bb8799c8da41194f046f4b970c4"> 2972</a></span>&#160;<span class="comment"> * Transfer internal timing information from one stream to another.</span></div><div class="line"><a name="l02973"></a><span class="lineno"><a class="line" href="group__lavf__misc.html#gga67f84bb8799c8da41194f046f4b970c4a925300170a86b606dbe4b2b2a18ad12a"> 2973</a></span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02974"></a><span class="lineno"><a class="line" href="group__lavf__misc.html#gga67f84bb8799c8da41194f046f4b970c4ae6bd8e936313feda91adedd2501ca90b"> 2974</a></span>&#160;<span class="comment"> * This function is useful when doing stream copy.</span></div><div class="line"><a name="l02975"></a><span class="lineno"><a class="line" href="group__lavf__misc.html#gga67f84bb8799c8da41194f046f4b970c4a4b894ad271e07df75e1b8121455ea4ee"> 2975</a></span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02976"></a><span class="lineno"> 2976</span>&#160;<span class="comment"> * @param ofmt     target output format for ost</span></div><div class="line"><a name="l02977"></a><span class="lineno"> 2977</span>&#160;<span class="comment"> * @param ost      output stream which needs timings copy and adjustments</span></div><div class="line"><a name="l02978"></a><span class="lineno"> 2978</span>&#160;<span class="comment"> * @param ist      reference input stream to copy timings from</span></div><div class="line"><a name="l02979"></a><span class="lineno"> 2979</span>&#160;<span class="comment"> * @param copy_tb  define from where the stream codec timebase needs to be imported</span></div><div class="line"><a name="l02980"></a><span class="lineno"> 2980</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02981"></a><span class="lineno"> 2981</span>&#160;<span class="keywordtype">int</span> <a class="code" href="group__lavf__misc.html#gae35832b110d26ffa3e8805b3d55e8f36">avformat_transfer_internal_stream_timing_info</a>(<span class="keyword">const</span> <a class="code" href="structAVOutputFormat.html">AVOutputFormat</a> *ofmt,</div><div class="line"><a name="l02982"></a><span class="lineno"> 2982</span>&#160;                                                  <a class="code" href="structAVStream.html">AVStream</a> *ost, <span class="keyword">const</span> <a class="code" href="structAVStream.html">AVStream</a> *ist,</div><div class="line"><a name="l02983"></a><span class="lineno"> 2983</span>&#160;                                                  <span class="keyword">enum</span> <a class="code" href="group__lavf__misc.html#ga67f84bb8799c8da41194f046f4b970c4">AVTimebaseSource</a> copy_tb);</div><div class="line"><a name="l02984"></a><span class="lineno"> 2984</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02985"></a><span class="lineno"> 2985</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02986"></a><span class="lineno"> 2986</span>&#160;<span class="comment"> * Get the internal codec timebase from a stream.</span></div><div class="line"><a name="l02987"></a><span class="lineno"> 2987</span>&#160;<span class="comment"> *</span></div><div class="line"><a name="l02988"></a><span class="lineno"> 2988</span>&#160;<span class="comment"> * @param st  input stream to extract the timebase from</span></div><div class="line"><a name="l02989"></a><span class="lineno"> 2989</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02990"></a><span class="lineno"> 2990</span>&#160;<a class="code" href="structAVRational.html">AVRational</a> <a class="code" href="group__lavf__misc.html#ga64b609bbdda09ec7b29534a30656eb1a">av_stream_get_codec_timebase</a>(<span class="keyword">const</span> <a class="code" href="structAVStream.html">AVStream</a> *st);</div><div class="line"><a name="l02991"></a><span class="lineno"> 2991</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02992"></a><span class="lineno"> 2992</span>&#160;<span class="comment">/**</span></div><div class="line"><a name="l02993"></a><span class="lineno"> 2993</span>&#160;<span class="comment"> * @}</span></div><div class="line"><a name="l02994"></a><span class="lineno"> 2994</span>&#160;<span class="comment"> */</span></div><div class="line"><a name="l02995"></a><span class="lineno"> 2995</span>&#160;</div><div class="line"><a name="l02996"></a><span class="lineno"> 2996</span>&#160;<span class="preprocessor">#endif </span><span class="comment">/* AVFORMAT_AVFORMAT_H */</span><span class="preprocessor"></span></div><div class="ttc" id="group__lavf__misc_html_ga63a0579d6c2aa72470ac742bbbc1205d"><div class="ttname"><a href="group__lavf__misc.html#ga63a0579d6c2aa72470ac742bbbc1205d">av_url_split</a></div><div class="ttdeci">void av_url_split(char *proto, int proto_size, char *authorization, int authorization_size, char *hostname, int hostname_size, int *port_ptr, char *path, int path_size, const char *url)</div><div class="ttdoc">Split a URL string into components. </div></div>
<div class="ttc" id="structAVFormatContext_html_af3f615ad9ff79fb90f4eb136a1f58065"><div class="ttname"><a href="structAVFormatContext.html#af3f615ad9ff79fb90f4eb136a1f58065">AVFormatContext::io_open</a></div><div class="ttdeci">int(* io_open)(struct AVFormatContext *s, AVIOContext **pb, const char *url, int flags, AVDictionary **options)</div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l01885">avformat.h:1885</a></div></div>
<div class="ttc" id="avformat_8h_html_afacbc85f23a50771e3801bda0a353d91a10f8e7a9d88b7b5e2010ffb496b6cf1a"><div class="ttname"><a href="avformat_8h.html#afacbc85f23a50771e3801bda0a353d91a10f8e7a9d88b7b5e2010ffb496b6cf1a">AVSTREAM_PARSE_TIMESTAMPS</a></div><div class="ttdoc">full parsing and interpolation of timestamps for frames not starting on a packet boundary ...</div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l00795">avformat.h:795</a></div></div>
<div class="ttc" id="structAVIOContext_html"><div class="ttname"><a href="structAVIOContext.html">AVIOContext</a></div><div class="ttdoc">Bytestream IO Context. </div><div class="ttdef"><b>Definition:</b> <a href="avio_8h_source.html#l00161">avio.h:161</a></div></div>
<div class="ttc" id="group__lavf__misc_html_ga46720b0bb28ca455246805be8969ff9e"><div class="ttname"><a href="group__lavf__misc.html#ga46720b0bb28ca455246805be8969ff9e">av_pkt_dump2</a></div><div class="ttdeci">void av_pkt_dump2(FILE *f, const AVPacket *pkt, int dump_payload, const AVStream *st)</div><div class="ttdoc">Send a nice dump of a packet to the specified file stream. </div></div>
<div class="ttc" id="avio_8h_html"><div class="ttname"><a href="avio_8h.html">avio.h</a></div><div class="ttdoc">Buffered I/O operations. </div></div>
<div class="ttc" id="group__lavc__packet_html_ga9a80bfcacc586b483a973272800edb97"><div class="ttname"><a href="group__lavc__packet.html#ga9a80bfcacc586b483a973272800edb97">AVPacketSideDataType</a></div><div class="ttdeci">AVPacketSideDataType</div><div class="ttdef"><b>Definition:</b> <a href="avcodec_8h_source.html#l01140">avcodec.h:1140</a></div></div>
<div class="ttc" id="group__lavf__decoding_html_ga71091e146791c4d181635485447c2830"><div class="ttname"><a href="group__lavf__decoding.html#ga71091e146791c4d181635485447c2830">av_demuxer_open</a></div><div class="ttdeci">attribute_deprecated int av_demuxer_open(AVFormatContext *ic)</div></div>
<div class="ttc" id="structAVFrame_html"><div class="ttname"><a href="structAVFrame.html">AVFrame</a></div><div class="ttdoc">This structure describes decoded (raw) audio or video data. </div><div class="ttdef"><b>Definition:</b> <a href="frame_8h_source.html#l00201">frame.h:201</a></div></div>
<div class="ttc" id="group__lavf__encoding_html_ga37352ed2c63493c38219d935e71db6c1"><div class="ttname"><a href="group__lavf__encoding.html#ga37352ed2c63493c38219d935e71db6c1">av_interleaved_write_frame</a></div><div class="ttdeci">int av_interleaved_write_frame(AVFormatContext *s, AVPacket *pkt)</div><div class="ttdoc">Write a packet to an output media file ensuring correct interleaving. </div></div>
<div class="ttc" id="group__lavf__misc_html_ga3ed7441cb4af0bdd65a4cf51bf35088e"><div class="ttname"><a href="group__lavf__misc.html#ga3ed7441cb4af0bdd65a4cf51bf35088e">av_add_index_entry</a></div><div class="ttdeci">int av_add_index_entry(AVStream *st, int64_t pos, int64_t timestamp, int size, int distance, int flags)</div><div class="ttdoc">Add an index entry into a sorted list. </div></div>
<div class="ttc" id="group__lavf__encoding_html_gaa85cc1774f18f306cd20a40fc50d0b36"><div class="ttname"><a href="group__lavf__encoding.html#gaa85cc1774f18f306cd20a40fc50d0b36">av_write_frame</a></div><div class="ttdeci">int av_write_frame(AVFormatContext *s, AVPacket *pkt)</div><div class="ttdoc">Write a packet to an output media file. </div></div>
<div class="ttc" id="structAVProbeData_html_a0e8504127aff8af25cc9f3c6400b9651"><div class="ttname"><a href="structAVProbeData.html#a0e8504127aff8af25cc9f3c6400b9651">AVProbeData::filename</a></div><div class="ttdeci">const char * filename</div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l00449">avformat.h:449</a></div></div>
<div class="ttc" id="group__lavf__misc_html_ga0f62da0e809045bb21166013c404ce43"><div class="ttname"><a href="group__lavf__misc.html#ga0f62da0e809045bb21166013c404ce43">av_guess_sample_aspect_ratio</a></div><div class="ttdeci">AVRational av_guess_sample_aspect_ratio(AVFormatContext *format, AVStream *stream, AVFrame *frame)</div><div class="ttdoc">Guess the sample aspect ratio of a frame, based on both the stream and the frame aspect ratio...</div></div>
<div class="ttc" id="structAVOutputFormat_html_a1354a9c8542b1b698157218336bd4754"><div class="ttname"><a href="structAVOutputFormat.html#a1354a9c8542b1b698157218336bd4754">AVOutputFormat::video_codec</a></div><div class="ttdeci">enum AVCodecID video_codec</div><div class="ttdoc">default video codec </div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l00518">avformat.h:518</a></div></div>
<div class="ttc" id="time_8h_html"><div class="ttname"><a href="time_8h.html">time.h</a></div></div>
<div class="ttc" id="group__lavf__encoding_html_ga661ee0b2f3dbcaaef5d68f2f5d75e2d4"><div class="ttname"><a href="group__lavf__encoding.html#ga661ee0b2f3dbcaaef5d68f2f5d75e2d4">av_get_output_timestamp</a></div><div class="ttdeci">int av_get_output_timestamp(struct AVFormatContext *s, int stream, int64_t *dts, int64_t *wall)</div><div class="ttdoc">Get timing information for the data currently output. </div></div>
<div class="ttc" id="group__lavf__misc_html_gga67f84bb8799c8da41194f046f4b970c4ae6bd8e936313feda91adedd2501ca90b"><div class="ttname"><a href="group__lavf__misc.html#gga67f84bb8799c8da41194f046f4b970c4ae6bd8e936313feda91adedd2501ca90b">AVFMT_TBCF_DECODER</a></div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l02974">avformat.h:2974</a></div></div>
<div class="ttc" id="group__lavf__decoding_html_ga7e4318244afd6c5fe55cec75d27258b2"><div class="ttname"><a href="group__lavf__decoding.html#ga7e4318244afd6c5fe55cec75d27258b2">av_probe_input_format3</a></div><div class="ttdeci">AVInputFormat * av_probe_input_format3(AVProbeData *pd, int is_opened, int *score_ret)</div><div class="ttdoc">Guess the file format. </div></div>
<div class="ttc" id="structAVInputFormat_html"><div class="ttname"><a href="structAVInputFormat.html">AVInputFormat</a></div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l00642">avformat.h:642</a></div></div>
<div class="ttc" id="demuxing__decoding_8c_html_a3d4c6562f0b27cf0cacbbea5c038c090"><div class="ttname"><a href="demuxing__decoding_8c.html#a3d4c6562f0b27cf0cacbbea5c038c090">pkt</a></div><div class="ttdeci">static AVPacket pkt</div><div class="ttdef"><b>Definition:</b> <a href="demuxing__decoding_8c_source.html#l00054">demuxing_decoding.c:54</a></div></div>
<div class="ttc" id="group__lavf__encoding_html_ga5f6bebdc8c234a5ad9740de89acb15e6"><div class="ttname"><a href="group__lavf__encoding.html#ga5f6bebdc8c234a5ad9740de89acb15e6">av_write_uncoded_frame_query</a></div><div class="ttdeci">int av_write_uncoded_frame_query(AVFormatContext *s, int stream_index)</div><div class="ttdoc">Test whether a muxer supports uncoded frame. </div></div>
<div class="ttc" id="structAVInputFormat_html_a195b445886775084b8e075062d33f09a"><div class="ttname"><a href="structAVInputFormat.html#a195b445886775084b8e075062d33f09a">AVInputFormat::priv_data_size</a></div><div class="ttdeci">int priv_data_size</div><div class="ttdoc">Size of private data so that it can be allocated in the wrapper. </div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l00698">avformat.h:698</a></div></div>
<div class="ttc" id="structAVCodec_html"><div class="ttname"><a href="structAVCodec.html">AVCodec</a></div><div class="ttdoc">AVCodec. </div><div class="ttdef"><b>Definition:</b> <a href="avcodec_8h_source.html#l03365">avcodec.h:3365</a></div></div>
<div class="ttc" id="structAVCodecParameters_html"><div class="ttname"><a href="structAVCodecParameters.html">AVCodecParameters</a></div><div class="ttdoc">This struct describes the properties of an encoded stream. </div><div class="ttdef"><b>Definition:</b> <a href="avcodec_8h_source.html#l03830">avcodec.h:3830</a></div></div>
<div class="ttc" id="avformat_8h_html_ac7070b68d7ca5fd577f9f835556ebeff"><div class="ttname"><a href="avformat_8h.html#ac7070b68d7ca5fd577f9f835556ebeff">av_fmt_ctx_get_duration_estimation_method</a></div><div class="ttdeci">enum AVDurationEstimationMethod av_fmt_ctx_get_duration_estimation_method(const AVFormatContext *ctx)</div><div class="ttdoc">Returns the method used to set ctx-&gt;duration. </div></div>
<div class="ttc" id="structAVFormatContext_html"><div class="ttname"><a href="structAVFormatContext.html">AVFormatContext</a></div><div class="ttdoc">Format I/O context. </div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l01325">avformat.h:1325</a></div></div>
<div class="ttc" id="group__lavf__misc_html_ga12c049178414cc221dfafd4e7f836dea"><div class="ttname"><a href="group__lavf__misc.html#ga12c049178414cc221dfafd4e7f836dea">av_guess_frame_rate</a></div><div class="ttdeci">AVRational av_guess_frame_rate(AVFormatContext *ctx, AVStream *stream, AVFrame *frame)</div><div class="ttdoc">Guess the frame rate, based on both the container and codec information. </div></div>
<div class="ttc" id="group__riff__fourcc_html_gac389e7f9cd19570bd599a61fd1884a4a"><div class="ttname"><a href="group__riff__fourcc.html#gac389e7f9cd19570bd599a61fd1884a4a">avformat_get_mov_audio_tags</a></div><div class="ttdeci">const struct AVCodecTag * avformat_get_mov_audio_tags(void)</div></div>
<div class="ttc" id="dict_8h_html"><div class="ttname"><a href="dict_8h.html">dict.h</a></div><div class="ttdoc">Public dictionary API. </div></div>
<div class="ttc" id="structAVOutputFormat_html_aad55a00e728a020c1dcfaaf695320445"><div class="ttname"><a href="structAVOutputFormat.html#aad55a00e728a020c1dcfaaf695320445">AVOutputFormat::flags</a></div><div class="ttdeci">int flags</div><div class="ttdoc">can use flags: AVFMT_NOFILE, AVFMT_NEEDNUMBER, AVFMT_GLOBALHEADER, AVFMT_NOTIMESTAMPS, AVFMT_VARIABLE_FPS, AVFMT_NODIMENSIONS, AVFMT_NOSTREAMS, AVFMT_ALLOW_FLUSH, AVFMT_TS_NONSTRICT, AVFMT_TS_NEGATIVE </div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l00526">avformat.h:526</a></div></div>
<div class="ttc" id="group__riff__fourcc_html_ga036cfb1a22e899179f932df0cfc6c415"><div class="ttname"><a href="group__riff__fourcc.html#ga036cfb1a22e899179f932df0cfc6c415">avformat_get_riff_video_tags</a></div><div class="ttdeci">const struct AVCodecTag * avformat_get_riff_video_tags(void)</div></div>
<div class="ttc" id="group__lavf__misc_html_ga27b89fa8286af6efb5a69e8db4033b09"><div class="ttname"><a href="group__lavf__misc.html#ga27b89fa8286af6efb5a69e8db4033b09">av_codec_get_id</a></div><div class="ttdeci">enum AVCodecID av_codec_get_id(const struct AVCodecTag *const *tags, unsigned int tag)</div><div class="ttdoc">Get the AVCodecID for the given codec tag tag. </div></div>
<div class="ttc" id="group__lavf__core_html_gaf2d4e0fee66cef99dea2153933e6b907"><div class="ttname"><a href="group__lavf__core.html#gaf2d4e0fee66cef99dea2153933e6b907">avformat_version</a></div><div class="ttdeci">unsigned avformat_version(void)</div><div class="ttdoc">Return the LIBAVFORMAT_VERSION_INT constant. </div></div>
<div class="ttc" id="group__lavf__core_html_ga160fef784175409f945c70e8931accc8"><div class="ttname"><a href="group__lavf__core.html#ga160fef784175409f945c70e8931accc8">avformat_license</a></div><div class="ttdeci">const char * avformat_license(void)</div><div class="ttdoc">Return the libavformat license. </div></div>
<div class="ttc" id="group__lavf__misc_html_gae35832b110d26ffa3e8805b3d55e8f36"><div class="ttname"><a href="group__lavf__misc.html#gae35832b110d26ffa3e8805b3d55e8f36">avformat_transfer_internal_stream_timing_info</a></div><div class="ttdeci">int avformat_transfer_internal_stream_timing_info(const AVOutputFormat *ofmt, AVStream *ost, const AVStream *ist, enum AVTimebaseSource copy_tb)</div><div class="ttdoc">Transfer internal timing information from one stream to another. </div></div>
<div class="ttc" id="avformat_8h_html_a7bec8d592652431045d81a02fef74f28"><div class="ttname"><a href="avformat_8h.html#a7bec8d592652431045d81a02fef74f28">AVFormatInternal</a></div><div class="ttdeci">struct AVFormatInternal AVFormatInternal</div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l01309">avformat.h:1309</a></div></div>
<div class="ttc" id="structAVOutputFormat_html_ad7677ef35d272b2dad5498c51b4d2204"><div class="ttname"><a href="structAVOutputFormat.html#ad7677ef35d272b2dad5498c51b4d2204">AVOutputFormat::priv_data_size</a></div><div class="ttdeci">int priv_data_size</div><div class="ttdoc">size of private data so that it can be allocated in the wrapper </div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l00548">avformat.h:548</a></div></div>
<div class="ttc" id="avformat_8h_html_a5989dd9dc73f1e05d7cce92a056180bd"><div class="ttname"><a href="avformat_8h.html#a5989dd9dc73f1e05d7cce92a056180bd">AVStreamInternal</a></div><div class="ttdeci">struct AVStreamInternal AVStreamInternal</div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l00849">avformat.h:849</a></div></div>
<div class="ttc" id="group__lavf__misc_html_gga67f84bb8799c8da41194f046f4b970c4a925300170a86b606dbe4b2b2a18ad12a"><div class="ttname"><a href="group__lavf__misc.html#gga67f84bb8799c8da41194f046f4b970c4a925300170a86b606dbe4b2b2a18ad12a">AVFMT_TBCF_AUTO</a></div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l02973">avformat.h:2973</a></div></div>
<div class="ttc" id="group__lavf__misc_html_ga7e45597834e9ef3098ddb74bc5e1550c"><div class="ttname"><a href="group__lavf__misc.html#ga7e45597834e9ef3098ddb74bc5e1550c">avformat_match_stream_specifier</a></div><div class="ttdeci">int avformat_match_stream_specifier(AVFormatContext *s, AVStream *st, const char *spec)</div><div class="ttdoc">Check if the stream st contained in s is matched by the stream specifier spec. </div></div>
<div class="ttc" id="avformat_8h_html_a7c2692ffa20d3e888e40e79eeda6d73b"><div class="ttname"><a href="avformat_8h.html#a7c2692ffa20d3e888e40e79eeda6d73b">AVDurationEstimationMethod</a></div><div class="ttdeci">AVDurationEstimationMethod</div><div class="ttdoc">The duration of a video can be estimated through various ways, and this enum can be used to know how ...</div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l01303">avformat.h:1303</a></div></div>
<div class="ttc" id="group__lavf__core_html_gadcb0fd3e507d9b58fe78f61f8ad39827"><div class="ttname"><a href="group__lavf__core.html#gadcb0fd3e507d9b58fe78f61f8ad39827">avformat_new_stream</a></div><div class="ttdeci">AVStream * avformat_new_stream(AVFormatContext *s, const AVCodec *c)</div><div class="ttdoc">Add a new stream to a media file. </div></div>
<div class="ttc" id="group__lavf__core_html_ga2c3404067d7e9bc7b8443e3f58cf8e65"><div class="ttname"><a href="group__lavf__core.html#ga2c3404067d7e9bc7b8443e3f58cf8e65">av_stream_get_side_data</a></div><div class="ttdeci">uint8_t * av_stream_get_side_data(const AVStream *stream, enum AVPacketSideDataType type, int *size)</div><div class="ttdoc">Get side information from stream. </div></div>
<div class="ttc" id="group__lavf__misc_html_gabe1a7b6824078229c69b75c71053c035"><div class="ttname"><a href="group__lavf__misc.html#gabe1a7b6824078229c69b75c71053c035">av_codec_get_tag2</a></div><div class="ttdeci">int av_codec_get_tag2(const struct AVCodecTag *const *tags, enum AVCodecID id, unsigned int *tag)</div><div class="ttdoc">Get the codec tag for the given codec id. </div></div>
<div class="ttc" id="demuxing__decoding_8c_html_ad7d33d579a8d4241a5e643e39287a209"><div class="ttname"><a href="demuxing__decoding_8c.html#ad7d33d579a8d4241a5e643e39287a209">frame</a></div><div class="ttdeci">static AVFrame * frame</div><div class="ttdef"><b>Definition:</b> <a href="demuxing__decoding_8c_source.html#l00053">demuxing_decoding.c:53</a></div></div>
<div class="ttc" id="group__lavf__core_html_gac7a91abf2f59648d995894711f070f62"><div class="ttname"><a href="group__lavf__core.html#gac7a91abf2f59648d995894711f070f62">avformat_alloc_context</a></div><div class="ttdeci">AVFormatContext * avformat_alloc_context(void)</div><div class="ttdoc">Allocate an AVFormatContext. </div></div>
<div class="ttc" id="group__lavf__misc_html_gaab9fad988c28cc1c4dcbba24a36b6113"><div class="ttname"><a href="group__lavf__misc.html#gaab9fad988c28cc1c4dcbba24a36b6113">av_pkt_dump_log2</a></div><div class="ttdeci">void av_pkt_dump_log2(void *avcl, int level, const AVPacket *pkt, int dump_payload, const AVStream *st)</div><div class="ttdoc">Send a nice dump of a packet to the log. </div></div>
<div class="ttc" id="group__lavf__core_html_ga5f48b0398d77d8eeb45d6c649e4e3404"><div class="ttname"><a href="group__lavf__core.html#ga5f48b0398d77d8eeb45d6c649e4e3404">avformat_configuration</a></div><div class="ttdeci">const char * avformat_configuration(void)</div><div class="ttdoc">Return the libavformat build-time configuration. </div></div>
<div class="ttc" id="avformat_8h_html_a1a5362deb573c857ad801ec212ef3583"><div class="ttname"><a href="avformat_8h.html#a1a5362deb573c857ad801ec212ef3583">MAX_REORDER_DELAY</a></div><div class="ttdeci">#define MAX_REORDER_DELAY</div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l01093">avformat.h:1093</a></div></div>
<div class="ttc" id="structAVFormatContext_html_a32379cc371463b235d54235d4af06a15"><div class="ttname"><a href="structAVFormatContext.html#a32379cc371463b235d54235d4af06a15">AVFormatContext::flags</a></div><div class="ttdeci">int flags</div><div class="ttdoc">Flags modifying the (de)muxer behaviour. </div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l01436">avformat.h:1436</a></div></div>
<div class="ttc" id="structAVPacketList_html"><div class="ttname"><a href="structAVPacketList.html">AVPacketList</a></div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l01962">avformat.h:1962</a></div></div>
<div class="ttc" id="group__lavf__core_html_gab31f7c7c99dcadead38e8e83e0fdb828"><div class="ttname"><a href="group__lavf__core.html#gab31f7c7c99dcadead38e8e83e0fdb828">av_new_program</a></div><div class="ttdeci">AVProgram * av_new_program(AVFormatContext *s, int id)</div></div>
<div class="ttc" id="structAVFormatContext_html_adfa686249f83379ee2e3d5b295d9f442"><div class="ttname"><a href="structAVFormatContext.html#adfa686249f83379ee2e3d5b295d9f442">AVFormatContext::protocol_whitelist</a></div><div class="ttdeci">char * protocol_whitelist</div><div class="ttdoc">&amp;#39;,&amp;#39; separated list of allowed protocols. </div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l01863">avformat.h:1863</a></div></div>
<div class="ttc" id="group__lavf__core_html_ga84542023693d61e8564c5d457979c932"><div class="ttname"><a href="group__lavf__core.html#ga84542023693d61e8564c5d457979c932">avformat_network_init</a></div><div class="ttdeci">int avformat_network_init(void)</div><div class="ttdoc">Do global initialization of network components. </div></div>
<div class="ttc" id="group__riff__fourcc_html_ga8b9668cfd684804ebe7ab14b05aa3ba0"><div class="ttname"><a href="group__riff__fourcc.html#ga8b9668cfd684804ebe7ab14b05aa3ba0">avformat_get_riff_audio_tags</a></div><div class="ttdeci">const struct AVCodecTag * avformat_get_riff_audio_tags(void)</div></div>
<div class="ttc" id="group__lavf__misc_html_gaa2a7353a6bb0c8726797abd56b176af0"><div class="ttname"><a href="group__lavf__misc.html#gaa2a7353a6bb0c8726797abd56b176af0">av_sdp_create</a></div><div class="ttdeci">int av_sdp_create(AVFormatContext *ac[], int n_files, char *buf, int size)</div><div class="ttdoc">Generate an SDP for an RTP session. </div></div>
<div class="ttc" id="avformat_8h_html_a9d2e6f22150d98c36dcc2c6c49318019"><div class="ttname"><a href="avformat_8h.html#a9d2e6f22150d98c36dcc2c6c49318019">av_get_packet</a></div><div class="ttdeci">int av_get_packet(AVIOContext *s, AVPacket *pkt, int size)</div><div class="ttdoc">Allocate and read the payload of a packet and initialize its fields with default values. </div></div>
<div class="ttc" id="group__lavf__misc_html_ga8247f49e5642dd3bd20ce6ba5a7f6466"><div class="ttname"><a href="group__lavf__misc.html#ga8247f49e5642dd3bd20ce6ba5a7f6466">av_match_ext</a></div><div class="ttdeci">int av_match_ext(const char *filename, const char *extensions)</div><div class="ttdoc">Return a positive value if the given filename has one of the given extensions, 0 otherwise. </div></div>
<div class="ttc" id="group__lavf__core_html_ga6030789ce395ef543306bbe933619749"><div class="ttname"><a href="group__lavf__core.html#ga6030789ce395ef543306bbe933619749">avformat_get_class</a></div><div class="ttdeci">const AVClass * avformat_get_class(void)</div><div class="ttdoc">Get the AVClass for AVFormatContext. </div></div>
<div class="ttc" id="group__lavf__decoding_html_gafba896fafa5947fefeb47360f0bb0237"><div class="ttname"><a href="group__lavf__decoding.html#gafba896fafa5947fefeb47360f0bb0237">av_probe_input_buffer2</a></div><div class="ttdeci">int av_probe_input_buffer2(AVIOContext *pb, AVInputFormat **fmt, const char *url, void *logctx, unsigned int offset, unsigned int max_probe_size)</div><div class="ttdoc">Probe a bytestream to determine the input format. </div></div>
<div class="ttc" id="avformat_8h_html_afacbc85f23a50771e3801bda0a353d91a4a4190f226593e92724285f8bfef9c2e"><div class="ttname"><a href="avformat_8h.html#afacbc85f23a50771e3801bda0a353d91a4a4190f226593e92724285f8bfef9c2e">AVSTREAM_PARSE_FULL_RAW</a></div><div class="ttdoc">full parsing and repack with timestamp and position generation by parser for raw this assumes that ea...</div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l00797">avformat.h:797</a></div></div>
<div class="ttc" id="avformat_8h_html_a7c2692ffa20d3e888e40e79eeda6d73ba6185e1e7f8dfae85596779408ef496b2"><div class="ttname"><a href="avformat_8h.html#a7c2692ffa20d3e888e40e79eeda6d73ba6185e1e7f8dfae85596779408ef496b2">AVFMT_DURATION_FROM_BITRATE</a></div><div class="ttdoc">Duration estimated from bitrate (less accurate) </div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l01306">avformat.h:1306</a></div></div>
<div class="ttc" id="avformat_8h_html_a0e991213ccc3d642972b57a1decb797b"><div class="ttname"><a href="avformat_8h.html#a0e991213ccc3d642972b57a1decb797b">av_append_packet</a></div><div class="ttdeci">int av_append_packet(AVIOContext *s, AVPacket *pkt, int size)</div><div class="ttdoc">Read data and append it to the current content of the AVPacket. </div></div>
<div class="ttc" id="group__riff__fourcc_html_ga36261b12dba43e0cba5a753ecb3d0e54"><div class="ttname"><a href="group__riff__fourcc.html#ga36261b12dba43e0cba5a753ecb3d0e54">avformat_get_mov_video_tags</a></div><div class="ttdeci">const struct AVCodecTag * avformat_get_mov_video_tags(void)</div></div>
<div class="ttc" id="avformat_8h_html_a6ddf3d982feb45fa5081420ee911f5d5"><div class="ttname"><a href="avformat_8h.html#a6ddf3d982feb45fa5081420ee911f5d5">avformat_alloc_output_context2</a></div><div class="ttdeci">int avformat_alloc_output_context2(AVFormatContext **ctx, AVOutputFormat *oformat, const char *format_name, const char *filename)</div><div class="ttdoc">Allocate an AVFormatContext for an output format. </div></div>
<div class="ttc" id="avformat_8h_html_afacbc85f23a50771e3801bda0a353d91ac715de62daa60e31ce01b9671bd35f9e"><div class="ttname"><a href="avformat_8h.html#afacbc85f23a50771e3801bda0a353d91ac715de62daa60e31ce01b9671bd35f9e">AVSTREAM_PARSE_NONE</a></div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l00792">avformat.h:792</a></div></div>
<div class="ttc" id="group__lavf__misc_html_gae2645941f2dc779c307eb6314fd39f10"><div class="ttname"><a href="group__lavf__misc.html#gae2645941f2dc779c307eb6314fd39f10">av_dump_format</a></div><div class="ttdeci">void av_dump_format(AVFormatContext *ic, int index, const char *url, int is_output)</div><div class="ttdoc">Print detailed information about the input or output format, such as duration, bitrate, streams, container, programs, metadata, side data, codec and time base. </div></div>
<div class="ttc" id="structAVIOInterruptCB_html"><div class="ttname"><a href="structAVIOInterruptCB.html">AVIOInterruptCB</a></div><div class="ttdoc">Callback for checking whether to abort blocking functions. </div><div class="ttdef"><b>Definition:</b> <a href="avio_8h_source.html#l00058">avio.h:58</a></div></div>
<div class="ttc" id="group__lavf__decoding_html_gaa6fa468c922ff5c60a6021dcac09aff9"><div class="ttname"><a href="group__lavf__decoding.html#gaa6fa468c922ff5c60a6021dcac09aff9">av_find_best_stream</a></div><div class="ttdeci">int av_find_best_stream(AVFormatContext *ic, enum AVMediaType type, int wanted_stream_nb, int related_stream, AVCodec **decoder_ret, int flags)</div><div class="ttdoc">Find the &quot;best&quot; stream in the file. </div></div>
<div class="ttc" id="group__lavf__misc_html_ga64b609bbdda09ec7b29534a30656eb1a"><div class="ttname"><a href="group__lavf__misc.html#ga64b609bbdda09ec7b29534a30656eb1a">av_stream_get_codec_timebase</a></div><div class="ttdeci">AVRational av_stream_get_codec_timebase(const AVStream *st)</div><div class="ttdoc">Get the internal codec timebase from a stream. </div></div>
<div class="ttc" id="group__lavf__decoding_html_ga85cab6fb4038a82d90b4adea8c253943"><div class="ttname"><a href="group__lavf__decoding.html#ga85cab6fb4038a82d90b4adea8c253943">av_probe_input_buffer</a></div><div class="ttdeci">int av_probe_input_buffer(AVIOContext *pb, AVInputFormat **fmt, const char *url, void *logctx, unsigned int offset, unsigned int max_probe_size)</div><div class="ttdoc">Like av_probe_input_buffer2() but returns 0 on success. </div></div>
<div class="ttc" id="group__lavf__decoding_html_ga9edb9ac206ed05dc5baa9d168f31de48"><div class="ttname"><a href="group__lavf__decoding.html#ga9edb9ac206ed05dc5baa9d168f31de48">av_find_program_from_stream</a></div><div class="ttdeci">AVProgram * av_find_program_from_stream(AVFormatContext *ic, AVProgram *last, int s)</div><div class="ttdoc">Find the programs which belong to a given stream. </div></div>
<div class="ttc" id="group__lavc__core_html_gaadca229ad2c20e060a14fec08a5cc7ce"><div class="ttname"><a href="group__lavc__core.html#gaadca229ad2c20e060a14fec08a5cc7ce">AVCodecID</a></div><div class="ttdeci">AVCodecID</div><div class="ttdoc">Identify the syntax and semantics of the bitstream. </div><div class="ttdef"><b>Definition:</b> <a href="avcodec_8h_source.html#l00215">avcodec.h:215</a></div></div>
<div class="ttc" id="group__lavf__misc_html_gac4cabc0d681c34b2e2c6a87a55877f0d"><div class="ttname"><a href="group__lavf__misc.html#gac4cabc0d681c34b2e2c6a87a55877f0d">av_index_search_timestamp</a></div><div class="ttdeci">int av_index_search_timestamp(AVStream *st, int64_t timestamp, int flags)</div><div class="ttdoc">Get the index for a specific timestamp. </div></div>
<div class="ttc" id="group__lavf__misc_html_gab533a6d5d830ab90573dd035002c5bca"><div class="ttname"><a href="group__lavf__misc.html#gab533a6d5d830ab90573dd035002c5bca">av_hex_dump</a></div><div class="ttdeci">void av_hex_dump(FILE *f, const uint8_t *buf, int size)</div><div class="ttdoc">Send a nice hexadecimal dump of a buffer to the specified file stream. </div></div>
<div class="ttc" id="structAVCodecParserContext_html_a540286a805755b5b1f9d213f9f1d7109"><div class="ttname"><a href="structAVCodecParserContext.html#a540286a805755b5b1f9d213f9f1d7109">AVCodecParserContext::parser</a></div><div class="ttdeci">struct AVCodecParser * parser</div><div class="ttdef"><b>Definition:</b> <a href="avcodec_8h_source.html#l04943">avcodec.h:4943</a></div></div>
<div class="ttc" id="avformat_8h_html_a125e78a8250557501479986fead28a43"><div class="ttname"><a href="avformat_8h.html#a125e78a8250557501479986fead28a43">av_stream_get_parser</a></div><div class="ttdeci">struct AVCodecParserContext * av_stream_get_parser(const AVStream *s)</div></div>
<div class="ttc" id="group__lavu__dict_html_ga1d7cc0833bee918994a600556410315f"><div class="ttname"><a href="group__lavu__dict.html#ga1d7cc0833bee918994a600556410315f">AVDictionary</a></div><div class="ttdeci">struct AVDictionary AVDictionary</div><div class="ttdef"><b>Definition:</b> <a href="dict_8h_source.html#l00090">dict.h:90</a></div></div>
<div class="ttc" id="group__lavf__decoding_html_ga7494bb63a59e79e9fe88eb1682d4d7b3"><div class="ttname"><a href="group__lavf__decoding.html#ga7494bb63a59e79e9fe88eb1682d4d7b3">av_read_play</a></div><div class="ttdeci">int av_read_play(AVFormatContext *s)</div><div class="ttdoc">Start playing a network-based stream (e.g. </div></div>
<div class="ttc" id="structAVProgram_html"><div class="ttname"><a href="structAVProgram.html">AVProgram</a></div><div class="ttdoc">New fields can be added to the end with minor version bumps. </div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l01252">avformat.h:1252</a></div></div>
<div class="ttc" id="group__lavf__decoding_html_gae8b938f6e7c3741dd27a6c171e72f33d"><div class="ttname"><a href="group__lavf__decoding.html#gae8b938f6e7c3741dd27a6c171e72f33d">av_probe_input_format2</a></div><div class="ttdeci">AVInputFormat * av_probe_input_format2(AVProbeData *pd, int is_opened, int *score_max)</div><div class="ttdoc">Guess the file format. </div></div>
<div class="ttc" id="structAVFormatContext_html_a71797838db59ca0682dd2d18b149134e"><div class="ttname"><a href="structAVFormatContext.html#a71797838db59ca0682dd2d18b149134e">AVFormatContext::opaque</a></div><div class="ttdeci">void * opaque</div><div class="ttdoc">User data. </div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l01809">avformat.h:1809</a></div></div>
<div class="ttc" id="avformat_8h_html_afacbc85f23a50771e3801bda0a353d91a67bc09fcdeb0e05754f344fbc80856ca"><div class="ttname"><a href="avformat_8h.html#afacbc85f23a50771e3801bda0a353d91a67bc09fcdeb0e05754f344fbc80856ca">AVSTREAM_PARSE_HEADERS</a></div><div class="ttdoc">Only parse headers, do not repack. </div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l00794">avformat.h:794</a></div></div>
<div class="ttc" id="group__lavf__misc_html_gaa90b4c72d1bbb298e11096d3a09ec7db"><div class="ttname"><a href="group__lavf__misc.html#gaa90b4c72d1bbb298e11096d3a09ec7db">avformat_query_codec</a></div><div class="ttdeci">int avformat_query_codec(const AVOutputFormat *ofmt, enum AVCodecID codec_id, int std_compliance)</div><div class="ttdoc">Test if the given container can store a codec. </div></div>
<div class="ttc" id="structAVProbeData_html_a20533bdafa6230d2ef8392cb7cb38382"><div class="ttname"><a href="structAVProbeData.html#a20533bdafa6230d2ef8392cb7cb38382">AVProbeData::mime_type</a></div><div class="ttdeci">const char * mime_type</div><div class="ttdoc">mime_type, when known. </div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l00452">avformat.h:452</a></div></div>
<div class="ttc" id="structAVProbeData_html_a30309e4de25c1a411c635eab767e1e53"><div class="ttname"><a href="structAVProbeData.html#a30309e4de25c1a411c635eab767e1e53">AVProbeData::buf_size</a></div><div class="ttdeci">int buf_size</div><div class="ttdoc">Size of buf except extra allocated bytes. </div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l00451">avformat.h:451</a></div></div>
<div class="ttc" id="structAVProbeData_html_a814cca49dda3f578ebb32d4b2f74368a"><div class="ttname"><a href="structAVProbeData.html#a814cca49dda3f578ebb32d4b2f74368a">AVProbeData::buf</a></div><div class="ttdeci">unsigned char * buf</div><div class="ttdoc">Buffer must have AVPROBE_PADDING_SIZE of extra allocated bytes filled with zero. </div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l00450">avformat.h:450</a></div></div>
<div class="ttc" id="avformat_8h_html_aa3a096ee52bc6b1e0f31278d26996777"><div class="ttname"><a href="avformat_8h.html#aa3a096ee52bc6b1e0f31278d26996777">av_format_inject_global_side_data</a></div><div class="ttdeci">void av_format_inject_global_side_data(AVFormatContext *s)</div><div class="ttdoc">This function will cause global side data to be injected in the next packet of each stream as well as...</div></div>
<div class="ttc" id="group__lavf__decoding_html_ga27db687592d99f25ccf81a3b3ee8da9c"><div class="ttname"><a href="group__lavf__decoding.html#ga27db687592d99f25ccf81a3b3ee8da9c">av_read_pause</a></div><div class="ttdeci">int av_read_pause(AVFormatContext *s)</div><div class="ttdoc">Pause a network-based stream (e.g. </div></div>
<div class="ttc" id="group__lavf__decoding_html_ga7d2f532c6653c2419b17956712fdf3da"><div class="ttname"><a href="group__lavf__decoding.html#ga7d2f532c6653c2419b17956712fdf3da">av_find_input_format</a></div><div class="ttdeci">AVInputFormat * av_find_input_format(const char *short_name)</div><div class="ttdoc">Find AVInputFormat based on the short name of the input format. </div></div>
<div class="ttc" id="structAVOutputFormat_html_aa867a120bd90779111565907b327ba61"><div class="ttname"><a href="structAVOutputFormat.html#aa867a120bd90779111565907b327ba61">AVOutputFormat::write_header</a></div><div class="ttdeci">int(* write_header)(struct AVFormatContext *)</div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l00550">avformat.h:550</a></div></div>
<div class="ttc" id="group__lavf__encoding_html_ga18b7b10bb5b94c4842de18166bc677cb"><div class="ttname"><a href="group__lavf__encoding.html#ga18b7b10bb5b94c4842de18166bc677cb">avformat_write_header</a></div><div class="ttdeci">av_warn_unused_result int avformat_write_header(AVFormatContext *s, AVDictionary **options)</div><div class="ttdoc">Allocate the stream private data and write the stream header to an output media file. </div></div>
<div class="ttc" id="group__lavf__decoding_html_gaa59b7800da8ec11457c1e5b3fc295a20"><div class="ttname"><a href="group__lavf__decoding.html#gaa59b7800da8ec11457c1e5b3fc295a20">av_program_add_stream_index</a></div><div class="ttdeci">void av_program_add_stream_index(AVFormatContext *ac, int progid, unsigned int idx)</div></div>
<div class="ttc" id="avformat_8h_html_a80856b99bcf4373936fb4fba028b11ca"><div class="ttname"><a href="avformat_8h.html#a80856b99bcf4373936fb4fba028b11ca">av_format_control_message</a></div><div class="ttdeci">int(* av_format_control_message)(struct AVFormatContext *s, int type, void *data, size_t data_size)</div><div class="ttdoc">Callback used by devices to communicate with application. </div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l01293">avformat.h:1293</a></div></div>
<div class="ttc" id="group__lavf__core_html_ga5c8d715704c153cb645982444063cc2b"><div class="ttname"><a href="group__lavf__core.html#ga5c8d715704c153cb645982444063cc2b">av_stream_add_side_data</a></div><div class="ttdeci">int av_stream_add_side_data(AVStream *st, enum AVPacketSideDataType type, uint8_t *data, size_t size)</div><div class="ttdoc">Wrap an existing array as stream side data. </div></div>
<div class="ttc" id="group__lavf__encoding_html_gae8a1efab53a348857f209ea51037da4c"><div class="ttname"><a href="group__lavf__encoding.html#gae8a1efab53a348857f209ea51037da4c">av_guess_codec</a></div><div class="ttdeci">enum AVCodecID av_guess_codec(AVOutputFormat *fmt, const char *short_name, const char *filename, const char *mime_type, enum AVMediaType type)</div><div class="ttdoc">Guess the codec ID based upon muxer and filename. </div></div>
<div class="ttc" id="structAVFormatContext_html_a11bf0a9a1ba16bc402c6a237b58b4da1"><div class="ttname"><a href="structAVFormatContext.html#a11bf0a9a1ba16bc402c6a237b58b4da1">AVFormatContext::max_streams</a></div><div class="ttdeci">int max_streams</div><div class="ttdoc">The maximum number of streams. </div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l01905">avformat.h:1905</a></div></div>
<div class="ttc" id="group__lavf__misc_html_gaad9737492bb66aeeec37b7c7d8d90f2a"><div class="ttname"><a href="group__lavf__misc.html#gaad9737492bb66aeeec37b7c7d8d90f2a">av_find_default_stream_index</a></div><div class="ttdeci">int av_find_default_stream_index(AVFormatContext *s)</div></div>
<div class="ttc" id="structAVIndexEntry_html"><div class="ttname"><a href="structAVIndexEntry.html">AVIndexEntry</a></div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l00802">avformat.h:802</a></div></div>
<div class="ttc" id="avformat_8h_html_a7c2692ffa20d3e888e40e79eeda6d73bae92edb9576c3d6dd68f49a849a2ec6c0"><div class="ttname"><a href="avformat_8h.html#a7c2692ffa20d3e888e40e79eeda6d73bae92edb9576c3d6dd68f49a849a2ec6c0">AVFMT_DURATION_FROM_STREAM</a></div><div class="ttdoc">Duration estimated from a stream with a known duration. </div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l01305">avformat.h:1305</a></div></div>
<div class="ttc" id="group__lavf__core_html_gae324697cedd36e7b47a1e142dc24b805"><div class="ttname"><a href="group__lavf__core.html#gae324697cedd36e7b47a1e142dc24b805">av_stream_new_side_data</a></div><div class="ttdeci">uint8_t * av_stream_new_side_data(AVStream *stream, enum AVPacketSideDataType type, int size)</div><div class="ttdoc">Allocate new information from stream. </div></div>
<div class="ttc" id="group__lavf__encoding_html_ga8795680bd7489e96eeb5aef5e615cacc"><div class="ttname"><a href="group__lavf__encoding.html#ga8795680bd7489e96eeb5aef5e615cacc">av_guess_format</a></div><div class="ttdeci">AVOutputFormat * av_guess_format(const char *short_name, const char *filename, const char *mime_type)</div><div class="ttdoc">Return the output format in the list of registered output formats which best matches the provided par...</div></div>
<div class="ttc" id="group__lavf__core_html_ga896f319308627b5b66fd41a4b1d53ae6"><div class="ttname"><a href="group__lavf__core.html#ga896f319308627b5b66fd41a4b1d53ae6">av_register_input_format</a></div><div class="ttdeci">void av_register_input_format(AVInputFormat *format)</div></div>
<div class="ttc" id="libavformat_2version_8h_html"><div class="ttname"><a href="libavformat_2version_8h.html">version.h</a></div><div class="ttdoc">Libavformat version macros. </div></div>
<div class="ttc" id="avformat_8h_html_a6f7cab62acdf2bce2883a3c82cf1a27c"><div class="ttname"><a href="avformat_8h.html#a6f7cab62acdf2bce2883a3c82cf1a27c">AVOpenCallback</a></div><div class="ttdeci">int(* AVOpenCallback)(struct AVFormatContext *s, AVIOContext **pb, const char *url, int flags, const AVIOInterruptCB *int_cb, AVDictionary **options)</div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l01296">avformat.h:1296</a></div></div>
<div class="ttc" id="group__lavf__core_html_ga8fe016b9e8df67a5ffde855f2f891d71"><div class="ttname"><a href="group__lavf__core.html#ga8fe016b9e8df67a5ffde855f2f891d71">av_oformat_next</a></div><div class="ttdeci">AVOutputFormat * av_oformat_next(const AVOutputFormat *f)</div><div class="ttdoc">If f is NULL, returns the first registered output format, if f is non-NULL, returns the next register...</div></div>
<div class="ttc" id="group__lavf__encoding_html_ga169cfa28508e22e138c5b99be8517ea4"><div class="ttname"><a href="group__lavf__encoding.html#ga169cfa28508e22e138c5b99be8517ea4">avformat_init_output</a></div><div class="ttdeci">av_warn_unused_result int avformat_init_output(AVFormatContext *s, AVDictionary **options)</div><div class="ttdoc">Allocate the stream private data and initialize the codec, but do not write the header. </div></div>
<div class="ttc" id="structAVCodecParserContext_html"><div class="ttname"><a href="structAVCodecParserContext.html">AVCodecParserContext</a></div><div class="ttdef"><b>Definition:</b> <a href="avcodec_8h_source.html#l04941">avcodec.h:4941</a></div></div>
<div class="ttc" id="group__lavf__misc_html_ga90e027a5d9006148413a1387c506cd40"><div class="ttname"><a href="group__lavf__misc.html#ga90e027a5d9006148413a1387c506cd40">av_get_frame_filename</a></div><div class="ttdeci">int av_get_frame_filename(char *buf, int buf_size, const char *path, int number)</div></div>
<div class="ttc" id="structAVBitStreamFilterContext_html"><div class="ttname"><a href="structAVBitStreamFilterContext.html">AVBitStreamFilterContext</a></div><div class="ttdef"><b>Definition:</b> <a href="avcodec_8h_source.html#l05558">avcodec.h:5558</a></div></div>
<div class="ttc" id="structAVStream_html"><div class="ttname"><a href="structAVStream.html">AVStream</a></div><div class="ttdoc">Stream structure. </div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l00872">avformat.h:872</a></div></div>
<div class="ttc" id="avio__reading_8c_html_a3a86bff38e7cb9093d0a32316b73b29c"><div class="ttname"><a href="avio__reading_8c.html#a3a86bff38e7cb9093d0a32316b73b29c">read_packet</a></div><div class="ttdeci">static int read_packet(void *opaque, uint8_t *buf, int buf_size)</div><div class="ttdef"><b>Definition:</b> <a href="avio__reading_8c_source.html#l00042">avio_reading.c:42</a></div></div>
<div class="ttc" id="group__lavf__misc_html_ga501ff1b3aa357c09da90c0effb356e45"><div class="ttname"><a href="group__lavf__misc.html#ga501ff1b3aa357c09da90c0effb356e45">avformat_queue_attached_pictures</a></div><div class="ttdeci">int avformat_queue_attached_pictures(AVFormatContext *s)</div></div>
<div class="ttc" id="group__lavf__core_html_gabf0629358bc40c7874932ef6f4dda6b8"><div class="ttname"><a href="group__lavf__core.html#gabf0629358bc40c7874932ef6f4dda6b8">av_register_output_format</a></div><div class="ttdeci">void av_register_output_format(AVOutputFormat *format)</div></div>
<div class="ttc" id="group__lavf__core_html_ga245f2875f80ce67ec3d1e0f54dacf2c4"><div class="ttname"><a href="group__lavf__core.html#ga245f2875f80ce67ec3d1e0f54dacf2c4">avformat_network_deinit</a></div><div class="ttdeci">int avformat_network_deinit(void)</div><div class="ttdoc">Undo the initialization done by avformat_network_init. </div></div>
<div class="ttc" id="structAVPacketSideData_html"><div class="ttname"><a href="structAVPacketSideData.html">AVPacketSideData</a></div><div class="ttdef"><b>Definition:</b> <a href="avcodec_8h_source.html#l01357">avcodec.h:1357</a></div></div>
<div class="ttc" id="avcodec_8h_html"><div class="ttname"><a href="avcodec_8h.html">avcodec.h</a></div><div class="ttdoc">Libavcodec external API header. </div></div>
<div class="ttc" id="structAVOutputFormat_html_a381830276f0c71583a0ca014fcd2fc97"><div class="ttname"><a href="structAVOutputFormat.html#a381830276f0c71583a0ca014fcd2fc97">AVOutputFormat::next</a></div><div class="ttdeci">struct AVOutputFormat * next</div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l00544">avformat.h:544</a></div></div>
<div class="ttc" id="structAVFormatContext_html_a1e7324262b6b78522e52064daaa7bc87"><div class="ttname"><a href="structAVFormatContext.html#a1e7324262b6b78522e52064daaa7bc87">AVFormatContext::pb</a></div><div class="ttdeci">AVIOContext * pb</div><div class="ttdoc">I/O context. </div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l01367">avformat.h:1367</a></div></div>
<div class="ttc" id="structAVCodecContext_html"><div class="ttname"><a href="structAVCodecContext.html">AVCodecContext</a></div><div class="ttdoc">main external API structure. </div><div class="ttdef"><b>Definition:</b> <a href="avcodec_8h_source.html#l01502">avcodec.h:1502</a></div></div>
<div class="ttc" id="group__lavf__misc_html_gac20eb319c6c46f581b5d08f5c25e763e"><div class="ttname"><a href="group__lavf__misc.html#gac20eb319c6c46f581b5d08f5c25e763e">av_filename_number_test</a></div><div class="ttdeci">int av_filename_number_test(const char *filename)</div><div class="ttdoc">Check whether filename actually is a numbered sequence generator. </div></div>
<div class="ttc" id="group__lavf__misc_html_ga05f17637161cd79506f67b20ea8149c9"><div class="ttname"><a href="group__lavf__misc.html#ga05f17637161cd79506f67b20ea8149c9">av_get_frame_filename2</a></div><div class="ttdeci">int av_get_frame_filename2(char *buf, int buf_size, const char *path, int number, int flags)</div><div class="ttdoc">Return in &amp;#39;buf&amp;#39; the path with &amp;#39;d&amp;#39; replaced by a number. </div></div>
<div class="ttc" id="structAVFormatContext_html_a88077ea47abd7cd3fefe7828f778a686"><div class="ttname"><a href="structAVFormatContext.html#a88077ea47abd7cd3fefe7828f778a686">AVFormatContext::io_close</a></div><div class="ttdeci">void(* io_close)(struct AVFormatContext *s, AVIOContext *pb)</div><div class="ttdoc">A callback for closing the streams opened with AVFormatContext.io_open(). </div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l01891">avformat.h:1891</a></div></div>
<div class="ttc" id="structAVClass_html"><div class="ttname"><a href="structAVClass.html">AVClass</a></div><div class="ttdoc">Describe the class of an AVClass context structure. </div><div class="ttdef"><b>Definition:</b> <a href="log_8h_source.html#l00067">log.h:67</a></div></div>
<div class="ttc" id="structAVOutputFormat_html_adc8b4d7a5f6610e1816dd522e362217c"><div class="ttname"><a href="structAVOutputFormat.html#adc8b4d7a5f6610e1816dd522e362217c">AVOutputFormat::subtitle_codec</a></div><div class="ttdeci">enum AVCodecID subtitle_codec</div><div class="ttdoc">default subtitle codec </div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l00519">avformat.h:519</a></div></div>
<div class="ttc" id="structAVRational_html"><div class="ttname"><a href="structAVRational.html">AVRational</a></div><div class="ttdoc">Rational number (pair of numerator and denominator). </div><div class="ttdef"><b>Definition:</b> <a href="rational_8h_source.html#l00058">rational.h:58</a></div></div>
<div class="ttc" id="group__lavu__misc_html_ga9a84bba4713dfced21a1a56163be1f48"><div class="ttname"><a href="group__lavu__misc.html#ga9a84bba4713dfced21a1a56163be1f48">AVMediaType</a></div><div class="ttdeci">AVMediaType</div><div class="ttdef"><b>Definition:</b> <a href="avutil_8h_source.html#l00199">avutil.h:199</a></div></div>
<div class="ttc" id="group__lavf__misc_html_gga67f84bb8799c8da41194f046f4b970c4a4b894ad271e07df75e1b8121455ea4ee"><div class="ttname"><a href="group__lavf__misc.html#gga67f84bb8799c8da41194f046f4b970c4a4b894ad271e07df75e1b8121455ea4ee">AVFMT_TBCF_DEMUXER</a></div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l02975">avformat.h:2975</a></div></div>
<div class="ttc" id="group__lavf__core_html_gac2990b13b68e831a408fce8e1d0d6445"><div class="ttname"><a href="group__lavf__core.html#gac2990b13b68e831a408fce8e1d0d6445">avformat_free_context</a></div><div class="ttdeci">void avformat_free_context(AVFormatContext *s)</div><div class="ttdoc">Free an AVFormatContext and all its streams. </div></div>
<div class="ttc" id="structAVProbeData_html"><div class="ttname"><a href="structAVProbeData.html">AVProbeData</a></div><div class="ttdoc">This structure contains the data a format has to probe a file. </div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l00448">avformat.h:448</a></div></div>
<div class="ttc" id="group__lavf__decoding_html_ga4fdb3084415a82e3810de6ee60e46a61"><div class="ttname"><a href="group__lavf__decoding.html#ga4fdb3084415a82e3810de6ee60e46a61">av_read_frame</a></div><div class="ttdeci">int av_read_frame(AVFormatContext *s, AVPacket *pkt)</div><div class="ttdoc">Return the next frame of a stream. </div></div>
<div class="ttc" id="structAVDeviceInfoList_html"><div class="ttname"><a href="structAVDeviceInfoList.html">AVDeviceInfoList</a></div><div class="ttdoc">List of devices. </div><div class="ttdef"><b>Definition:</b> <a href="avdevice_8h_source.html#l00460">avdevice.h:460</a></div></div>
<div class="ttc" id="group__lavf__misc_html_ga67f84bb8799c8da41194f046f4b970c4"><div class="ttname"><a href="group__lavf__misc.html#ga67f84bb8799c8da41194f046f4b970c4">AVTimebaseSource</a></div><div class="ttdeci">AVTimebaseSource</div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l02972">avformat.h:2972</a></div></div>
<div class="ttc" id="group__lavf__decoding_html_ga3b40fc8d2fda6992ae6ea2567d71ba30"><div class="ttname"><a href="group__lavf__decoding.html#ga3b40fc8d2fda6992ae6ea2567d71ba30">avformat_seek_file</a></div><div class="ttdeci">int avformat_seek_file(AVFormatContext *s, int stream_index, int64_t min_ts, int64_t ts, int64_t max_ts, int flags)</div><div class="ttdoc">Seek to timestamp ts. </div></div>
<div class="ttc" id="avformat_8h_html_afacbc85f23a50771e3801bda0a353d91a41eb176dd7cfc095b5ea66816a75c56a"><div class="ttname"><a href="avformat_8h.html#afacbc85f23a50771e3801bda0a353d91a41eb176dd7cfc095b5ea66816a75c56a">AVSTREAM_PARSE_FULL_ONCE</a></div><div class="ttdoc">full parsing and repack of the first frame only, only implemented for H.264 currently ...</div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l00796">avformat.h:796</a></div></div>
<div class="ttc" id="structAVInputFormat_html_ac12c67e8e0b7bc2b0c26ab383d9a0c76"><div class="ttname"><a href="structAVInputFormat.html#ac12c67e8e0b7bc2b0c26ab383d9a0c76">AVInputFormat::raw_codec_id</a></div><div class="ttdeci">int raw_codec_id</div><div class="ttdoc">Raw demuxers store their codec ID here. </div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l00693">avformat.h:693</a></div></div>
<div class="ttc" id="attributes_8h_html_aa6d076561d3a9eea4729ee632652de02"><div class="ttname"><a href="attributes_8h.html#aa6d076561d3a9eea4729ee632652de02">attribute_deprecated</a></div><div class="ttdeci">#define attribute_deprecated</div><div class="ttdef"><b>Definition:</b> <a href="attributes_8h_source.html#l00094">attributes.h:94</a></div></div>
<div class="ttc" id="avformat_8h_html_a7c2692ffa20d3e888e40e79eeda6d73bac94465d3290399477775fe094ab8f75a"><div class="ttname"><a href="avformat_8h.html#a7c2692ffa20d3e888e40e79eeda6d73bac94465d3290399477775fe094ab8f75a">AVFMT_DURATION_FROM_PTS</a></div><div class="ttdoc">Duration accurately estimated from PTSes. </div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l01304">avformat.h:1304</a></div></div>
<div class="ttc" id="attributes_8h_html_a93f17e0f0b53a66e7b5eceb3dff2918f"><div class="ttname"><a href="attributes_8h.html#a93f17e0f0b53a66e7b5eceb3dff2918f">av_warn_unused_result</a></div><div class="ttdeci">#define av_warn_unused_result</div><div class="ttdef"><b>Definition:</b> <a href="attributes_8h_source.html#l00056">attributes.h:56</a></div></div>
<div class="ttc" id="group__lavf__decoding_html_gaa23f7619d8d4ea0857065d9979c75ac8"><div class="ttname"><a href="group__lavf__decoding.html#gaa23f7619d8d4ea0857065d9979c75ac8">av_seek_frame</a></div><div class="ttdeci">int av_seek_frame(AVFormatContext *s, int stream_index, int64_t timestamp, int flags)</div><div class="ttdoc">Seek to the keyframe at timestamp. </div></div>
<div class="ttc" id="avformat_8h_html_afacbc85f23a50771e3801bda0a353d91ac21d15a27dac74ca0730b4dace71d883"><div class="ttname"><a href="avformat_8h.html#afacbc85f23a50771e3801bda0a353d91ac21d15a27dac74ca0730b4dace71d883">AVSTREAM_PARSE_FULL</a></div><div class="ttdoc">full parsing and repack </div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l00793">avformat.h:793</a></div></div>
<div class="ttc" id="structAVChapter_html"><div class="ttname"><a href="structAVChapter.html">AVChapter</a></div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l01282">avformat.h:1282</a></div></div>
<div class="ttc" id="group__lavf__encoding_html_gafe9916c601bba6827d6f9271a61260e4"><div class="ttname"><a href="group__lavf__encoding.html#gafe9916c601bba6827d6f9271a61260e4">av_interleaved_write_uncoded_frame</a></div><div class="ttdeci">int av_interleaved_write_uncoded_frame(AVFormatContext *s, int stream_index, AVFrame *frame)</div><div class="ttdoc">Write an uncoded frame to an output media file. </div></div>
<div class="ttc" id="structAVPacketList_html_a6a1d0f1a75cfafa4643b93752edef643"><div class="ttname"><a href="structAVPacketList.html#a6a1d0f1a75cfafa4643b93752edef643">AVPacketList::next</a></div><div class="ttdeci">struct AVPacketList * next</div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l01964">avformat.h:1964</a></div></div>
<div class="ttc" id="structAVOutputFormat_html_ac4c06882481a62fd0de7396909b02796"><div class="ttname"><a href="structAVOutputFormat.html#ac4c06882481a62fd0de7396909b02796">AVOutputFormat::data_codec</a></div><div class="ttdeci">enum AVCodecID data_codec</div><div class="ttdoc">default data codec </div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l00607">avformat.h:607</a></div></div>
<div class="ttc" id="group__lavf__decoding_html_gad42172e27cddafb81096939783b157bb"><div class="ttname"><a href="group__lavf__decoding.html#gad42172e27cddafb81096939783b157bb">avformat_find_stream_info</a></div><div class="ttdeci">int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options)</div><div class="ttdoc">Read packets of a media file to get stream information. </div></div>
<div class="ttc" id="avformat_8h_html_afacbc85f23a50771e3801bda0a353d91"><div class="ttname"><a href="avformat_8h.html#afacbc85f23a50771e3801bda0a353d91">AVStreamParseType</a></div><div class="ttdeci">AVStreamParseType</div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l00791">avformat.h:791</a></div></div>
<div class="ttc" id="structAVOutputFormat_html"><div class="ttname"><a href="structAVOutputFormat.html">AVOutputFormat</a></div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l00506">avformat.h:506</a></div></div>
<div class="ttc" id="group__lavf__decoding_html_gae804b99aec044690162b8b9b110236a4"><div class="ttname"><a href="group__lavf__decoding.html#gae804b99aec044690162b8b9b110236a4">avformat_close_input</a></div><div class="ttdeci">void avformat_close_input(AVFormatContext **s)</div><div class="ttdoc">Close an opened input AVFormatContext. </div></div>
<div class="ttc" id="group__lavf__encoding_html_gaab766dccdff1bf323a2fc604e723b441"><div class="ttname"><a href="group__lavf__encoding.html#gaab766dccdff1bf323a2fc604e723b441">av_write_uncoded_frame</a></div><div class="ttdeci">int av_write_uncoded_frame(AVFormatContext *s, int stream_index, AVFrame *frame)</div><div class="ttdoc">Write an uncoded frame to an output media file. </div></div>
<div class="ttc" id="structAVInputFormat_html_a286d65d159570516e5ed38fcbb842d5a"><div class="ttname"><a href="structAVInputFormat.html#a286d65d159570516e5ed38fcbb842d5a">AVInputFormat::read_header</a></div><div class="ttdeci">int(* read_header)(struct AVFormatContext *)</div><div class="ttdoc">Read the format header and initialize the AVFormatContext structure. </div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l00712">avformat.h:712</a></div></div>
<div class="ttc" id="structAVOutputFormat_html_a2e4fff0aa061984d586ea08ecad96141"><div class="ttname"><a href="structAVOutputFormat.html#a2e4fff0aa061984d586ea08ecad96141">AVOutputFormat::audio_codec</a></div><div class="ttdeci">enum AVCodecID audio_codec</div><div class="ttdoc">default audio codec </div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l00517">avformat.h:517</a></div></div>
<div class="ttc" id="log_8h_html"><div class="ttname"><a href="log_8h.html">log.h</a></div></div>
<div class="ttc" id="group__lavf__decoding_html_ga31d601155e9035d5b0e7efedc894ee49"><div class="ttname"><a href="group__lavf__decoding.html#ga31d601155e9035d5b0e7efedc894ee49">avformat_open_input</a></div><div class="ttdeci">int avformat_open_input(AVFormatContext **ps, const char *url, AVInputFormat *fmt, AVDictionary **options)</div><div class="ttdoc">Open an input stream and read the header. </div></div>
<div class="ttc" id="group__lavc__decoding_html_ga352363bce7d3ed82c101b3bc001d1c16"><div class="ttname"><a href="group__lavc__decoding.html#ga352363bce7d3ed82c101b3bc001d1c16">AVDiscard</a></div><div class="ttdeci">AVDiscard</div><div class="ttdef"><b>Definition:</b> <a href="avcodec_8h_source.html#l00782">avcodec.h:782</a></div></div>
<div class="ttc" id="group__lavf__encoding_html_ga7f14007e7dc8f481f054b21614dfec13"><div class="ttname"><a href="group__lavf__encoding.html#ga7f14007e7dc8f481f054b21614dfec13">av_write_trailer</a></div><div class="ttdeci">int av_write_trailer(AVFormatContext *s)</div><div class="ttdoc">Write the stream trailer to an output media file and free the file private data. </div></div>
<div class="ttc" id="structAVFormatContext_html_ae06bb84162881843504ecd870c328690"><div class="ttname"><a href="structAVFormatContext.html#ae06bb84162881843504ecd870c328690">AVFormatContext::protocol_blacklist</a></div><div class="ttdeci">char * protocol_blacklist</div><div class="ttdoc">&amp;#39;,&amp;#39; separated list of disallowed protocols. </div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l01898">avformat.h:1898</a></div></div>
<div class="ttc" id="group__lavf__decoding_html_gaa03a82c5fd4fe3af312d229ca94cd6f3"><div class="ttname"><a href="group__lavf__decoding.html#gaa03a82c5fd4fe3af312d229ca94cd6f3">avformat_flush</a></div><div class="ttdeci">int avformat_flush(AVFormatContext *s)</div><div class="ttdoc">Discard all internally buffered data. </div></div>
<div class="ttc" id="structAVInputFormat_html_a2e272c7785fdd26895b1af1867b62567"><div class="ttname"><a href="structAVInputFormat.html#a2e272c7785fdd26895b1af1867b62567">AVInputFormat::read_probe</a></div><div class="ttdeci">int(* read_probe)(AVProbeData *)</div><div class="ttdoc">Tell if a given file has a chance of being parsed as this format. </div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l00705">avformat.h:705</a></div></div>
<div class="ttc" id="group__lavf__misc_html_ga56f93dbd118ff5fe833a2e39b685974c"><div class="ttname"><a href="group__lavf__misc.html#ga56f93dbd118ff5fe833a2e39b685974c">av_hex_dump_log</a></div><div class="ttdeci">void av_hex_dump_log(void *avcl, int level, const uint8_t *buf, int size)</div><div class="ttdoc">Send a nice hexadecimal dump of a buffer to the log. </div></div>
<div class="ttc" id="structAVInputFormat_html_ad18d8584bb0648f53a7980be8f368164"><div class="ttname"><a href="structAVInputFormat.html#ad18d8584bb0648f53a7980be8f368164">AVInputFormat::next</a></div><div class="ttdeci">struct AVInputFormat * next</div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l00688">avformat.h:688</a></div></div>
<div class="ttc" id="group__lavf__misc_html_ga126917b7ce8b4f05505098b72f4997de"><div class="ttname"><a href="group__lavf__misc.html#ga126917b7ce8b4f05505098b72f4997de">av_codec_get_tag</a></div><div class="ttdeci">unsigned int av_codec_get_tag(const struct AVCodecTag *const *tags, enum AVCodecID id)</div><div class="ttdoc">Get the codec tag for the given codec id id. </div></div>
<div class="ttc" id="group__lavf__decoding_html_gad8a1268228fff3aeae0aeaa99a767a24"><div class="ttname"><a href="group__lavf__decoding.html#gad8a1268228fff3aeae0aeaa99a767a24">av_probe_input_format</a></div><div class="ttdeci">AVInputFormat * av_probe_input_format(AVProbeData *pd, int is_opened)</div><div class="ttdoc">Guess the file format. </div></div>
<div class="ttc" id="structAVDeviceCapabilitiesQuery_html"><div class="ttname"><a href="structAVDeviceCapabilitiesQuery.html">AVDeviceCapabilitiesQuery</a></div><div class="ttdoc">Following API allows user to probe device capabilities (supported codecs, pixel formats, sample formats, resolutions, channel counts, etc). </div><div class="ttdef"><b>Definition:</b> <a href="avdevice_8h_source.html#l00400">avdevice.h:400</a></div></div>
<div class="ttc" id="structAVPacket_html"><div class="ttname"><a href="structAVPacket.html">AVPacket</a></div><div class="ttdoc">This structure stores compressed data. </div><div class="ttdef"><b>Definition:</b> <a href="avcodec_8h_source.html#l01391">avcodec.h:1391</a></div></div>
<div class="ttc" id="group__lavf__core_html_ga917265caec45ef5a0646356ed1a507e3"><div class="ttname"><a href="group__lavf__core.html#ga917265caec45ef5a0646356ed1a507e3">av_register_all</a></div><div class="ttdeci">void av_register_all(void)</div><div class="ttdoc">Initialize libavformat and register all the muxers, demuxers and protocols. </div></div>
<div class="ttc" id="avformat_8h_html_a79d6ee9e699fd534e85543752f3cb775"><div class="ttname"><a href="avformat_8h.html#a79d6ee9e699fd534e85543752f3cb775">MAX_STD_TIMEBASES</a></div><div class="ttdeci">#define MAX_STD_TIMEBASES</div><div class="ttdoc">Stream information used internally by avformat_find_stream_info() </div><div class="ttdef"><b>Definition:</b> <a href="avformat_8h_source.html#l01029">avformat.h:1029</a></div></div>
<div class="ttc" id="avformat_8h_html_aea2211b21ee4a9a443886c2e0a63be1c"><div class="ttname"><a href="avformat_8h.html#aea2211b21ee4a9a443886c2e0a63be1c">av_stream_get_end_pts</a></div><div class="ttdeci">int64_t av_stream_get_end_pts(const AVStream *st)</div><div class="ttdoc">Returns the pts of the last muxed packet + its duration. </div></div>
<div class="ttc" id="group__lavf__core_html_ga64ff7d30d32639e69fe57f99bb48f680"><div class="ttname"><a href="group__lavf__core.html#ga64ff7d30d32639e69fe57f99bb48f680">av_iformat_next</a></div><div class="ttdeci">AVInputFormat * av_iformat_next(const AVInputFormat *f)</div><div class="ttdoc">If f is NULL, returns the first registered input format, if f is non-NULL, returns the next registere...</div></div>
</div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
